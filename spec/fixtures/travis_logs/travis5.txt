travis_fold:start:worker_info
[0K[33;1mWorker information[0m
hostname: production-2-worker-com-b-1-gce:6b0b80ab-d038-4959-9390-d3ca924e8944
version: v2.9.3 https://github.com/travis-ci/worker/tree/a41c772c638071fbbdbc106f31a664c0532e0c36
instance: testing-gce-041c17ff-a5c6-4dd8-a635-0d81b1f1bbff:travis-ci-garnet-trusty-1499451966 (via amqp)
startup: 21.390497439s
travis_fold:end:worker_info
[0Ktravis_fold:start:system_info
[0K[33;1mBuild system information[0m

Build language: ruby

Build group: stable

Build dist: trusty

Build id: 52422318

Job id: 86779313

travis-build version: 3a278b3be

[34m[1mBuild image provisioning date and time[0m

Fri Jul  7 18:51:38 UTC 2017

[34m[1mOperating System Details[0m

Distributor ID:	Ubuntu

Description:	Ubuntu 14.04.5 LTS

Release:	14.04

Codename:	trusty

[34m[1mLinux Version[0m

4.4.0-81-generic

[34m[1mCookbooks Version[0m

15a6f94 https://github.com/travis-ci/travis-cookbooks/tree/15a6f94

[34m[1mgit version[0m

git version 2.13.0

[34m[1mbash version[0m

GNU bash, version 4.3.11(1)-release (x86_64-pc-linux-gnu)

[34m[1mgcc version[0m

gcc (Ubuntu 4.8.4-2ubuntu1~14.04.3) 4.8.4

Copyright (C) 2013 Free Software Foundation, Inc.

This is free software; see the source for copying conditions.  There is NO

warranty; not even for MERCHANTABILITY or FITNESS FOR A PARTICULAR PURPOSE.



[34m[1mdocker version[0m

Client:

 Version:      17.03.1-ce

 API version:  1.27

 Go version:   go1.7.5

 Git commit:   c6d412e

 Built:        Mon Mar 27 17:10:36 2017

 OS/Arch:      linux/amd64



Server:

 Version:      17.03.1-ce

 API version:  1.27 (minimum version 1.12)

 Go version:   go1.7.5

 Git commit:   c6d412e

 Built:        Mon Mar 27 17:10:36 2017

 OS/Arch:      linux/amd64

 Experimental: false

[34m[1mclang version[0m

clang version 3.5.0 (tags/RELEASE_350/final)

Target: x86_64-unknown-linux-gnu

Thread model: posix

[34m[1mjq version[0m

jq-1.5

[34m[1mbats version[0m

Bats 0.4.0

[34m[1mshellcheck version[0m

0.4.5

[34m[1mshfmt version[0m

v1.0.0

[34m[1mccache version[0m

ccache version 3.1.9



Copyright (C) 2002-2007 Andrew Tridgell

Copyright (C) 2009-2011 Joel Rosdahl



This program is free software; you can redistribute it and/or modify it under

the terms of the GNU General Public License as published by the Free Software

Foundation; either version 3 of the License, or (at your option) any later

version.

[34m[1mcmake version[0m

cmake version 3.2.2



CMake suite maintained and supported by Kitware (kitware.com/cmake).

[34m[1mheroku version[0m

heroku-cli/6.12.5-17216bc (linux-x64) node-v8.1.3

[34m[1mimagemagick version[0m

Version: ImageMagick 6.7.7-10 2017-05-26 Q16 http://www.imagemagick.org

[34m[1mmd5deep version[0m

4.2

[34m[1mmercurial version[0m

Mercurial Distributed SCM (version 4.2.2)

(see https://mercurial-scm.org for more information)



Copyright (C) 2005-2017 Matt Mackall and others

This is free software; see the source for copying conditions. There is NO

warranty; not even for MERCHANTABILITY or FITNESS FOR A PARTICULAR PURPOSE.

[34m[1mmysql version[0m

mysql  Ver 14.14 Distrib 5.6.33, for debian-linux-gnu (x86_64) using  EditLine wrapper

[34m[1mopenssl version[0m

OpenSSL 1.0.2j  26 Sep 2016

[34m[1mpacker version[0m

Packer v0.10.1



Your version of Packer is out of date! The latest version

is 1.0.2. You can update by downloading from www.packer.io

[34m[1mpostgresql client version[0m

psql (PostgreSQL) 9.6.3

[34m[1mragel version[0m

Ragel State Machine Compiler version 6.8 Feb 2013

Copyright (c) 2001-2009 by Adrian Thurston

[34m[1msubversion version[0m

svn, version 1.8.8 (r1568071)

   compiled Aug 20 2015, 12:51:30 on x86_64-pc-linux-gnu



Copyright (C) 2013 The Apache Software Foundation.

This software consists of contributions made by many people;

see the NOTICE file for more information.

Subversion is open source software, see http://subversion.apache.org/



The following repository access (RA) modules are available:



* ra_svn : Module for accessing a repository using the svn network protocol.

  - with Cyrus SASL authentication

  - handles 'svn' scheme

* ra_local : Module for accessing a repository on local disk.

  - handles 'file' scheme

* ra_serf : Module for accessing a repository via WebDAV protocol using serf.

  - using serf 1.3.3

  - handles 'http' scheme

  - handles 'https' scheme



[34m[1msudo version[0m

Sudo version 1.8.9p5

Configure options: --prefix=/usr -v --with-all-insults --with-pam --with-fqdn --with-logging=syslog --with-logfac=authpriv --with-env-editor --with-editor=/usr/bin/editor --with-timeout=15 --with-password-timeout=0 --with-passprompt=[sudo] password for %p:  --without-lecture --with-tty-tickets --disable-root-mailer --enable-admin-flag --with-sendmail=/usr/sbin/sendmail --with-timedir=/var/lib/sudo --mandir=/usr/share/man --libexecdir=/usr/lib/sudo --with-sssd --with-sssd-lib=/usr/lib/x86_64-linux-gnu --with-selinux

Sudoers policy plugin version 1.8.9p5

Sudoers file grammar version 43



Sudoers path: /etc/sudoers

Authentication methods: 'pam'

Syslog facility if syslog is being used for logging: authpriv

Syslog priority to use when user authenticates successfully: notice

Syslog priority to use when user authenticates unsuccessfully: alert

Send mail if the user is not in sudoers

Use a separate timestamp for each user/tty combo

Lecture user the first time they run sudo

Root may run sudo

Allow some information gathering to give useful error messages

Require fully-qualified hostnames in the sudoers file

Visudo will honor the EDITOR environment variable

Set the LOGNAME and USER environment variables

Length at which to wrap log file lines (0 for no wrap): 80

Authentication timestamp timeout: 15.0 minutes

Password prompt timeout: 0.0 minutes

Number of tries to enter a password: 3

Umask to use or 0777 to use user's: 022

Path to mail program: /usr/sbin/sendmail

Flags for mail program: -t

Address to send mail to: root

Subject line for mail messages: *** SECURITY information for %h ***

Incorrect password message: Sorry, try again.

Path to authentication timestamp dir: /var/lib/sudo

Default password prompt: [sudo] password for %p:

Default user to run commands as: root

Value to override user's $PATH with: /usr/local/sbin:/usr/local/bin:/usr/sbin:/usr/bin:/sbin:/bin:/snap/bin

Path to the editor for use by visudo: /usr/bin/editor

When to require a password for 'list' pseudocommand: any

When to require a password for 'verify' pseudocommand: all

File descriptors >= 3 will be closed before executing a command

Environment variables to check for sanity:

	TZ

	TERM

	LINGUAS

	LC_*

	LANGUAGE

	LANG

	COLORTERM

Environment variables to remove:

	RUBYOPT

	RUBYLIB

	PYTHONUSERBASE

	PYTHONINSPECT

	PYTHONPATH

	PYTHONHOME

	TMPPREFIX

	ZDOTDIR

	READNULLCMD

	NULLCMD

	FPATH

	PERL5DB

	PERL5OPT

	PERL5LIB

	PERLLIB

	PERLIO_DEBUG

	JAVA_TOOL_OPTIONS

	SHELLOPTS

	GLOBIGNORE

	PS4

	BASH_ENV

	ENV

	TERMCAP

	TERMPATH

	TERMINFO_DIRS

	TERMINFO

	_RLD*

	LD_*

	PATH_LOCALE

	NLSPATH

	HOSTALIASES

	RES_OPTIONS

	LOCALDOMAIN

	CDPATH

	IFS

Environment variables to preserve:

	JAVA_HOME

	TRAVIS

	CI

	DEBIAN_FRONTEND

	XAUTHORIZATION

	XAUTHORITY

	PS2

	PS1

	PATH

	LS_COLORS

	KRB5CCNAME

	HOSTNAME

	HOME

	DISPLAY

	COLORS

Locale to use while parsing sudoers: C

Directory in which to store input/output logs: /var/log/sudo-io

File in which to store the input/output log: %{seq}

Add an entry to the utmp/utmpx file when allocating a pty

PAM service name to use

PAM service name to use for login shells

Create a new PAM session for the command to run in

Maximum I/O log sequence number: 0



Local IP address and netmask pairs:

	10.240.0.5/255.255.255.255

	172.17.0.1/255.255.0.0



Sudoers I/O plugin version 1.8.9p5

[34m[1mgzip version[0m

gzip 1.6

Copyright (C) 2007, 2010, 2011 Free Software Foundation, Inc.

Copyright (C) 1993 Jean-loup Gailly.

This is free software.  You may redistribute copies of it under the terms of

the GNU General Public License <http://www.gnu.org/licenses/gpl.html>.

There is NO WARRANTY, to the extent permitted by law.



Written by Jean-loup Gailly.

[34m[1mzip version[0m

Copyright (c) 1990-2008 Info-ZIP - Type 'zip "-L"' for software license.

This is Zip 3.0 (July 5th 2008), by Info-ZIP.

Currently maintained by E. Gordon.  Please send bug reports to

the authors using the web page at www.info-zip.org; see README for details.



Latest sources and executables are at ftp://ftp.info-zip.org/pub/infozip,

as of above date; see http://www.info-zip.org/ for other sites.



Compiled with gcc 4.8.2 for Unix (Linux ELF) on Oct 21 2013.



Zip special compilation options:

	USE_EF_UT_TIME       (store Universal Time)

	BZIP2_SUPPORT        (bzip2 library version 1.0.6, 6-Sept-2010)

	    bzip2 code and library copyright (c) Julian R Seward

	    (See the bzip2 license for terms of use)

	SYMLINK_SUPPORT      (symbolic links supported)

	LARGE_FILE_SUPPORT   (can read and write large files on file system)

	ZIP64_SUPPORT        (use Zip64 to store large files in archives)

	UNICODE_SUPPORT      (store and read UTF-8 Unicode paths)

	STORE_UNIX_UIDs_GIDs (store UID/GID sizes/values using new extra field)

	UIDGID_NOT_16BIT     (old Unix 16-bit UID/GID extra field not used)

	[encryption, version 2.91 of 05 Jan 2007] (modified for Zip 3)



Encryption notice:

	The encryption code of this program is not copyrighted and is

	put in the public domain.  It was originally written in Europe

	and, to the best of our knowledge, can be freely distributed

	in both source and object forms from any country, including

	the USA under License Exception TSU of the U.S. Export

	Administration Regulations (section 740.13(e)) of 6 June 2002.



Zip environment options:

             ZIP:  [none]

          ZIPOPT:  [none]

[34m[1mvim version[0m

VIM - Vi IMproved 7.4 (2013 Aug 10, compiled Nov 24 2016 16:43:18)

Included patches: 1-52

Extra patches: 8.0.0056

Modified by pkg-vim-maintainers@lists.alioth.debian.org

Compiled by buildd@

Huge version without GUI.  Features included (+) or not (-):

+acl             +farsi           +mouse_netterm   +syntax

+arabic          +file_in_path    +mouse_sgr       +tag_binary

+autocmd         +find_in_path    -mouse_sysmouse  +tag_old_static

-balloon_eval    +float           +mouse_urxvt     -tag_any_white

-browse          +folding         +mouse_xterm     -tcl

++builtin_terms  -footer          +multi_byte      +terminfo

+byte_offset     +fork()          +multi_lang      +termresponse

+cindent         +gettext         -mzscheme        +textobjects

-clientserver    -hangul_input    +netbeans_intg   +title

-clipboard       +iconv           +path_extra      -toolbar

+cmdline_compl   +insert_expand   -perl            +user_commands

+cmdline_hist    +jumplist        +persistent_undo +vertsplit

+cmdline_info    +keymap          +postscript      +virtualedit

+comments        +langmap         +printer         +visual

+conceal         +libcall         +profile         +visualextra

+cryptv          +linebreak       +python          +viminfo

+cscope          +lispindent      -python3         +vreplace

+cursorbind      +listcmds        +quickfix        +wildignore

+cursorshape     +localmap        +reltime         +wildmenu

+dialog_con      -lua             +rightleft       +windows

+diff            +menu            -ruby            +writebackup

+digraphs        +mksession       +scrollbind      -X11

-dnd             +modify_fname    +signs           -xfontset

-ebcdic          +mouse           +smartindent     -xim

+emacs_tags      -mouseshape      -sniff           -xsmp

+eval            +mouse_dec       +startuptime     -xterm_clipboard

+ex_extra        +mouse_gpm       +statusline      -xterm_save

+extra_search    -mouse_jsbterm   -sun_workshop    -xpm

   system vimrc file: "$VIM/vimrc"

     user vimrc file: "$HOME/.vimrc"

 2nd user vimrc file: "~/.vim/vimrc"

      user exrc file: "$HOME/.exrc"

  fall-back for $VIM: "/usr/share/vim"

Compilation: gcc -c -I. -Iproto -DHAVE_CONFIG_H     -g -O2 -fstack-protector --param=ssp-buffer-size=4 -Wformat -Werror=format-security -U_FORTIFY_SOURCE -D_FORTIFY_SOURCE=1

Linking: gcc   -Wl,-Bsymbolic-functions -Wl,-z,relro -Wl,--as-needed -o vim        -lm -ltinfo -lnsl  -lselinux  -lacl -lattr -lgpm -ldl    -L/usr/lib/python2.7/config-x86_64-linux-gnu -lpython2.7 -lpthread -ldl -lutil -lm -Xlinker -export-dynamic -Wl,-O1 -Wl,-Bsymbolic-functions

[34m[1miptables version[0m

iptables v1.4.21

[34m[1mcurl version[0m

curl 7.35.0 (x86_64-pc-linux-gnu) libcurl/7.35.0 OpenSSL/1.0.1f zlib/1.2.8 libidn/1.28 librtmp/2.3

[34m[1mwget version[0m

GNU Wget 1.15 built on linux-gnu.

[34m[1mrsync version[0m

rsync  version 3.1.0  protocol version 31

[34m[1mgimme version[0m

v1.0.0

[34m[1mnvm version[0m

0.33.0

[34m[1mperlbrew version[0m

/home/travis/perl5/perlbrew/bin/perlbrew  - App::perlbrew/0.80

[34m[1mphpenv version[0m

rbenv 1.1.1-2-g615f844

[34m[1mrvm version[0m

rvm 1.29.2 (latest) by Michal Papis, Piotr Kuczynski, Wayne E. Seguin [https://rvm.io/]

[34m[1mdefault ruby version[0m

ruby 2.4.1p111 (2017-03-22 revision 58053) [x86_64-linux]

[34m[1mCouchDB version[0m

couchdb 1.6.1

[34m[1mElasticSearch version[0m

5.4.3

[34m[1mInstalled Firefox version[0m

firefox 50.0.2

[34m[1mMongoDB version[0m

MongoDB 3.2.15

[34m[1mPre-installed PostgreSQL versions[0m

9.2.21

9.3.17

9.4.12

9.5.7

9.6.3

[34m[1mRabbitMQ Version[0m

3.6.10

[34m[1mRedis version[0m

redis-server 3.2.9

[34m[1mriak version[0m

2.2.3

[34m[1mPre-installed Go versions[0m

1.7.4

[34m[1mant version[0m

Apache Ant(TM) version 1.9.3 compiled on April 8 2014

[34m[1mmvn version[0m

Apache Maven 3.3.9 (bb52d8502b132ec0a5a3f4c09453c07478323dc5; 2015-11-10T16:41:47+00:00)

Maven home: /usr/local/maven-3.3.9

Java version: 1.8.0_131, vendor: Oracle Corporation

Java home: /usr/lib/jvm/java-8-oracle/jre

Default locale: en_US, platform encoding: UTF-8

OS name: "linux", version: "4.4.0-81-generic", arch: "amd64", family: "unix"

[34m[1mgradle version[0m



------------------------------------------------------------

Gradle 3.2.1

------------------------------------------------------------



Build time:   2016-11-22 15:19:54 UTC

Revision:     83b485b914fd4f335ad0e66af9d14aad458d2cc5



Groovy:       2.4.7

Ant:          Apache Ant(TM) version 1.9.6 compiled on June 29 2015

JVM:          1.8.0_131 (Oracle Corporation 25.131-b11)

OS:           Linux 4.4.0-81-generic amd64



[34m[1mlein version[0m

WARNING: You're currently running as root; probably by accident.

Press control-C to abort or Enter to continue as root.

Set LEIN_ROOT to disable this warning.

Leiningen 2.7.1 on Java 1.8.0_131 Java HotSpot(TM) 64-Bit Server VM

[34m[1mPre-installed Node.js versions[0m

v4.8.3

v6.11.0

v6.9.4

v7.4

v7.4.0

[34m[1mphpenv versions[0m

  system

  5.6

* 5.6.24 (set by /home/travis/.phpenv/version)

  7.0

  7.0.7

  hhvm

  hhvm-stable

[34m[1mcomposer --version[0m

Composer version 1.2.0 2016-07-19 01:28:52

[34m[1mPre-installed Ruby versions[0m

ruby-2.2.7

ruby-2.3.4

ruby-2.4.1

travis_fold:end:system_info
[0K

W: http://dl.hhvm.com/ubuntu/dists/trusty/InRelease: Signature by key 36AEF64D0207E7EEE352D4875A16E7281BE7A449 uses weak digest algorithm (SHA1)

W: http://ppa.launchpad.net/couchdb/stable/ubuntu/dists/trusty/Release.gpg: Signature by key 15866BAFD9BCC4F3C1E0DFC7D69548E1C17EAB57 uses weak digest algorithm (SHA1)

[33;1mPatching redis-server init script[0m



Installing an SSH key from: travis yaml

Key fingerprint: 68:68:a3:f3:ec:40:4b:b6:b8:df:a5:88:30:43:fb:6a



travis_fold:start:git.checkout
[0Ktravis_time:start:09c942f3
[0K$ git clone --depth=50 git@github.com:Liaison-Intl/WebAdMIT.git Liaison-Intl/WebAdMIT

Cloning into 'Liaison-Intl/WebAdMIT'...

Warning: Permanently added the RSA host key for IP address '192.30.253.112' to the list of known hosts.


remote: Counting objects: 34836, done.[K

remote: Compressing objects:   0% (1/14767)   [K
remote: Compressing objects:   1% (148/14767)   [K
remote: Compressing objects:   2% (296/14767)   [K
remote: Compressing objects:   3% (444/14767)   [K
remote: Compressing objects:   3% (572/14767)   [K
remote: Compressing objects:   4% (591/14767)   [K
remote: Compressing objects:   5% (739/14767)   [K
remote: Compressing objects:   6% (887/14767)   [K
remote: Compressing objects:   7% (1034/14767)   [K
remote: Compressing objects:   8% (1182/14767)   [K
remote: Compressing objects:   9% (1330/14767)   [K
remote: Compressing objects:  10% (1477/14767)   [K
remote: Compressing objects:  11% (1625/14767)   [K
remote: Compressing objects:  12% (1773/14767)   [K
remote: Compressing objects:  13% (1920/14767)   [K
remote: Compressing objects:  14% (2068/14767)   [K
remote: Compressing objects:  15% (2216/14767)   [K
remote: Compressing objects:  16% (2363/14767)   [K
remote: Compressing objects:  17% (2511/14767)   [K
remote: Compressing objects:  18% (2659/14767)   [K
remote: Compressing objects:  19% (2806/14767)   [K
remote: Compressing objects:  20% (2954/14767)   [K
remote: Compressing objects:  21% (3102/14767)   [K
remote: Compressing objects:  22% (3249/14767)   [K
remote: Compressing objects:  23% (3397/14767)   [K
remote: Compressing objects:  24% (3545/14767)   [K
remote: Compressing objects:  25% (3692/14767)   [K
remote: Compressing objects:  25% (3733/14767)   [K
remote: Compressing objects:  26% (3840/14767)   [K
remote: Compressing objects:  27% (3988/14767)   [K
remote: Compressing objects:  28% (4135/14767)   [K
remote: Compressing objects:  29% (4283/14767)   [K
remote: Compressing objects:  30% (4431/14767)   [K
remote: Compressing objects:  31% (4578/14767)   [K
remote: Compressing objects:  32% (4726/14767)   [K
remote: Compressing objects:  33% (4874/14767)   [K
remote: Compressing objects:  34% (5021/14767)   [K
remote: Compressing objects:  35% (5169/14767)   [K
remote: Compressing objects:  36% (5317/14767)   [K
remote: Compressing objects:  37% (5464/14767)   [K
remote: Compressing objects:  38% (5612/14767)   [K
remote: Compressing objects:  39% (5760/14767)   [K
remote: Compressing objects:  40% (5907/14767)   [K
remote: Compressing objects:  41% (6055/14767)   [K
remote: Compressing objects:  42% (6203/14767)   [K
remote: Compressing objects:  43% (6350/14767)   [K
remote: Compressing objects:  44% (6498/14767)   [K
remote: Compressing objects:  45% (6646/14767)   [K
remote: Compressing objects:  46% (6793/14767)   [K
remote: Compressing objects:  47% (6941/14767)   [K
remote: Compressing objects:  48% (7089/14767)   [K
remote: Compressing objects:  49% (7236/14767)   [K
remote: Compressing objects:  50% (7384/14767)   [K
remote: Compressing objects:  51% (7532/14767)   [K
remote: Compressing objects:  52% (7679/14767)   [K
remote: Compressing objects:  53% (7827/14767)   [K
remote: Compressing objects:  54% (7975/14767)   [K
remote: Compressing objects:  55% (8122/14767)   [K
remote: Compressing objects:  56% (8270/14767)   [K
remote: Compressing objects:  57% (8418/14767)   [K
remote: Compressing objects:  58% (8565/14767)   [K
remote: Compressing objects:  59% (8713/14767)   [K
remote: Compressing objects:  60% (8861/14767)   [K
remote: Compressing objects:  61% (9008/14767)   [K
remote: Compressing objects:  62% (9156/14767)   [K
remote: Compressing objects:  63% (9304/14767)   [K
remote: Compressing objects:  64% (9451/14767)   [K
remote: Compressing objects:  65% (9599/14767)   [K
remote: Compressing objects:  66% (9747/14767)   [K
remote: Compressing objects:  67% (9894/14767)   [K
remote: Compressing objects:  68% (10042/14767)   [K
remote: Compressing objects:  69% (10190/14767)   [K
remote: Compressing objects:  70% (10337/14767)   [K
remote: Compressing objects:  71% (10485/14767)   [K
remote: Compressing objects:  72% (10633/14767)   [K
remote: Compressing objects:  73% (10780/14767)   [K
remote: Compressing objects:  74% (10928/14767)   [K
remote: Compressing objects:  75% (11076/14767)   [K
remote: Compressing objects:  76% (11223/14767)   [K
remote: Compressing objects:  77% (11371/14767)   [K
remote: Compressing objects:  78% (11519/14767)   [K
remote: Compressing objects:  79% (11666/14767)   [K
remote: Compressing objects:  80% (11814/14767)   [K
remote: Compressing objects:  81% (11962/14767)   [K
remote: Compressing objects:  82% (12109/14767)   [K
remote: Compressing objects:  83% (12257/14767)   [K
remote: Compressing objects:  84% (12405/14767)   [K
remote: Compressing objects:  85% (12552/14767)   [K
remote: Compressing objects:  86% (12700/14767)   [K
remote: Compressing objects:  87% (12848/14767)   [K
remote: Compressing objects:  88% (12995/14767)   [K
remote: Compressing objects:  89% (13143/14767)   [K
remote: Compressing objects:  90% (13291/14767)   [K
remote: Compressing objects:  91% (13438/14767)   [K
remote: Compressing objects:  92% (13586/14767)   [K
remote: Compressing objects:  93% (13734/14767)   [K
remote: Compressing objects:  94% (13881/14767)   [K
remote: Compressing objects:  95% (14029/14767)   [K
remote: Compressing objects:  96% (14177/14767)   [K
remote: Compressing objects:  97% (14324/14767)   [K
remote: Compressing objects:  98% (14472/14767)   [K
remote: Compressing objects:  99% (14620/14767)   [K
remote: Compressing objects: 100% (14767/14767)   [K
remote: Compressing objects: 100% (14767/14767), done.[K

Receiving objects:   0% (1/34836)
Receiving objects:   1% (349/34836)
Receiving objects:   2% (697/34836)
Receiving objects:   3% (1046/34836)
Receiving objects:   4% (1394/34836)
Receiving objects:   5% (1742/34836)
Receiving objects:   6% (2091/34836)
Receiving objects:   7% (2439/34836)
Receiving objects:   8% (2787/34836)
Receiving objects:   9% (3136/34836)
Receiving objects:  10% (3484/34836)
Receiving objects:  11% (3832/34836)
Receiving objects:  12% (4181/34836)
Receiving objects:  13% (4529/34836)
Receiving objects:  14% (4878/34836)
Receiving objects:  15% (5226/34836)
Receiving objects:  16% (5574/34836)
Receiving objects:  17% (5923/34836)
Receiving objects:  18% (6271/34836)
Receiving objects:  19% (6619/34836)
Receiving objects:  20% (6968/34836)
Receiving objects:  21% (7316/34836)
Receiving objects:  22% (7664/34836)
Receiving objects:  23% (8013/34836)
Receiving objects:  24% (8361/34836)
Receiving objects:  25% (8709/34836)
Receiving objects:  26% (9058/34836)
Receiving objects:  27% (9406/34836)
Receiving objects:  28% (9755/34836)
Receiving objects:  29% (10103/34836)
Receiving objects:  30% (10451/34836)
Receiving objects:  31% (10800/34836)
Receiving objects:  32% (11148/34836)
Receiving objects:  33% (11496/34836)
Receiving objects:  34% (11845/34836)
Receiving objects:  35% (12193/34836)
Receiving objects:  36% (12541/34836)
Receiving objects:  37% (12890/34836)
Receiving objects:  38% (13238/34836)
Receiving objects:  39% (13587/34836)
Receiving objects:  40% (13935/34836)
Receiving objects:  41% (14283/34836)
Receiving objects:  42% (14632/34836)
Receiving objects:  43% (14980/34836)
Receiving objects:  44% (15328/34836)
Receiving objects:  45% (15677/34836)
Receiving objects:  46% (16025/34836)
Receiving objects:  47% (16373/34836)
Receiving objects:  48% (16722/34836)
Receiving objects:  49% (17070/34836)
Receiving objects:  50% (17418/34836)
Receiving objects:  51% (17767/34836)
Receiving objects:  52% (18115/34836)
Receiving objects:  53% (18464/34836)
Receiving objects:  54% (18812/34836)
Receiving objects:  55% (19160/34836)
Receiving objects:  56% (19509/34836)
Receiving objects:  57% (19857/34836)
Receiving objects:  58% (20205/34836)
Receiving objects:  59% (20554/34836)
Receiving objects:  60% (20902/34836)
Receiving objects:  61% (21250/34836)
Receiving objects:  62% (21599/34836)
Receiving objects:  63% (21947/34836)
Receiving objects:  64% (22296/34836)
Receiving objects:  65% (22644/34836)
Receiving objects:  66% (22992/34836)
Receiving objects:  67% (23341/34836)
Receiving objects:  68% (23689/34836)
Receiving objects:  69% (24037/34836), 13.38 MiB | 26.74 MiB/s
Receiving objects:  70% (24386/34836), 13.38 MiB | 26.74 MiB/s
Receiving objects:  71% (24734/34836), 13.38 MiB | 26.74 MiB/s
Receiving objects:  72% (25082/34836), 13.38 MiB | 26.74 MiB/s
Receiving objects:  73% (25431/34836), 13.38 MiB | 26.74 MiB/s
Receiving objects:  74% (25779/34836), 13.38 MiB | 26.74 MiB/s
Receiving objects:  75% (26127/34836), 13.38 MiB | 26.74 MiB/s
Receiving objects:  76% (26476/34836), 13.38 MiB | 26.74 MiB/s
Receiving objects:  77% (26824/34836), 13.38 MiB | 26.74 MiB/s
Receiving objects:  78% (27173/34836), 13.38 MiB | 26.74 MiB/s
Receiving objects:  79% (27521/34836), 13.38 MiB | 26.74 MiB/s
Receiving objects:  80% (27869/34836), 13.38 MiB | 26.74 MiB/s
Receiving objects:  81% (28218/34836), 13.38 MiB | 26.74 MiB/s
Receiving objects:  82% (28566/34836), 13.38 MiB | 26.74 MiB/s
Receiving objects:  83% (28914/34836), 13.38 MiB | 26.74 MiB/s
Receiving objects:  84% (29263/34836), 13.38 MiB | 26.74 MiB/s
Receiving objects:  85% (29611/34836), 13.38 MiB | 26.74 MiB/s
Receiving objects:  86% (29959/34836), 13.38 MiB | 26.74 MiB/s
Receiving objects:  87% (30308/34836), 13.38 MiB | 26.74 MiB/s
Receiving objects:  88% (30656/34836), 13.38 MiB | 26.74 MiB/s
Receiving objects:  89% (31005/34836), 13.38 MiB | 26.74 MiB/s
Receiving objects:  90% (31353/34836), 13.38 MiB | 26.74 MiB/s
Receiving objects:  91% (31701/34836), 13.38 MiB | 26.74 MiB/s
Receiving objects:  92% (32050/34836), 13.38 MiB | 26.74 MiB/s
Receiving objects:  92% (32093/34836), 16.46 MiB | 15.91 MiB/s
Receiving objects:  93% (32398/34836), 16.46 MiB | 15.91 MiB/s
Receiving objects:  94% (32746/34836), 16.46 MiB | 15.91 MiB/s
Receiving objects:  95% (33095/34836), 16.46 MiB | 15.91 MiB/s
Receiving objects:  96% (33443/34836), 16.46 MiB | 15.91 MiB/s
Receiving objects:  97% (33791/34836), 16.46 MiB | 15.91 MiB/s
Receiving objects:  98% (34140/34836), 16.46 MiB | 15.91 MiB/s
Receiving objects:  99% (34488/34836), 16.46 MiB | 15.91 MiB/s
remote: Total 34836 (delta 22315), reused 28904 (delta 19349), pack-reused 0[K

Receiving objects: 100% (34836/34836), 16.46 MiB | 15.91 MiB/s
Receiving objects: 100% (34836/34836), 29.28 MiB | 15.91 MiB/s, done.

Resolving deltas:   0% (0/22315)
Resolving deltas:   1% (226/22315)
Resolving deltas:   2% (492/22315)
Resolving deltas:   3% (818/22315)
Resolving deltas:   7% (1706/22315)
Resolving deltas:   8% (1786/22315)
Resolving deltas:   9% (2071/22315)
Resolving deltas:  10% (2258/22315)
Resolving deltas:  11% (2488/22315)
Resolving deltas:  12% (2866/22315)
Resolving deltas:  13% (2905/22315)
Resolving deltas:  14% (3329/22315)
Resolving deltas:  21% (4889/22315)
Resolving deltas:  23% (5278/22315)
Resolving deltas:  25% (5728/22315)
Resolving deltas:  26% (5803/22315)
Resolving deltas:  27% (6046/22315)
Resolving deltas:  31% (7070/22315)
Resolving deltas:  32% (7328/22315)
Resolving deltas:  36% (8201/22315)
Resolving deltas:  37% (8310/22315)
Resolving deltas:  38% (8496/22315)
Resolving deltas:  39% (8704/22315)
Resolving deltas:  40% (8968/22315)
Resolving deltas:  41% (9150/22315)
Resolving deltas:  43% (9652/22315)
Resolving deltas:  44% (9821/22315)
Resolving deltas:  45% (10042/22315)
Resolving deltas:  46% (10265/22315)
Resolving deltas:  49% (11065/22315)
Resolving deltas:  51% (11556/22315)
Resolving deltas:  52% (11634/22315)
Resolving deltas:  53% (11983/22315)
Resolving deltas:  54% (12079/22315)
Resolving deltas:  55% (12278/22315)
Resolving deltas:  56% (12634/22315)
Resolving deltas:  57% (12723/22315)
Resolving deltas:  61% (13733/22315)
Resolving deltas:  62% (13836/22315)
Resolving deltas:  63% (14059/22315)
Resolving deltas:  64% (14283/22315)
Resolving deltas:  65% (14505/22315)
Resolving deltas:  66% (14729/22315)
Resolving deltas:  68% (15294/22315)
Resolving deltas:  69% (15398/22315)
Resolving deltas:  70% (15622/22315)
Resolving deltas:  71% (15846/22315)
Resolving deltas:  72% (16072/22315)
Resolving deltas:  73% (16299/22315)
Resolving deltas:  74% (16517/22315)
Resolving deltas:  75% (16737/22315)
Resolving deltas:  76% (16961/22315)
Resolving deltas:  77% (17183/22315)
Resolving deltas:  78% (17406/22315)
Resolving deltas:  79% (17630/22315)
Resolving deltas:  80% (17852/22315)
Resolving deltas:  81% (18082/22315)
Resolving deltas:  82% (18300/22315)
Resolving deltas:  83% (18645/22315)
Resolving deltas:  84% (18798/22315)
Resolving deltas:  85% (18969/22315)
Resolving deltas:  86% (19191/22315)
Resolving deltas:  87% (19415/22315)
Resolving deltas:  88% (19638/22315)
Resolving deltas:  89% (19861/22315)
Resolving deltas:  90% (20084/22315)
Resolving deltas:  91% (20307/22315)
Resolving deltas:  92% (20532/22315)
Resolving deltas:  93% (20753/22315)
Resolving deltas:  94% (20981/22315)
Resolving deltas:  95% (21203/22315)
Resolving deltas:  96% (21438/22315)
Resolving deltas:  99% (22198/22315)
Resolving deltas: 100% (22315/22315)
Resolving deltas: 100% (22315/22315), done.



travis_time:end:09c942f3:start=1502828443802494253,finish=1502828454378099492,duration=10575605239
[0K$ cd Liaison-Intl/WebAdMIT

travis_time:start:0fab4726
[0K$ git fetch origin +refs/pull/7014/merge:

remote: Counting objects: 7, done.[K

remote: Compressing objects:  25% (1/4)   [K
remote: Compressing objects:  50% (2/4)   [K
remote: Compressing objects:  75% (3/4)   [K
remote: Compressing objects: 100% (4/4)   [K
remote: Compressing objects: 100% (4/4), done.[K

remote: Total 7 (delta 5), reused 4 (delta 3), pack-reused 0[K

Unpacking objects:  14% (1/7)
Unpacking objects:  28% (2/7)
Unpacking objects:  42% (3/7)
Unpacking objects:  57% (4/7)
Unpacking objects:  71% (5/7)
Unpacking objects:  85% (6/7)
Unpacking objects: 100% (7/7)
Unpacking objects: 100% (7/7), done.

From github.com:Liaison-Intl/WebAdMIT

 * branch              refs/pull/7014/merge -> FETCH_HEAD



travis_time:end:0fab4726:start=1502828454384111239,finish=1502828455105363338,duration=721252099
[0K$ git checkout -qf FETCH_HEAD

travis_fold:end:git.checkout
[0Ktravis_fold:start:apt
[0K[33;1mAdding APT Sources (BETA)[0m

$ export DEBIAN_FRONTEND=noninteractive

travis_time:start:04997ddb
[0K$ sudo -E apt-add-repository -y "ppa:fkrull/deadsnakes"

gpg: keyring `/tmp/tmpyqir1usr/secring.gpg' created

gpg: keyring `/tmp/tmpyqir1usr/pubring.gpg' created

gpg: requesting key DB82666C from hkp server keyserver.ubuntu.com

gpg: /tmp/tmpyqir1usr/trustdb.gpg: trustdb created

gpg: key DB82666C: public key "Launchpad Old Python Versions" imported

gpg: Total number processed: 1

gpg:               imported: 1  (RSA: 1)

OK



travis_time:end:04997ddb:start=1502828455370137646,finish=1502828457008873531,duration=1638735885
[0Ktravis_time:start:08919f5c
[0K$ sudo -E apt-add-repository -y "ppa:ubuntu-toolchain-r/test"

gpg: keyring `/tmp/tmpkrwsotde/secring.gpg' created

gpg: keyring `/tmp/tmpkrwsotde/pubring.gpg' created

gpg: requesting key BA9EF27F from hkp server keyserver.ubuntu.com

gpg: /tmp/tmpkrwsotde/trustdb.gpg: trustdb created

gpg: key BA9EF27F: public key "Launchpad Toolchain builds" imported

gpg: Total number processed: 1

gpg:               imported: 1  (RSA: 1)

OK



travis_time:end:08919f5c:start=1502828457014107626,finish=1502828458527452395,duration=1513344769
[0K[33;1mInstalling APT Packages (BETA)[0m

$ export DEBIAN_FRONTEND=noninteractive

travis_time:start:10379754
[0K$ sudo -E apt-get -yq update &>> ~/apt-get-update.log



travis_time:end:10379754:start=1502828458532848178,finish=1502828464434435913,duration=5901587735
[0Ktravis_time:start:17b2c0d4
[0K$ sudo -E apt-get -yq --no-install-suggests --no-install-recommends --force-yes install libtcmalloc-minimal4 unixodbc unixodbc-dev freetds-dev freetds-bin tdsodbc

Reading package lists...

Building dependency tree...

Reading state information...

unixodbc is already the newest version (2.2.14p2-5ubuntu5).

unixodbc set to manually installed.

unixodbc-dev is already the newest version (2.2.14p2-5ubuntu5).

The following additional packages will be installed:

  freetds-common libct4 libsybdb5

The following NEW packages will be installed:

  freetds-bin freetds-common freetds-dev libct4 libsybdb5 libtcmalloc-minimal4

  tdsodbc

0 upgraded, 7 newly installed, 0 to remove and 120 not upgraded.

Need to get 1,500 kB of archives.

After this operation, 4,385 kB of additional disk space will be used.

Get:1 http://us-central1.gce.archive.ubuntu.com/ubuntu trusty/main amd64 freetds-common all 0.91-5 [24.3 kB]

Get:2 http://us-central1.gce.archive.ubuntu.com/ubuntu trusty/main amd64 libct4 amd64 0.91-5 [166 kB]

Get:3 http://us-central1.gce.archive.ubuntu.com/ubuntu trusty/main amd64 libsybdb5 amd64 0.91-5 [194 kB]

Get:4 http://us-central1.gce.archive.ubuntu.com/ubuntu trusty/universe amd64 freetds-bin amd64 0.91-5 [306 kB]

Get:5 http://us-central1.gce.archive.ubuntu.com/ubuntu trusty/main amd64 freetds-dev amd64 0.91-5 [514 kB]

Get:6 http://us-central1.gce.archive.ubuntu.com/ubuntu trusty-updates/main amd64 libtcmalloc-minimal4 amd64 2.1-2ubuntu1.1 [103 kB]

Get:7 http://us-central1.gce.archive.ubuntu.com/ubuntu trusty/main amd64 tdsodbc amd64 0.91-5 [193 kB]

Fetched 1,500 kB in 0s (39.7 MB/s)

Preconfiguring packages ...

Selecting previously unselected package freetds-common.

(Reading database ...
(Reading database ... 5%
(Reading database ... 10%
(Reading database ... 15%
(Reading database ... 20%
(Reading database ... 25%
(Reading database ... 30%
(Reading database ... 35%
(Reading database ... 40%
(Reading database ... 45%
(Reading database ... 50%
(Reading database ... 55%
(Reading database ... 60%
(Reading database ... 65%
(Reading database ... 70%
(Reading database ... 75%
(Reading database ... 80%
(Reading database ... 85%
(Reading database ... 90%
(Reading database ... 95%
(Reading database ... 100%
(Reading database ... 92853 files and directories currently installed.)

Preparing to unpack .../freetds-common_0.91-5_all.deb ...

Unpacking freetds-common (0.91-5) ...

Selecting previously unselected package libct4:amd64.

Preparing to unpack .../libct4_0.91-5_amd64.deb ...

Unpacking libct4:amd64 (0.91-5) ...

Selecting previously unselected package libsybdb5:amd64.

Preparing to unpack .../libsybdb5_0.91-5_amd64.deb ...

Unpacking libsybdb5:amd64 (0.91-5) ...

Selecting previously unselected package freetds-bin.

Preparing to unpack .../freetds-bin_0.91-5_amd64.deb ...

Unpacking freetds-bin (0.91-5) ...

Selecting previously unselected package freetds-dev.

Preparing to unpack .../freetds-dev_0.91-5_amd64.deb ...

Unpacking freetds-dev (0.91-5) ...

Selecting previously unselected package libtcmalloc-minimal4.

Preparing to unpack .../libtcmalloc-minimal4_2.1-2ubuntu1.1_amd64.deb ...

Unpacking libtcmalloc-minimal4 (2.1-2ubuntu1.1) ...

Selecting previously unselected package tdsodbc:amd64.

Preparing to unpack .../tdsodbc_0.91-5_amd64.deb ...

Unpacking tdsodbc:amd64 (0.91-5) ...

Processing triggers for man-db (2.6.7.1-1ubuntu1) ...

Setting up freetds-common (0.91-5) ...

Setting up libct4:amd64 (0.91-5) ...

Setting up libsybdb5:amd64 (0.91-5) ...

Setting up freetds-bin (0.91-5) ...

Setting up freetds-dev (0.91-5) ...

Setting up libtcmalloc-minimal4 (2.1-2ubuntu1.1) ...

Setting up tdsodbc:amd64 (0.91-5) ...

Processing triggers for libc-bin (2.19-0ubuntu6.13) ...

W: --force-yes is deprecated, use one of the options starting with --allow instead.



travis_time:end:17b2c0d4:start=1502828464439065366,finish=1502828467234610149,duration=2795544783
[0Ktravis_fold:end:apt
[0Ktravis_fold:start:services
[0Ktravis_time:start:0c4c67ac
[0K$ sudo service redis-server start

Starting redis-server: redis-server.



travis_time:end:0c4c67ac:start=1502828467239568782,finish=1502828467286187569,duration=46618787
[0Ktravis_time:start:07cdd506
[0K$ sudo service docker start

start: Job is already running: docker



travis_time:end:07cdd506:start=1502828467290766376,finish=1502828467304727145,duration=13960769
[0Ktravis_fold:end:services
[0Ktravis_fold:start:postgresql
[0K[33;1mStarting PostgreSQL v9.5[0m

travis_time:start:17c070d4
[0K$ sudo service postgresql stop

 * Stopping PostgreSQL 9.2 database server       [80G
[74G[ OK ]

 * Stopping PostgreSQL 9.3 database server       [80G
[74G[ OK ]

 * Stopping PostgreSQL 9.4 database server       [80G
[74G[ OK ]

 * Stopping PostgreSQL 9.5 database server       [80G
[74G[ OK ]

 * Stopping PostgreSQL 9.6 database server       [80G
[74G[ OK ]



travis_time:end:17c070d4:start=1502828470311792718,finish=1502828471634761322,duration=1322968604
[0Ktravis_time:start:14fdb63c
[0K$ sudo service postgresql start 9.5

 * Starting PostgreSQL 9.5 database server       [80G
[74G[ OK ]



travis_time:end:14fdb63c:start=1502828471639741678,finish=1502828473838566073,duration=2198824395
[0Ktravis_time:start:02514dc8
[0K$ sudo -u postgres createuser -s -p 5432 travis &>/dev/null



travis_time:end:02514dc8:start=1502828473843546934,finish=1502828473890264250,duration=46717316
[0Ktravis_time:start:03f8e5fa
[0K$ sudo -u postgres createdb -O travis -p 5432 travis &>/dev/null



travis_time:end:03f8e5fa:start=1502828473895299426,finish=1502828474145300793,duration=250001367
[0Ktravis_time:start:0855073c
[0K$ sudo -u postgres createuser -s -p 5433 travis &>/dev/null



travis_time:end:0855073c:start=1502828474149897562,finish=1502828474188041378,duration=38143816
[0Ktravis_time:start:2cce36d6
[0K$ sudo -u postgres createdb -O travis -p 5433 travis &>/dev/null



travis_time:end:2cce36d6:start=1502828474192812527,finish=1502828474231782187,duration=38969660
[0Ktravis_fold:end:postgresql
[0K

[33;1mSetting environment variables from repository settings[0m

$ export DOCKER_USERNAME=watravisbot

$ export DOCKER_PASSWORD=[secure]

$ export TRAVIS_ACCESS_TOKEN=[secure]



[33;1mSetting environment variables from .travis.yml[0m

$ export TEST_SUITE=minitest:integration_split

$ export DEFAULT_WAIT_TIMEOUT=30

$ export JOB_INDEX=1

$ export JOB_COUNT=5



travis_fold:start:rvm
[0Ktravis_time:start:0d4569fd
[0K$ rvm use ruby-1.9.3-p551 --install --binary --fuzzy

[33mruby-1.9.3-p551 is not installed - installing.[0m

[32mSearching for binary rubies, this might take some time.[0m

[32mFound remote file https://rvm_io.global.ssl.fastly.net/binaries/ubuntu/14.04/x86_64/ruby-1.9.3-p551.tar.bz2[0m

[32mChecking requirements for ubuntu.[0m

[32mRequirements installation successful.[0m

[32mruby-1.9.3-p551 - #configure[0m

[32mruby-1.9.3-p551 - #download[0m

  % Total    % Received % Xferd  Average Speed   Time    Time     Time  Current

                                 Dload  Upload   Total   Spent    Left  Speed


  0     0    0     0    0     0      0      0 --:--:-- --:--:-- --:--:--     0
100 13.3M  100 13.3M    0     0  39.2M      0 --:--:-- --:--:-- --:--:-- 39.3M

[32mruby-1.9.3-p551 - #validate archive[0m

[32mruby-1.9.3-p551 - #extract[0m

[32mruby-1.9.3-p551 - #validate binary[0m

[32mruby-1.9.3-p551 - #setup[0m

[32mruby-1.9.3-p551 - #gemset created /home/travis/.rvm/gems/ruby-1.9.3-p551@global[0m

[32mruby-1.9.3-p551 - #importing gemset /home/travis/.rvm/gemsets/global.gems[0m|/-\|/-\|.-\|/-\|/-.|/-\|/-\|.-\|/-\|/-.|/-\|/-\|.-\|/-\|/-.|/-\|/-\|.-\|/-\|/-.|/-\|/-\|.-\|/-\|/-.|/-\|/-\|.-\|/-\|/-.|/-\|/-\|.-\|/-\|/-.|/-\|/-\|.-\|/-\|/-.|/-\|/-\|.-\|/-\|/-.|/-\|/-\|.-\|/-\|/-.|/-\|/-\|.-\|/-\|/-.|/-\|/-\|.-\|/-\|/-.|/-\|/-\|.-\|/-\|/-.|/-\|/-\|.-\|/-\|/-.|/-\|/-\|.-\|/-\|/-.|/-\|/-\|.-\|/-\|/-.|/-\|/-\|.-\|/-\|/-.|/-\|/-\|.-\|/-\|/-..

[32mruby-1.9.3-p551 - #generating global wrappers[0m|/-\|/-\|.-\|/-\|/-.|/-\|/-\|.-\|/-\|/-.|/-\|/-\|.-\|/-\|/-.|/-\|/-\|.-\|/.

[32mruby-1.9.3-p551 - #uninstalling gem rubygems-bundler-1.4.4[0m|/.

[32mruby-1.9.3-p551 - #gemset created /home/travis/.rvm/gems/ruby-1.9.3-p551[0m

[32mruby-1.9.3-p551 - #importing gemset /home/travis/.rvm/gemsets/default.gems[0m|/-\|/-\|.-\|/-\|/-.|/-\|/-\|.-\|/-\|/-.|/-\|/-\|.-\|/-\|/-.|/-\|/-\|.-\|/-\|/-.|/-\|/-\|.-\|/-\|/-.|/-\|/-\|.-\|/-\|/-.|/-\|/-\|.-\|/-\|/-.|/-\.

[32mruby-1.9.3-p551 - #generating default wrappers[0m|/-\|/-\|.-\|/-\|/-.|/-\|/-\|.-\|/-\|/-.|/-\|/-\|.-\|/-\|/-.|/-\|/-\|.-\|/-.

[32mUsing /home/travis/.rvm/gems/ruby-1.9.3-p551[0m



travis_time:end:0d4569fd:start=1502828474246213247,finish=1502828486784607711,duration=12538394464
[0Ktravis_fold:end:rvm
[0K$ export BUNDLE_GEMFILE=$PWD/Gemfile-Rails_4.0

travis_fold:start:cache.1
[0KSetting up build cache

$ export CASHER_DIR=$HOME/.casher

travis_time:start:0651f7d8
[0K$ Installing caching utilities



travis_time:end:0651f7d8:start=1502828487045607288,finish=1502828487184814510,duration=139207222
[0Ktravis_time:start:009896d0
[0K

travis_time:end:009896d0:start=1502828487193164754,finish=1502828487199308880,duration=6144126
[0Ktravis_time:start:1580631d
[0K[32;1mattempting to download cache archive[0m

[32;1mfetching PR.7014/cache-linux-trusty-48bf8259d550ef0b6ebe7a197765a83bbbdeba047435bfe415385e9f32053c3d--rvm-ruby-1.9.3-p551--gemfile-Gemfile-Rails_4.0.tgz[0m

[32;1mfetching PR.7014/cache--rvm-ruby-1.9.3-p551--gemfile-Gemfile-Rails_4.0.tgz[0m

[32;1mfetching master/cache-linux-trusty-48bf8259d550ef0b6ebe7a197765a83bbbdeba047435bfe415385e9f32053c3d--rvm-ruby-1.9.3-p551--gemfile-Gemfile-Rails_4.0.tgz[0m

[32;1mfound cache[0m



travis_time:end:1580631d:start=1502828487207541129,finish=1502828488914946411,duration=1707405282
[0Ktravis_fold:end:cache.1
[0K

travis_fold:start:cache.bundler
[0Ktravis_time:start:00fb5e00
[0K

travis_time:end:00fb5e00:start=1502828488921913185,finish=1502828488927741062,duration=5827877
[0Ktravis_time:start:04bf210c
[0K[32;1madding /home/travis/build/Liaison-Intl/WebAdMIT/vendor/bundle to cache[0m

[32;1mcreating directory /home/travis/build/Liaison-Intl/WebAdMIT/vendor/bundle[0m



travis_time:end:04bf210c:start=1502828488935166734,finish=1502828494034127756,duration=5098961022
[0Ktravis_fold:end:cache.bundler
[0K$ ruby --version

ruby 1.9.3p551 (2014-11-13 revision 48407) [x86_64-linux]

$ rvm --version

rvm 1.29.2 (latest) by Michal Papis, Piotr Kuczynski, Wayne E. Seguin [https://rvm.io/]

$ bundle --version

Bundler version 1.7.6

$ gem --version

2.4.3

travis_fold:start:before_install.1
[0Ktravis_time:start:1a27d972
[0K$ if [[ "${RUN}" == "./travis/build_push_container" ]] ; then gem install travis_dedup && travis-dedup --pro --ignore-error-500 ${TRAVIS_REPO_SLUG} ${TRAVIS_ACCESS_TOKEN} ; fi



travis_time:end:1a27d972:start=1502828494383433266,finish=1502828494388068349,duration=4635083
[0Ktravis_fold:end:before_install.1
[0Ktravis_fold:start:before_install.2
[0Ktravis_time:start:03f37cf2
[0K$ if [[ -n "${TRAVIS_TAG}" && "${RUN}" != "./travis/build_push_container" ]] ; then echo "Skipping tests since were building for a tag" ; exit 0 ; fi



travis_time:end:03f37cf2:start=1502828494394093360,finish=1502828494399202226,duration=5108866
[0Ktravis_fold:end:before_install.2
[0Ktravis_fold:start:before_install.3
[0Ktravis_time:start:1e13580f
[0K$ mkdir /tmp/bin



travis_time:end:1e13580f:start=1502828494405075106,finish=1502828494410921687,duration=5846581
[0Ktravis_fold:end:before_install.3
[0Ktravis_fold:start:before_install.4
[0Ktravis_time:start:0350b59c
[0K$ sh ./travis/install_phantomjs-2.1.1.sh


Reading package lists... 0%

Reading package lists... 100%

Reading package lists... Done



Building dependency tree... 0%

Building dependency tree... 0%

Building dependency tree... 50%

Building dependency tree... 50%

Building dependency tree



Reading state information... 0%

Reading state information... 0%

Reading state information... Done


build-essential is already the newest version (11.6ubuntu6).

libxft-dev is already the newest version (2.3.1-2).

libxft-dev set to manually installed.

libssl-dev is already the newest version (1.0.1f-1ubuntu2.22).

libssl-dev set to manually installed.

The following NEW packages will be installed:

  chrpath

0 upgraded, 1 newly installed, 0 to remove and 120 not upgraded.

Need to get 12.5 kB of archives.

After this operation, 62.5 kB of additional disk space will be used.


0% [Working]

Get:1 http://us-central1.gce.archive.ubuntu.com/ubuntu trusty/main amd64 chrpath amd64 0.14-3ubuntu1 [12.5 kB]


80% [1 chrpath 12.5 kB/12.5 kB 100%]

100% [Working]

Fetched 12.5 kB in 0s (0 B/s)

Selecting previously unselected package chrpath.

(Reading database ...
(Reading database ... 5%
(Reading database ... 10%
(Reading database ... 15%
(Reading database ... 20%
(Reading database ... 25%
(Reading database ... 30%
(Reading database ... 35%
(Reading database ... 40%
(Reading database ... 45%
(Reading database ... 50%
(Reading database ... 55%
(Reading database ... 60%
(Reading database ... 65%
(Reading database ... 70%
(Reading database ... 75%
(Reading database ... 80%
(Reading database ... 85%
(Reading database ... 90%
(Reading database ... 95%
(Reading database ... 100%
(Reading database ... 92934 files and directories currently installed.)

Preparing to unpack .../chrpath_0.14-3ubuntu1_amd64.deb ...

Unpacking chrpath (0.14-3ubuntu1) ...

Processing triggers for man-db (2.6.7.1-1ubuntu1) ...

Setting up chrpath (0.14-3ubuntu1) ...


Reading package lists... 0%

Reading package lists... 100%

Reading package lists... Done



Building dependency tree... 0%

Building dependency tree... 0%

Building dependency tree... 50%

Building dependency tree... 50%

Building dependency tree



Reading state information... 0%

Reading state information... 0%

Reading state information... Done


libfreetype6 is already the newest version (2.5.2-1ubuntu2.8).

libfreetype6 set to manually installed.

libfreetype6-dev is already the newest version (2.5.2-1ubuntu2.8).

0 upgraded, 0 newly installed, 0 to remove and 120 not upgraded.


Reading package lists... 0%

Reading package lists... 100%

Reading package lists... Done



Building dependency tree... 0%

Building dependency tree... 0%

Building dependency tree... 50%

Building dependency tree... 50%

Building dependency tree



Reading state information... 0%

Reading state information... 0%

Reading state information... Done


libfontconfig1 is already the newest version (2.11.0-0ubuntu4.2).

libfontconfig1 set to manually installed.

libfontconfig1-dev is already the newest version (2.11.0-0ubuntu4.2).

libfontconfig1-dev set to manually installed.

0 upgraded, 0 newly installed, 0 to remove and 120 not upgraded.

--2017-08-15 20:21:37--  https://github.com/Medium/phantomjs/releases/download/v2.1.1/phantomjs-2.1.1-linux-x86_64.tar.bz2

Resolving github.com (github.com)... 192.30.253.112, 192.30.253.113

Connecting to github.com (github.com)|192.30.253.112|:443... connected.

HTTP request sent, awaiting response... 302 Found

Location: https://github-production-release-asset-2e65be.s3.amazonaws.com/5755891/d55faeca-f27c-11e5-84be-6e92fb868e05?X-Amz-Algorithm=AWS4-HMAC-SHA256&X-Amz-Credential=AKIAIWNJYAX4CSVEH53A%2F20170815%2Fus-east-1%2Fs3%2Faws4_request&X-Amz-Date=20170815T202137Z&X-Amz-Expires=300&X-Amz-Signature=c28b638209177dd0fa071f6af5e9c4ae5589cf2dc3427b641f1c8fda1547e758&X-Amz-SignedHeaders=host&actor_id=0&response-content-disposition=attachment%3B%20filename%3Dphantomjs-2.1.1-linux-x86_64.tar.bz2&response-content-type=application%2Foctet-stream [following]

--2017-08-15 20:21:37--  https://github-production-release-asset-2e65be.s3.amazonaws.com/5755891/d55faeca-f27c-11e5-84be-6e92fb868e05?X-Amz-Algorithm=AWS4-HMAC-SHA256&X-Amz-Credential=AKIAIWNJYAX4CSVEH53A%2F20170815%2Fus-east-1%2Fs3%2Faws4_request&X-Amz-Date=20170815T202137Z&X-Amz-Expires=300&X-Amz-Signature=c28b638209177dd0fa071f6af5e9c4ae5589cf2dc3427b641f1c8fda1547e758&X-Amz-SignedHeaders=host&actor_id=0&response-content-disposition=attachment%3B%20filename%3Dphantomjs-2.1.1-linux-x86_64.tar.bz2&response-content-type=application%2Foctet-stream

Resolving github-production-release-asset-2e65be.s3.amazonaws.com (github-production-release-asset-2e65be.s3.amazonaws.com)... 52.216.226.152

Connecting to github-production-release-asset-2e65be.s3.amazonaws.com (github-production-release-asset-2e65be.s3.amazonaws.com)|52.216.226.152|:443... connected.

HTTP request sent, awaiting response... 200 OK

Length: 23415665 (22M) [application/octet-stream]

Saving to: Ã¢â‚¬Ëœphantomjs-2.1.1-linux-x86_64.tar.bz2Ã¢â‚¬â„¢




 0% [                                       ] 0           --.-K/s
 0% [                                       ] 181,816      809KB/s
 2% [                                       ] 564,792     1.23MB/s
 4% [>                                      ] 1,139,256   1.65MB/s
 8% [==>                                    ] 1,974,840   2.14MB/s
13% [====>                                  ] 3,158,584   2.74MB/s
20% [======>                                ] 4,794,936   3.46MB/s
29% [==========>                            ] 6,953,528   4.30MB/s
42% [===============>                       ] 9,860,664   5.33MB/s
58% [=====================>                 ] 13,699,640  6.59MB/s
80% [==============================>        ] 18,773,523  8.12MB/s
100%[======================================>] 23,415,665  9.52MB/s   in 2.3s



2017-08-15 20:21:39 (9.52 MB/s) - Ã¢â‚¬Ëœphantomjs-2.1.1-linux-x86_64.tar.bz2Ã¢â‚¬â„¢ saved [23415665/23415665]



phantomjs-2.1.1-linux-x86_64/

phantomjs-2.1.1-linux-x86_64/examples/

phantomjs-2.1.1-linux-x86_64/examples/colorwheel.js

phantomjs-2.1.1-linux-x86_64/examples/scandir.js

phantomjs-2.1.1-linux-x86_64/examples/page_events.js

phantomjs-2.1.1-linux-x86_64/examples/loadspeed.js

phantomjs-2.1.1-linux-x86_64/examples/injectme.js

phantomjs-2.1.1-linux-x86_64/examples/render_multi_url.js

phantomjs-2.1.1-linux-x86_64/examples/server.js

phantomjs-2.1.1-linux-x86_64/examples/netlog.js

phantomjs-2.1.1-linux-x86_64/examples/pagecallback.js

phantomjs-2.1.1-linux-x86_64/examples/module.js

phantomjs-2.1.1-linux-x86_64/examples/arguments.js

phantomjs-2.1.1-linux-x86_64/examples/universe.js

phantomjs-2.1.1-linux-x86_64/examples/openurlwithproxy.js

phantomjs-2.1.1-linux-x86_64/examples/sleepsort.js

phantomjs-2.1.1-linux-x86_64/examples/modernizr.js

phantomjs-2.1.1-linux-x86_64/examples/unrandomize.js

phantomjs-2.1.1-linux-x86_64/examples/hello.js

phantomjs-2.1.1-linux-x86_64/examples/stdin-stdout-stderr.js

phantomjs-2.1.1-linux-x86_64/examples/fibo.js

phantomjs-2.1.1-linux-x86_64/examples/phantomwebintro.js

phantomjs-2.1.1-linux-x86_64/examples/echoToFile.js

phantomjs-2.1.1-linux-x86_64/examples/post.js

phantomjs-2.1.1-linux-x86_64/examples/loadurlwithoutcss.js

phantomjs-2.1.1-linux-x86_64/examples/child_process-examples.js

phantomjs-2.1.1-linux-x86_64/examples/printenv.js

phantomjs-2.1.1-linux-x86_64/examples/useragent.js

phantomjs-2.1.1-linux-x86_64/examples/rasterize.js

phantomjs-2.1.1-linux-x86_64/examples/outputEncoding.js

phantomjs-2.1.1-linux-x86_64/examples/waitfor.js

phantomjs-2.1.1-linux-x86_64/examples/serverkeepalive.js

phantomjs-2.1.1-linux-x86_64/examples/postserver.js

phantomjs-2.1.1-linux-x86_64/examples/printmargins.js

phantomjs-2.1.1-linux-x86_64/examples/version.js

phantomjs-2.1.1-linux-x86_64/examples/run-qunit.js

phantomjs-2.1.1-linux-x86_64/examples/features.js

phantomjs-2.1.1-linux-x86_64/examples/netsniff.js

phantomjs-2.1.1-linux-x86_64/examples/walk_through_frames.js

phantomjs-2.1.1-linux-x86_64/examples/printheaderfooter.js

phantomjs-2.1.1-linux-x86_64/examples/responsive-screenshot.js

phantomjs-2.1.1-linux-x86_64/examples/countdown.js

phantomjs-2.1.1-linux-x86_64/examples/detectsniff.js

phantomjs-2.1.1-linux-x86_64/examples/simpleserver.js

phantomjs-2.1.1-linux-x86_64/examples/postjson.js

phantomjs-2.1.1-linux-x86_64/examples/run-jasmine2.js

phantomjs-2.1.1-linux-x86_64/examples/run-jasmine.js

phantomjs-2.1.1-linux-x86_64/README.md

phantomjs-2.1.1-linux-x86_64/LICENSE.BSD

phantomjs-2.1.1-linux-x86_64/bin/

phantomjs-2.1.1-linux-x86_64/bin/phantomjs

phantomjs-2.1.1-linux-x86_64/third-party.txt

phantomjs-2.1.1-linux-x86_64/ChangeLog



travis_time:end:0350b59c:start=1502828494416939204,finish=1502828503199092889,duration=8782153685
[0Ktravis_fold:end:before_install.4
[0Ktravis_fold:start:before_install.5
[0Ktravis_time:start:1aea081a
[0K$ export PATH=/tmp/phantomjs-2.1.1-linux-x86_64/bin/:$PATH



travis_time:end:1aea081a:start=1502828503204427289,finish=1502828503208758011,duration=4330722
[0Ktravis_fold:end:before_install.5
[0Ktravis_fold:start:before_install.6
[0Ktravis_time:start:022400b9
[0K$ which phantomjs

/tmp/phantomjs-2.1.1-linux-x86_64/bin//phantomjs



travis_time:end:022400b9:start=1502828503214433153,finish=1502828503219440486,duration=5007333
[0Ktravis_fold:end:before_install.6
[0Ktravis_fold:start:before_install.7
[0Ktravis_time:start:06926315
[0K$ phantomjs --version

2.1.1



travis_time:end:06926315:start=1502828503224420085,finish=1502828503486259679,duration=261839594
[0Ktravis_fold:end:before_install.7
[0Ktravis_fold:start:before_install.8
[0Ktravis_time:start:05d66e8e
[0K$ psql --version

psql (PostgreSQL) 9.5.7



travis_time:end:05d66e8e:start=1502828503494015208,finish=1502828503503349262,duration=9334054
[0Ktravis_fold:end:before_install.8
[0Ktravis_fold:start:before_install.9
[0Ktravis_time:start:0aa4d39e
[0K$ export RUBY_GC_MALLOC_LIMIT=1000000000



travis_time:end:0aa4d39e:start=1502828503509586779,finish=1502828503514943874,duration=5357095
[0Ktravis_fold:end:before_install.9
[0Ktravis_fold:start:before_install.10
[0Ktravis_time:start:0ff6c2d8
[0K$ export RUBY_HEAP_SLOTS_GROWTH_FACTOR=1.25



travis_time:end:0ff6c2d8:start=1502828503520465353,finish=1502828503525232519,duration=4767166
[0Ktravis_fold:end:before_install.10
[0Ktravis_fold:start:before_install.11
[0Ktravis_time:start:0a9e5522
[0K$ export RUBY_HEAP_MIN_SLOTS=800000



travis_time:end:0a9e5522:start=1502828503530441217,finish=1502828503535122255,duration=4681038
[0Ktravis_fold:end:before_install.11
[0Ktravis_fold:start:before_install.12
[0Ktravis_time:start:0e7a5432
[0K$ export RUBY_FREE_MIN=600000



travis_time:end:0e7a5432:start=1502828503540456706,finish=1502828503545117816,duration=4661110
[0Ktravis_fold:end:before_install.12
[0Ktravis_fold:start:before_install.13
[0Ktravis_time:start:118ee7e7
[0K$ export LD_PRELOAD=/usr/lib/libtcmalloc_minimal.so.4



travis_time:end:118ee7e7:start=1502828503550496849,finish=1502828503559610972,duration=9114123
[0Ktravis_fold:end:before_install.13
[0Ktravis_fold:start:before_install.14
[0Ktravis_time:start:00b50454
[0K$ export TABLEAU_API_USER=edw_tableau_user4



travis_time:end:00b50454:start=1502828503571089626,finish=1502828503580283469,duration=9193843
[0Ktravis_fold:end:before_install.14
[0Ktravis_fold:start:before_install.15
[0Ktravis_time:start:0fe7d629
[0K$ export TABLEAU_API_PASSWORD=311ArsenalSt.



travis_time:end:0fe7d629:start=1502828503590100430,finish=1502828503599310599,duration=9210169
[0Ktravis_fold:end:before_install.15
[0Ktravis_fold:start:before_install.16
[0Ktravis_time:start:0ef349a0
[0K$ export TABLEAU_USER=test_user



travis_time:end:0ef349a0:start=1502828503608279520,finish=1502828503617938839,duration=9659319
[0Ktravis_fold:end:before_install.16
[0Ktravis_fold:start:before_install.17
[0Ktravis_time:start:0970309c
[0K$ export CONFIG_PORTAL_URL=http://10.10.12.30:8080/configuration/session



travis_time:end:0970309c:start=1502828503628379406,finish=1502828503637425666,duration=9046260
[0Ktravis_fold:end:before_install.17
[0Ktravis_fold:start:install
[0Ktravis_time:start:05ce4463
[0K$ if [[ "${RUN}" != "./travis/build_push_container" ]] ; then bundle install --without development etl --path=${BUNDLE_PATH:-vendor/bundle} ; fi

Using rake 10.5.0

Using aasm 3.4.0

Using i18n 0.8.0

Using minitest 4.7.5

Using multi_json 1.12.1

Using thread_safe 0.3.5

Using tzinfo 0.3.52

Using activesupport 4.0.13

Using builder 3.1.4

Using erubis 2.7.0

Using rack 1.5.5

Using rack-test 0.6.3

Using actionpack 4.0.13

Using mime-types 1.25.1

Using mail 2.6.4

Using actionmailer 4.0.13

Using actionpack-page_caching 1.0.2

Using activemodel 4.0.13

Using activerecord-deprecated_finders 1.0.4

Using arel 4.0.2

Using activerecord 4.0.13

Using activerecord-sqlserver-adapter 4.0.3

Using addressable 2.3.8

Using airbrake 4.3.3

Using gyoku 1.1.1

Using mini_portile 0.6.0

Using nokogiri 1.6.3.1

Using akami 1.2.1

Using amq-protocol 1.7.0

Using ansi 1.5.0

Using request_store 1.3.0

Using authlogic 3.4.2

Using json 1.8.3

Using multi_xml 0.5.5

Using httparty 0.13.5

Using uuidtools 2.1.5

Using aws-sdk 1.6.2

Using bcrypt-ruby 3.0.1

Using bunny 0.10.2

Using callsite 0.0.11

Using xpath 2.0.0

Using capybara 2.1.0

Using chronic 0.10.2

Using thor 0.19.1

Using railties 4.0.13

Using ckeditor_rails 4.1.1

Using climate_control 0.2.0

Using cliver 0.3.2

Using cocaine 0.5.8

Using coderay 1.1.0

Using coffee-script-source 1.10.0

Using execjs 1.4.0

Using coffee-script 2.4.1

Using coffee-rails 4.1.1

Using columnize 0.9.0

Using concurrent-ruby 1.0.1

Using unf_ext 0.0.7.4

Using unf 0.1.4

Using domain_name 0.5.20170404

Using http-cookie 1.0.3

Using netrc 0.11.0

Using rest-client 1.8.0

Using docile 1.1.5

Using simplecov-html 0.10.1

Using simplecov 0.14.1

Using term-ansicolor 1.0.0

Using coveralls 0.7.1

Using safe_yaml 1.0.4

Using crack 0.4.2

Using daemons 1.1.9

Using database_cleaner 1.3.0

Using debugger-linecache 1.2.0

Using debugger-ruby_core_source 1.3.8

Using debugger 1.6.8

Using dotenv-deployment 0.0.2

Using dotenv 0.11.1

Using dotenv-rails 0.11.1

Using draper 1.4.0

Using dynamic_form 1.1.4

Using net-ssh 2.6.6

Using net-ssh-gateway 1.2.0

Using elsewhere 0.6

Using ffi 1.9.6

Using ethon 0.8.0

Using eventmachine 1.2.1

Using factory_girl 4.4.0

Using factory_girl_rails 4.4.1

Using foreigner 1.6.1

Using formatador 0.2.5

Using formtastic 2.3.1

Using god 0.13.2

Using rb-fsevent 0.9.7

Using rb-inotify 0.9.5

Using rb-kqueue 0.2.3

Using listen 1.3.1

Using lumberjack 1.0.9

Using method_source 0.8.2

Using slop 3.6.0

Using pry 0.10.1

Using guard 1.8.3

Using guard-minitest 1.3.1

Using tilt 1.4.1

Using haml 4.0.7

Using hiredis 0.4.5

Using rubyntlm 0.3.4

Using httpi 2.1.0

Using jasmine-core 2.3.4

Using phantomjs 2.1.1.0

Using jasmine 2.3.1

Using jbuilder 2.2.6

Using jquery-rails 3.1.4

Using jquery-ui-rails 4.1.2

Using sprockets 3.6.0

Using sprockets-rails 2.3.3

Using js-routes 1.2.5

Using json-schema 2.6.0

Using kgio 2.10.0

Using launchy 2.4.2

Using libv8 3.16.14.19

Using marginalia 1.2.0

Using rack-contrib 1.1.0

Using meta_request 0.4.0

Using metaclass 0.0.4

Using mimemagic 0.3.0

Using minitest-bang 0.1.1

Using minitest-capybara 0.5.0

Using minitest-metadata 0.5.3

Using minitest-test 1.1.0

Using minitest-rails 1.0.1

Using minitest-rails-capybara 1.0.0

Using mocha 1.1.0

Using mono_logger 1.1.0

Using mustache 0.99.4

Using newrelic_rpm 3.15.2.317

Using nori 2.3.0

Using paperclip 4.3.7

Using passenger 5.0.30

Using pdfkit 0.5.3

Using pg 0.18.4

Using websocket-extensions 0.1.2

Using websocket-driver 0.6.5

Using poltergeist 1.15.0

Using polyamorous 1.1.0

Using progressbar 0.21.0

Using protected_attributes 1.1.3

Using pry-debugger 0.2.3

Using rack-protection 1.5.3

Using bundler 1.7.6

Using rails 4.0.13

Using rails-observers 0.1.2

Using raindrops 0.13.0

Using rdiscount 1.6.8

Using redis 3.2.2

Using redis-store 1.1.7

Using redis-rack 1.5.0

Using redis-actionpack 4.0.1

Using redis-activesupport 4.1.5

Using redis-namespace 1.5.2

Using redis-rails 4.0.0

Using ref 2.0.0

Using remotipart 1.3.1 from https://github.com/Liaison-Intl/remotipart.git (at master)

Using sinatra 1.3.3

Using vegas 0.1.11

Using resque 1.25.2

Using resque-loner 1.3.0

Using trollop 1.16.2

Using resque-pool 0.4.0

Using resque-status 0.4.3

Using ruby-ole 1.2.11.6

Using rubyzip 1.1.7

Using sass 3.4.22

Using sass-rails 5.0.4

Using wasabi 3.2.3

Using savon 2.3.3

Using sendgrid 1.2.0

Using shoulda-matchers 2.8.0

Using spreadsheet 0.8.3

Using squeel 1.2.3

Using sys-proctable 0.9.2

Using test-unit-minitest 0.9.1

Using therubyracer 0.12.2

Using thin 1.5.0

Using timecop 0.7.3

Using tins 1.6.0

Using tiny_tds 0.5.1

Using turn 0.9.7

Using typhoeus 0.8.0

Using uglifier 1.3.0

Using unicorn 4.6.2

Using vcr 2.8.0

Using webmock 1.19.0

Using whenever 0.9.4

Using will_paginate 3.0.4

Using zeus 0.15.4

[32mYour bundle is complete![0m

[32mGems in the groups development and etl were not installed.[0m

[32mIt was installed into ./vendor/bundle[0m



travis_time:end:05ce4463:start=1502828503648026503,finish=1502828504108119404,duration=460092901
[0Ktravis_fold:end:install
[0Ktravis_fold:start:before_script.1
[0Ktravis_time:start:0ab45dae
[0K$ cp config/database.yml.travis-ci config/database.yml



travis_time:end:0ab45dae:start=1502828504121638618,finish=1502828504135826761,duration=14188143
[0Ktravis_fold:end:before_script.1
[0Ktravis_fold:start:before_script.2
[0Ktravis_time:start:14a0f386
[0K$ cp config/database_read_only.yml.travis-ci config/database_read_only.yml



travis_time:end:14a0f386:start=1502828504147051307,finish=1502828504161192772,duration=14141465
[0Ktravis_fold:end:before_script.2
[0Ktravis_fold:start:before_script.3
[0Ktravis_time:start:0c4c96ee
[0K$ cp config/redis.yml.example config/redis.yml



travis_time:end:0c4c96ee:start=1502828504174004327,finish=1502828504188738156,duration=14733829
[0Ktravis_fold:end:before_script.3
[0Ktravis_fold:start:before_script.4
[0Ktravis_time:start:0b41ab08
[0K$ cp config/etl_redis.yml.example config/etl_redis.yml



travis_time:end:0b41ab08:start=1502828504200250853,finish=1502828504216489789,duration=16238936
[0Ktravis_fold:end:before_script.4
[0Ktravis_fold:start:before_script.5
[0Ktravis_time:start:00f0c935
[0K$ mkdir -p /home/travis/build/Liaison-Intl/WebAdMIT/public/assets



travis_time:end:00f0c935:start=1502828504227520513,finish=1502828504240308862,duration=12788349
[0Ktravis_fold:end:before_script.5
[0Ktravis_fold:start:before_script.6
[0Ktravis_time:start:1bbefe8d
[0K$ touch /home/travis/build/Liaison-Intl/WebAdMIT/public/assets/reports.css



travis_time:end:1bbefe8d:start=1502828504250882748,finish=1502828504263532791,duration=12650043
[0Ktravis_fold:end:before_script.6
[0Ktravis_fold:start:before_script.7
[0Ktravis_time:start:049c3da8
[0K$ echo "${TRAVIS_PULL_REQUEST_SHA:-${TRAVIS_COMMIT}} ${TRAVIS_PULL_REQUEST_BRANCH:-${TRAVIS_BRANCH}}" | tee REVISION

a52902397d0e150f681e5f4c3bda6235957ed20f feature/NF-18396



travis_time:end:049c3da8:start=1502828504274589814,finish=1502828504288549359,duration=13959545
[0Ktravis_fold:end:before_script.7
[0Ktravis_fold:start:before_script.8
[0Ktravis_time:start:1d085534
[0K$ if [[ "${RUN}" != "./travis/build_push_container" ]] ; then bundle exec rake db:create ; fi

Auto-loading of `.env.test` will be removed in 1.0. See https://github.com/bkeepers/dotenv-deployment if you would like to continue using this feature.

DEPRECATION WARNING:

Sass 3.5 will no longer support Ruby 1.9.3.

Please upgrade to Ruby 2.0.0 or greater as soon as possible.



** Invoke db:create (first_time)

** Invoke db:load_config (first_time)

** Execute db:load_config

** Execute db:create



travis_time:end:1d085534:start=1502828504298162069,finish=1502828512940413390,duration=8642251321
[0Ktravis_fold:end:before_script.8
[0Ktravis_fold:start:before_script.9
[0Ktravis_time:start:002dc90b
[0K$ if [[ "${RUN}" != "./travis/build_push_container" ]] ; then bundle exec rake db:schema:load ; fi

Auto-loading of `.env.test` will be removed in 1.0. See https://github.com/bkeepers/dotenv-deployment if you would like to continue using this feature.

DEPRECATION WARNING:

Sass 3.5 will no longer support Ruby 1.9.3.

Please upgrade to Ruby 2.0.0 or greater as soon as possible.



** Invoke db:schema:load (first_time)

** Invoke environment (first_time)

** Execute environment

DEPRECATION WARNING: config.whiny_nils option is deprecated and no longer works. (called from block in <top (required)> at /home/travis/build/Liaison-Intl/WebAdMIT/config/environments/test.rb:15)

INFO: It's now safe to remove /home/travis/build/Liaison-Intl/WebAdMIT/config/initializers/backports/backport_find_or_initialize_by_and_find_or_create_by.rb

INFO: It's now safe to remove /home/travis/build/Liaison-Intl/WebAdMIT/config/initializers/backports/try.rb

Running Rails 4.0.13

Running Ruby 1.9.3

Running PostgreSQL 9.5.7 on x86_64-pc-linux-gnu, compiled by gcc (Ubuntu 4.8.4-2ubuntu1~14.04.3) 4.8.4, 64-bit

DEPRECATION WARNING: The following options in your Designation.has_many :combined_degrees declaration are deprecated: :conditions. Please use a scope block instead. For example, the following:



    has_many :spam_comments, conditions: { spam: true }, class_name: 'Comment'



should be rewritten as the following:



    has_many :spam_comments, -> { where spam: true }, class_name: 'Comment'

. (called from <class:Designation> at /home/travis/build/Liaison-Intl/WebAdMIT/app/models/designation.rb:55)

DEPRECATION WARNING: The following options in your Designation.has_many :optional_offerings declaration are deprecated: :uniq. Please use a scope block instead. For example, the following:



    has_many :spam_comments, conditions: { spam: true }, class_name: 'Comment'



should be rewritten as the following:



    has_many :spam_comments, -> { where spam: true }, class_name: 'Comment'

. (called from <class:Designation> at /home/travis/build/Liaison-Intl/WebAdMIT/app/models/designation.rb:67)

DEPRECATION WARNING: The following options in your Designation.has_many :designation_evaluations declaration are deprecated: :order. Please use a scope block instead. For example, the following:



    has_many :spam_comments, conditions: { spam: true }, class_name: 'Comment'



should be rewritten as the following:



    has_many :spam_comments, -> { where spam: true }, class_name: 'Comment'

. (called from <class:Designation> at /home/travis/build/Liaison-Intl/WebAdMIT/app/models/designation.rb:69)

DEPRECATION WARNING: The following options in your ApplicantRequirement.has_many :courses declaration are deprecated: :uniq. Please use a scope block instead. For example, the following:



    has_many :spam_comments, conditions: { spam: true }, class_name: 'Comment'



should be rewritten as the following:



    has_many :spam_comments, -> { where spam: true }, class_name: 'Comment'

. (called from <class:ApplicantRequirement> at /home/travis/build/Liaison-Intl/WebAdMIT/app/models/applicant_requirement.rb:17)

DEPRECATION WARNING: The following options in your LocalGpa.has_many :applicant_courses declaration are deprecated: :uniq. Please use a scope block instead. For example, the following:



    has_many :spam_comments, conditions: { spam: true }, class_name: 'Comment'



should be rewritten as the following:



    has_many :spam_comments, -> { where spam: true }, class_name: 'Comment'

. (called from <class:LocalGpa> at /home/travis/build/Liaison-Intl/WebAdMIT/app/models/local_gpa.rb:10)

DEPRECATION WARNING: The following options in your LocalGpa.has_many :local_gpas_courses declaration are deprecated: :uniq. Please use a scope block instead. For example, the following:



    has_many :spam_comments, conditions: { spam: true }, class_name: 'Comment'



should be rewritten as the following:



    has_many :spam_comments, -> { where spam: true }, class_name: 'Comment'

. (called from <class:LocalGpa> at /home/travis/build/Liaison-Intl/WebAdMIT/app/models/local_gpa.rb:12)

DEPRECATION WARNING: The following options in your LocalGpa.has_many :courses declaration are deprecated: :uniq. Please use a scope block instead. For example, the following:



    has_many :spam_comments, conditions: { spam: true }, class_name: 'Comment'



should be rewritten as the following:



    has_many :spam_comments, -> { where spam: true }, class_name: 'Comment'

. (called from <class:LocalGpa> at /home/travis/build/Liaison-Intl/WebAdMIT/app/models/local_gpa.rb:13)

DEPRECATION WARNING: The following options in your LocalGpa.has_many :selected_courses declaration are deprecated: :order,:conditions. Please use a scope block instead. For example, the following:



    has_many :spam_comments, conditions: { spam: true }, class_name: 'Comment'



should be rewritten as the following:



    has_many :spam_comments, -> { where spam: true }, class_name: 'Comment'

. (called from <class:LocalGpa> at /home/travis/build/Liaison-Intl/WebAdMIT/app/models/local_gpa.rb:15)

DEPRECATION WARNING: The following options in your LocalGpa.has_many :deselected_courses declaration are deprecated: :uniq,:conditions. Please use a scope block instead. For example, the following:



    has_many :spam_comments, conditions: { spam: true }, class_name: 'Comment'



should be rewritten as the following:



    has_many :spam_comments, -> { where spam: true }, class_name: 'Comment'

. (called from <class:LocalGpa> at /home/travis/build/Liaison-Intl/WebAdMIT/app/models/local_gpa.rb:19)

DEPRECATION WARNING: The following options in your Scoring::PointTable.has_many :scoring_models declaration are deprecated: :uniq. Please use a scope block instead. For example, the following:



    has_many :spam_comments, conditions: { spam: true }, class_name: 'Comment'



should be rewritten as the following:



    has_many :spam_comments, -> { where spam: true }, class_name: 'Comment'

. (called from <class:PointTable> at /home/travis/build/Liaison-Intl/WebAdMIT/app/models/scoring/point_table.rb:20)

DEPRECATION WARNING: The following options in your Scoring::PointTable.has_many :entries declaration are deprecated: :include. Please use a scope block instead. For example, the following:



    has_many :spam_comments, conditions: { spam: true }, class_name: 'Comment'



should be rewritten as the following:



    has_many :spam_comments, -> { where spam: true }, class_name: 'Comment'

. (called from <class:PointTable> at /home/travis/build/Liaison-Intl/WebAdMIT/app/models/scoring/point_table.rb:23)

DEPRECATION WARNING: The following options in your GpaTemplateBase.has_many :gpa_templates_subjects declaration are deprecated: :conditions. Please use a scope block instead. For example, the following:



    has_many :spam_comments, conditions: { spam: true }, class_name: 'Comment'



should be rewritten as the following:



    has_many :spam_comments, -> { where spam: true }, class_name: 'Comment'

. (called from <class:GpaTemplateBase> at /home/travis/build/Liaison-Intl/WebAdMIT/app/models/gpa_template_base.rb:10)

DEPRECATION WARNING: The following options in your GpaTemplateBase.has_many :tracked_subjects declaration are deprecated: :uniq. Please use a scope block instead. For example, the following:



    has_many :spam_comments, conditions: { spam: true }, class_name: 'Comment'



should be rewritten as the following:



    has_many :spam_comments, -> { where spam: true }, class_name: 'Comment'

. (called from <class:GpaTemplateBase> at /home/travis/build/Liaison-Intl/WebAdMIT/app/models/gpa_template_base.rb:11)

DEPRECATION WARNING: The following options in your GpaTemplateBase.has_many :local_gpas declaration are deprecated: :uniq. Please use a scope block instead. For example, the following:



    has_many :spam_comments, conditions: { spam: true }, class_name: 'Comment'



should be rewritten as the following:



    has_many :spam_comments, -> { where spam: true }, class_name: 'Comment'

. (called from <class:GpaTemplateBase> at /home/travis/build/Liaison-Intl/WebAdMIT/app/models/gpa_template_base.rb:25)

** Invoke db:load_config (first_time)

** Execute db:load_config

** Execute db:schema:load

-- create_table("about_mes", {:force=>true})

   -> 0.0051s

-- add_index("about_mes", ["applicant_id"], {:name=>"index_about_mes_on_applicant_id"})

   -> 0.0024s

-- create_table("academic_enrichments", {:force=>true})

   -> 0.0031s

-- add_index("academic_enrichments", ["applicant_id"], {:name=>"index_academic_enrichments_on_applicant_id"})

   -> 0.0021s

-- create_table("academic_sessions", {:force=>true})

   -> 0.0034s

-- add_index("academic_sessions", ["academic_year_id"], {:name=>"index_academic_sessions_on_academic_year_id"})

   -> 0.0022s

-- add_index("academic_sessions", ["applicant_id"], {:name=>"index_academic_sessions_on_applicant_id"})

   -> 0.0022s

-- add_index("academic_sessions", ["association_id", "identifier"], {:name=>"index_academic_sessions_on_association_id_and_identifier"})

   -> 0.0022s

-- add_index("academic_sessions", ["association_id"], {:name=>"index_academic_sessions_on_association_id"})

   -> 0.0022s

-- add_index("academic_sessions", ["college_id"], {:name=>"index_academic_sessions_on_college_id"})

   -> 0.0022s

-- add_index("academic_sessions", ["identifier"], {:name=>"index_academic_sessions_on_identifier"})

   -> 0.0023s

-- add_index("academic_sessions", ["term_id"], {:name=>"index_academic_sessions_on_term_id"})

   -> 0.0024s

-- add_index("academic_sessions", ["term_type_id"], {:name=>"index_academic_sessions_on_term_type_id"})

   -> 0.0028s

-- create_table("academic_years", {:force=>true})

   -> 0.0036s

-- add_index("academic_years", ["association_id", "identifier"], {:name=>"index_academic_years_on_association_id_and_identifier"})

   -> 0.0027s

-- add_index("academic_years", ["association_id"], {:name=>"index_academic_years_on_association_id"})

   -> 0.0024s

-- add_index("academic_years", ["identifier"], {:name=>"index_academic_years_on_identifier"})

   -> 0.0023s

-- create_table("academic_years_gpa_templates", {:force=>true})

   -> 0.0029s

-- add_index("academic_years_gpa_templates", ["academic_year_id"], {:name=>"index_academic_years_gpa_templates_on_academic_year_id"})

   -> 0.0025s

-- add_index("academic_years_gpa_templates", ["gpa_template_id"], {:name=>"index_academic_years_gpa_templates_on_gpa_template_id"})

   -> 0.0022s

-- create_table("additional_languages", {:force=>true})

   -> 0.0031s

-- add_index("additional_languages", ["association_id", "identifier"], {:name=>"index_additional_languages_on_association_id_and_identifier"})

   -> 0.0032s

-- add_index("additional_languages", ["association_id"], {:name=>"index_additional_languages_on_association_id"})

   -> 0.0023s

-- add_index("additional_languages", ["identifier"], {:name=>"index_additional_languages_on_identifier"})

   -> 0.0022s

-- create_table("additional_mcat_intent_indicators", {:force=>true})

   -> 0.0030s

-- add_index("additional_mcat_intent_indicators", ["applicant_id"], {:name=>"index_additional_mcat_intent_indicators_on_applicant_id"})

   -> 0.0024s

-- create_table("advanced_dental_educations", {:force=>true})

   -> 0.0033s

-- create_table("advisor_request_associations", {:force=>true})

   -> 0.0032s

-- add_index("advisor_request_associations", ["advisor_request_id", "association_id"], {:name=>"index_uniq_advisor_request_associations", :unique=>true})

   -> 0.0026s

-- create_table("advisor_requests", {:force=>true})

   -> 0.0038s

-- add_index("advisor_requests", ["email"], {:name=>"index_advisor_requests_on_email", :unique=>true})

   -> 0.0023s

-- create_table("alternate_campuses", {:force=>true})

   -> 0.0031s

-- add_index("alternate_campuses", ["applicant_id", "organization_id"], {:name=>"index_alternate_campuses_on_applicant_id_and_organization_id", :unique=>true})

   -> 0.0027s

-- create_table("alternate_names", {:force=>true})

   -> 0.0034s

-- add_index("alternate_names", ["applicant_id"], {:name=>"index_alternate_names_on_applicant_id"})

   -> 0.0024s

-- create_table("animal_experiences", {:force=>true})

   -> 0.0037s

-- add_index("animal_experiences", ["animal_experience_type_id"], {:name=>"index_animal_experiences_on_animal_experience_type_id"})

   -> 0.0026s

-- add_index("animal_experiences", ["applicant_id"], {:name=>"index_animal_experiences_on_applicant_id"})

   -> 0.0022s

-- add_index("animal_experiences", ["identifier"], {:name=>"index_animal_experiences_on_identifier"})

   -> 0.0021s

-- add_index("animal_experiences", ["type"], {:name=>"index_animal_experiences_on_type"})

   -> 0.0021s

-- create_table("answer_bases", {:force=>true})

   -> 0.0035s

-- add_index("answer_bases", ["answered_by_id"], {:name=>"index_custom_field_answers_on_answered_by_id"})

   -> 0.0025s

-- add_index("answer_bases", ["applicant_id"], {:name=>"index_custom_field_answers_on_applicant_id"})

   -> 0.0022s

-- add_index("answer_bases", ["question_base_id", "applicant_id"], {:name=>"index_answer_bases_on_question_base_id_and_applicant_id", :unique=>true})

   -> 0.0022s

-- add_index("answer_bases", ["question_base_id"], {:name=>"index_custom_field_answers_on_custom_field_id"})

   -> 0.0021s

-- add_index("answer_bases", ["supplemental_lookup_id"], {:name=>"index_answer_bases_on_supplemental_lookup_id"})

   -> 0.0022s

-- add_index("answer_bases", ["type"], {:name=>"index_answer_bases_on_type"})

   -> 0.0021s

-- create_table("api_keys", {:force=>true})

   -> 0.0027s

-- create_table("applicant_attachments", {:force=>true})

   -> 0.0033s

-- add_index("applicant_attachments", ["applicant_id"], {:name=>"index_applicant_attachments_on_applicant_id"})

   -> 0.0025s

-- add_index("applicant_attachments", ["identifier"], {:name=>"index_applicant_attachments_on_identifier"})

   -> 0.0022s

-- add_index("applicant_attachments", ["visible_to_type", "visible_to_id"], {:name=>"index_applicant_attachments_6128a11646"})

   -> 0.0023s

-- create_table("applicant_college_details_warehouse", {:force=>true})

   -> 0.0052s

-- add_index("applicant_college_details_warehouse", ["applicant_id"], {:name=>"index_acd_warehouse_on_applicant_id"})

   -> 0.0024s

-- add_index("applicant_college_details_warehouse", ["first_degree_primary_major"], {:name=>"index_acd_warehouse_on_major_id_1"})

   -> 0.0029s

-- add_index("applicant_college_details_warehouse", ["first_degree_primary_minor"], {:name=>"index_acd_warehouse_on_minor_id_1"})

   -> 0.0024s

-- add_index("applicant_college_details_warehouse", ["first_degree_secondary_major"], {:name=>"index_acd_warehouse_on_major_id_2"})

   -> 0.0028s

-- add_index("applicant_college_details_warehouse", ["first_degree_secondary_minor"], {:name=>"index_acd_warehouse_on_minor_id_2"})

   -> 0.0024s

-- add_index("applicant_college_details_warehouse", ["first_degree_status"], {:name=>"index_acd_warehouse_on_degree_status_id_1"})

   -> 0.0025s

-- add_index("applicant_college_details_warehouse", ["mdb_code"], {:name=>"index_acd_warehouse_on_mdb_code"})

   -> 0.0025s

-- add_index("applicant_college_details_warehouse", ["name"], {:name=>"index_acd_warehouse_on_name"})

   -> 0.0024s

-- add_index("applicant_college_details_warehouse", ["school_type_id"], {:name=>"index_acd_warehouse_on_school_type_id"})

   -> 0.0023s

-- add_index("applicant_college_details_warehouse", ["second_degree_primary_major"], {:name=>"index_acd_warehouse_on_major_id_3"})

   -> 0.0023s

-- add_index("applicant_college_details_warehouse", ["second_degree_secondary_major"], {:name=>"index_acd_warehouse_on_major_id_4"})

   -> 0.0023s

-- add_index("applicant_college_details_warehouse", ["second_degree_status"], {:name=>"index_acd_warehouse_on_degree_status_id_2"})

   -> 0.0024s

-- add_index("applicant_college_details_warehouse", ["type"], {:name=>"index_acd_warehouse_on_type"})

   -> 0.0022s

-- create_table("applicant_criteria", {:force=>true})

   -> 0.0033s

-- add_index("applicant_criteria", ["applicant_id", "applicant_requirement_id", "criterion_id"], {:name=>"applicant_criteria_requirement_criterion_id", :unique=>true})

   -> 0.0025s

-- add_index("applicant_criteria", ["applicant_id", "criterion_id"], {:name=>"index_applicant_criteria_on_applicant_id_and_criterion_id", :unique=>true})

   -> 0.0024s

-- add_index("applicant_criteria", ["applicant_id"], {:name=>"index_applicant_criteria_on_applicant_id"})

   -> 0.0022s

-- add_index("applicant_criteria", ["applicant_requirement_id"], {:name=>"index_applicant_criteria_on_applicant_requirement_id"})

   -> 0.0022s

-- add_index("applicant_criteria", ["criteria_comment_id"], {:name=>"index_applicant_criteria_on_criteria_comment_id"})

   -> 0.0022s

-- add_index("applicant_criteria", ["criterion_id"], {:name=>"index_applicant_criteria_on_criterion_id"})

   -> 0.0022s

-- add_index("applicant_criteria", ["custom_choice_id"], {:name=>"index_applicant_criteria_on_custom_choice_id"})

   -> 0.0026s

-- create_table("applicant_criteria_courses", {:force=>true})

   -> 0.0027s

-- add_index("applicant_criteria_courses", ["applicant_criterion_id"], {:name=>"index_app_criteria_on_criterion_id"})

   -> 0.0024s

-- add_index("applicant_criteria_courses", ["applicant_id"], {:name=>"index_applicant_criteria_courses_on_applicant_id"})

   -> 0.0023s

-- add_index("applicant_criteria_courses", ["course_id"], {:name=>"index_app_criteria_on_course_id"})

   -> 0.0023s

-- create_table("applicant_degrees", {:force=>true})

   -> 0.0034s

-- add_index("applicant_degrees", ["applicant_id"], {:name=>"index_applicant_degrees_on_applicant_id"})

   -> 0.0025s

-- add_index("applicant_degrees", ["college_attended_id"], {:name=>"index_applicant_degrees_on_college_attended_id"})

   -> 0.0025s

-- add_index("applicant_degrees", ["degree_id"], {:name=>"index_applicant_degrees_on_degree_id"})

   -> 0.0024s

-- add_index("applicant_degrees", ["degree_status_id"], {:name=>"index_applicant_degrees_on_degree_status_id"})

   -> 0.0023s

-- add_index("applicant_degrees", ["identifier"], {:name=>"index_applicant_degrees_on_identifier"})

   -> 0.0023s

-- create_table("applicant_designation_details_mv", {:force=>true})

   -> 0.0068s

-- add_index("applicant_designation_details_mv", ["academic_update_status_id"], {:name=>"index_addw_on_academic_update_status_id"})

   -> 0.0026s

-- add_index("applicant_designation_details_mv", ["applicant_id", "application_status_id"], {:name=>"index_addw_on_applicant_id_and_application_status_id"})

   -> 0.0028s

-- add_index("applicant_designation_details_mv", ["applicant_id", "program_id"], {:name=>"index_addw_on_applicant_id_and_program_id"})

   -> 0.0026s

-- add_index("applicant_designation_details_mv", ["applicant_id", "status_show"], {:name=>"idx_designation_details_on_applicant_id_status_show"})

   -> 0.0024s

-- add_index("applicant_designation_details_mv", ["applicant_id"], {:name=>"index_addw_on_applicant_id"})

   -> 0.0022s

-- add_index("applicant_designation_details_mv", ["application_status_id"], {:name=>"index_addw_on_application_status_id"})

   -> 0.0023s

-- add_index("applicant_designation_details_mv", ["association_id"], {:name=>"index_addw_on_association_id"})

   -> 0.0023s

-- add_index("applicant_designation_details_mv", ["decision_id"], {:name=>"index_addw_on_decision_id"})

   -> 0.0023s

-- add_index("applicant_designation_details_mv", ["local_status_id"], {:name=>"index_addw_on_local_status_id"})

   -> 0.0022s

-- add_index("applicant_designation_details_mv", ["program_id", "applicant_id", "status_show"], {:name=>"idx_designation_details_on_program_id_applicant_id_status_show"})

   -> 0.0025s

-- add_index("applicant_designation_details_mv", ["program_id", "association_id"], {:name=>"index_addw_on_program_id_and_association_id"})

   -> 0.0025s

-- add_index("applicant_designation_details_mv", ["program_id"], {:name=>"index_addw_on_program_id"})

   -> 0.0022s

-- add_index("applicant_designation_details_mv", ["program_organization_id"], {:name=>"index_addw_on_program_organization_id"})

   -> 0.0024s

-- add_index("applicant_designation_details_mv", ["status_show", "program_id", "applicant_id"], {:name=>"idx_designation_details_on_status_show_program_id_applicant_id"})

   -> 0.0026s

-- add_index("applicant_designation_details_mv", ["status_title"], {:name=>"index_addw_on_status_title"})

   -> 0.0022s

-- create_table("applicant_details_headers", {:force=>true})

   -> 0.0028s

-- create_table("applicant_details_headers_programs", {:id=>false, :force=>true})

   -> 0.0019s

-- create_table("applicant_ethnicities", {:force=>true})

   -> 0.0028s

-- add_index("applicant_ethnicities", ["applicant_id", "ethnicity_id"], {:name=>"index_applicant_ethnicities_on_applicant_id_and_ethnicity_id"})

   -> 0.0028s

-- add_index("applicant_ethnicities", ["applicant_id"], {:name=>"index_applicant_ethnicities_on_applicant_id"})

   -> 0.0022s

-- add_index("applicant_ethnicities", ["ethnicity_id", "applicant_id"], {:name=>"index_applicant_ethnicities_on_ethnicity_id_and_applicant_id"})

   -> 0.0025s

-- add_index("applicant_ethnicities", ["ethnicity_id"], {:name=>"index_applicant_ethnicities_on_ethnicity_id"})

   -> 0.0023s

-- create_table("applicant_gateway_activities", {:force=>true})

   -> 0.0032s

-- add_index("applicant_gateway_activities", ["applicant_id", "program_id", "type"], {:name=>"applicant_gateway_activities_unique", :unique=>true})

   -> 0.0024s

-- create_table("applicant_gateway_activity_assignment_type_bases", {:force=>true})

   -> 0.0031s

-- create_table("applicant_gateway_activity_configurations", {:force=>true})

   -> 0.0036s

-- add_index("applicant_gateway_activity_configurations", ["activity_type_id", "program_id"], {:name=>"app_gateway_act_conf_uniq_index", :unique=>true})

   -> 0.0022s

-- create_table("applicant_gateway_activity_states", {:force=>true})

   -> 0.0030s

-- add_index("applicant_gateway_activity_states", ["name"], {:name=>"index_applicant_gateway_activity_states_on_name", :unique=>true})

   -> 0.0025s

-- create_table("applicant_gateway_activity_types", {:force=>true})

   -> 0.0034s

-- add_index("applicant_gateway_activity_types", ["activity_type"], {:name=>"index_applicant_gateway_activity_types_on_activity_type", :unique=>true})

   -> 0.0026s

-- add_index("applicant_gateway_activity_types", ["title"], {:name=>"index_applicant_gateway_activity_types_on_title", :unique=>true})

   -> 0.0023s

-- create_table("applicant_gateway_fees", {:force=>true})

   -> 0.0035s

-- create_table("applicant_gateway_offers", {:force=>true})

   -> 0.0033s

-- add_index("applicant_gateway_offers", ["applicant_gateway_activity_id"], {:name=>"index_applicant_gateway_offers_on_applicant_gateway_activity_id"})

   -> 0.0024s

-- add_index("applicant_gateway_offers", ["applicant_id"], {:name=>"index_applicant_gateway_offers_on_applicant_id"})

   -> 0.0021s

-- create_table("applicant_heard_about_sources", {:force=>true})

   -> 0.0031s

-- add_index("applicant_heard_about_sources", ["advisor_or_conselor"], {:name=>"ahas_advisor_or_conselor"})

   -> 0.0024s

-- add_index("applicant_heard_about_sources", ["alumni_or_current_student"], {:name=>"ahas_alumni_or_current_student"})

   -> 0.0022s

-- add_index("applicant_heard_about_sources", ["applicant_id"], {:name=>"index_applicant_heard_about_sources_on_applicant_id"})

   -> 0.0022s

-- add_index("applicant_heard_about_sources", ["asph_literature"], {:name=>"ahas_asph_literature"})

   -> 0.0024s

-- add_index("applicant_heard_about_sources", ["aupha_literature"], {:name=>"ahas_aupha_literature"})

   -> 0.0022s

-- add_index("applicant_heard_about_sources", ["career_fair"], {:name=>"ahas_career_fair"})

   -> 0.0022s

-- add_index("applicant_heard_about_sources", ["friend_or_relative"], {:name=>"ahas_friend_or_relative"})

   -> 0.0022s

-- add_index("applicant_heard_about_sources", ["grad_teacher_or_professor"], {:name=>"ahas_grad_teacher_or_professor"})

   -> 0.0024s

-- add_index("applicant_heard_about_sources", ["graduate_school_fair"], {:name=>"ahas_graduate_school_fair"})

   -> 0.0022s

-- add_index("applicant_heard_about_sources", ["health_care_provider"], {:name=>"ahas_health_care_provider"})

   -> 0.0022s

-- add_index("applicant_heard_about_sources", ["health_related_experience"], {:name=>"ahas_health_related_experience"})

   -> 0.0023s

-- add_index("applicant_heard_about_sources", ["idealist_event"], {:name=>"ahas_idealist_event"})

   -> 0.0023s

-- add_index("applicant_heard_about_sources", ["internet"], {:name=>"ahas_internet"})

   -> 0.0025s

-- add_index("applicant_heard_about_sources", ["media"], {:name=>"ahas_media"})

   -> 0.0023s

-- add_index("applicant_heard_about_sources", ["parent"], {:name=>"ahas_parent"})

   -> 0.0023s

-- add_index("applicant_heard_about_sources", ["professional_conference"], {:name=>"ahas_professional_conference"})

   -> 0.0023s

-- add_index("applicant_heard_about_sources", ["sph_literature"], {:name=>"ahas_sph_literature"})

   -> 0.0022s

-- add_index("applicant_heard_about_sources", ["teacher_or_professor"], {:name=>"ahas_teacher_or_professor"})

   -> 0.0021s

-- add_index("applicant_heard_about_sources", ["undergrad_teacher_or_professor"], {:name=>"ahas_undergrad_teacher_or_professor"})

   -> 0.0021s

-- create_table("applicant_mailings", {:force=>true})

   -> 0.0028s

-- add_index("applicant_mailings", ["applicant_id", "mailing_id"], {:name=>"index_applicant_mailings_on_applicant_id_and_mailing_id"})

   -> 0.0031s

-- add_index("applicant_mailings", ["applicant_id"], {:name=>"index_applicant_mailings_on_applicant_id"})

   -> 0.0026s

-- add_index("applicant_mailings", ["identifier"], {:name=>"index_applicant_mailings_on_identifier"})

   -> 0.0021s

-- add_index("applicant_mailings", ["mailing_id", "program_id"], {:name=>"index_applicant_mailings_on_mailing_id_and_program_id"})

   -> 0.0022s

-- add_index("applicant_mailings", ["mailing_id"], {:name=>"index_applicant_mailings_on_mailing_id"})

   -> 0.0022s

-- add_index("applicant_mailings", ["organization_id"], {:name=>"index_applicant_mailings_on_organization_id"})

   -> 0.0021s

-- add_index("applicant_mailings", ["program_id"], {:name=>"index_applicant_mailings_on_program_id"})

   -> 0.0022s

-- create_table("applicant_majors", {:force=>true})

   -> 0.0034s

-- add_index("applicant_majors", ["applicant_degree_id"], {:name=>"index_applicant_majors_on_applicant_degree_id"})

   -> 0.0024s

-- add_index("applicant_majors", ["applicant_id"], {:name=>"index_applicant_majors_on_applicant_id"})

   -> 0.0028s

-- add_index("applicant_majors", ["association_id"], {:name=>"index_applicant_majors_on_association_id"})

   -> 0.0022s

-- add_index("applicant_majors", ["major_id"], {:name=>"index_applicant_majors_on_major_id"})

   -> 0.0022s

-- create_table("applicant_minors", {:force=>true})

   -> 0.0033s

-- add_index("applicant_minors", ["applicant_degree_id"], {:name=>"index_applicant_minors_on_applicant_degree_id"})

   -> 0.0024s

-- add_index("applicant_minors", ["applicant_id"], {:name=>"index_applicant_minors_on_applicant_id"})

   -> 0.0022s

-- add_index("applicant_minors", ["association_id"], {:name=>"index_applicant_minors_on_association_id"})

   -> 0.0022s

-- add_index("applicant_minors", ["minor_id"], {:name=>"index_applicant_minors_on_minor_id"})

   -> 0.0021s

-- create_table("applicant_preferred_genders", {:force=>true})

   -> 0.0035s

-- add_index("applicant_preferred_genders", ["applicant_id"], {:name=>"index_applicant_preferred_genders_on_applicant_id", :unique=>true})

   -> 0.0023s

-- create_table("applicant_requirements", {:force=>true})

   -> 0.0030s

-- add_index("applicant_requirements", ["applicant_id", "requirement_id"], {:name=>"index_applicant_requirements_on_applicant_id_and_requirement_id", :unique=>true})

   -> 0.0023s

-- add_index("applicant_requirements", ["applicant_id"], {:name=>"index_applicant_requirements_on_applicant_id"})

   -> 0.0022s

-- add_index("applicant_requirements", ["requirement_id", "requirement_type"], {:name=>"app_req_requirement_id_and_requirement_type_idx"})

   -> 0.0023s

-- add_index("applicant_requirements", ["requirement_id"], {:name=>"index_applicant_requirements_on_requirement_id"})

   -> 0.0022s

-- create_table("applicant_score_entries", {:force=>true})

   -> 0.0032s

-- add_index("applicant_score_entries", ["model_component_id", "score_id"], {:name=>"unique_score_entrie", :unique=>true})

   -> 0.0027s

-- add_index("applicant_score_entries", ["model_component_id"], {:name=>"index_applicant_score_entries_on_model_compenent_id"})

   -> 0.0022s

-- add_index("applicant_score_entries", ["score_id"], {:name=>"index_applicant_score_entries_on_score_id"})

   -> 0.0024s

-- create_table("applicant_scores", {:force=>true})

   -> 0.0029s

-- add_index("applicant_scores", ["applicant_id"], {:name=>"index_applicant_scores_on_applicant_id"})

   -> 0.0023s

-- add_index("applicant_scores", ["calculated_score"], {:name=>"index_applicant_scores_on_calculated_score"})

   -> 0.0022s

-- add_index("applicant_scores", ["scoring_model_id"], {:name=>"index_applicant_scores_on_scoring_model_id"})

   -> 0.0021s

-- create_table("applicant_supplied_question_sets", {:force=>true})

   -> 0.0043s

-- create_table("applicants", {:force=>true})

   -> 0.0040s

-- add_index("applicants", ["association_id", "identifier"], {:name=>"index_applicants_on_association_id_and_identifier"})

   -> 0.0024s

-- add_index("applicants", ["association_id"], {:name=>"index_applicants_on_association_id"})

   -> 0.0023s

-- add_index("applicants", ["cas_id"], {:name=>"index_applicants_on_cas_id"})

   -> 0.0021s

-- add_index("applicants", ["email_type_id"], {:name=>"index_applicants_on_email_type_id"})

   -> 0.0023s

-- add_index("applicants", ["identifier", "cas_id", "association_id"], {:name=>"unique_find_or_create"})

   -> 0.0022s

-- add_index("applicants", ["identifier"], {:name=>"index_applicants_on_identifier"})

   -> 0.0022s

-- add_index("applicants", ["match_id"], {:name=>"index_applicants_on_match_id"})

   -> 0.0022s

-- create_table("applicants_emails", {:force=>true})

   -> 0.0028s

-- add_index("applicants_emails", ["applicant_id"], {:name=>"index_applicants_emails_on_applicant_id"})

   -> 0.0021s

-- add_index("applicants_emails", ["email_id"], {:name=>"index_applicants_emails_on_email_id"})

   -> 0.0021s

-- create_table("application_types", {:force=>true})

   -> 0.0031s

-- add_index("application_types", ["association_id", "identifier"], {:name=>"index_application_types_on_association_id_and_identifier"})

   -> 0.0025s

-- add_index("application_types", ["association_id"], {:name=>"index_application_types_on_association_id"})

   -> 0.0021s

-- add_index("application_types", ["identifier"], {:name=>"index_application_types_on_identifier"})

   -> 0.0022s

-- create_table("assignment_answers", {:force=>true})

   -> 0.0033s

-- add_index("assignment_answers", ["assignment_base_id", "question_id"], {:name=>"index_assignment_answers_on_assignment_base_id_and_question_id", :unique=>true})

   -> 0.0023s

-- add_index("assignment_answers", ["assignment_base_id"], {:name=>"index_assignment_answers_on_assignment_base_id"})

   -> 0.0022s

-- add_index("assignment_answers", ["question_id"], {:name=>"index_assignment_answers_on_question_id"})

   -> 0.0021s

-- create_table("assignment_bases", {:force=>true})

   -> 0.0038s

-- add_index("assignment_bases", ["applicant_id"], {:name=>"index_assignment_bases_on_applicant_id"})

   -> 0.0022s

-- add_index("assignment_bases", ["assignment_type_base_id"], {:name=>"index_assignment_bases_on_assignment_type_base_id"})

   -> 0.0020s

-- add_index("assignment_bases", ["interview_location_id"], {:name=>"index_assignment_bases_on_interview_location_id"})

   -> 0.0023s

-- add_index("assignment_bases", ["interview_slot_id"], {:name=>"index_assignment_bases_on_interview_slot_id"})

   -> 0.0022s

-- add_index("assignment_bases", ["organization_id"], {:name=>"index_assignment_bases_on_organization_id"})

   -> 0.0023s

-- add_index("assignment_bases", ["remark_id"], {:name=>"index_assignment_bases_on_remark_id"})

   -> 0.0020s

-- add_index("assignment_bases", ["type", "user_identity_id", "complete"], {:name=>"idx_assignment_bases_on_type_and_user_identity_id_and_complete"})

   -> 0.0024s

-- add_index("assignment_bases", ["type"], {:name=>"index_assignment_bases_on_type"})

   -> 0.0024s

-- create_table("assignment_questions", {:force=>true})

   -> 0.0030s

-- add_index("assignment_questions", ["assignment_type_base_id"], {:name=>"index_assignment_questions_on_assignment_type_base_id"})

   -> 0.0023s

-- create_table("assignment_type_bases", {:force=>true})

   -> 0.0033s

-- add_index("assignment_type_bases", ["organization_id"], {:name=>"index_assignment_type_bases_on_organization_id"})

   -> 0.0029s

-- add_index("assignment_type_bases", ["type"], {:name=>"index_assignment_type_bases_on_type"})

   -> 0.0021s

-- create_table("assignment_type_bases_programs", {:force=>true})

   -> 0.0030s

-- add_index("assignment_type_bases_programs", ["assignment_type_base_id"], {:name=>"index_assignment_type_bases_programs_on_assignment_type_base_id"})

   -> 0.0025s

-- add_index("assignment_type_bases_programs", ["program_id"], {:name=>"index_assignment_type_bases_programs_on_program_id"})

   -> 0.0022s

-- create_table("associations", {:force=>true})

   -> 0.0042s

-- add_index("associations", ["application_form_identifier"], {:name=>"index_associations_on_application_form_identifier", :unique=>true})

   -> 0.0025s

-- add_index("associations", ["cas3"], {:name=>"index_associations_on_cas3"})

   -> 0.0023s

-- add_index("associations", ["cas_id", "cycle_id"], {:name=>"index_associations_on_cas_id_and_cycle_id", :unique=>true})

   -> 0.0024s

-- add_index("associations", ["cas_id"], {:name=>"index_associations_on_cas_id"})

   -> 0.0022s

-- add_index("associations", ["identifier"], {:name=>"index_associations_on_identifier"})

   -> 0.0021s

-- create_table("associations_fields", {:force=>true})

   -> 0.0029s

-- add_index("associations_fields", ["association_id"], {:name=>"index_associations_fields_on_association_id"})

   -> 0.0023s

-- add_index("associations_fields", ["field_id"], {:name=>"index_associations_fields_on_field_id"})

   -> 0.0022s

-- create_table("attended_conferences", {:force=>true})

   -> 0.0033s

-- add_index("attended_conferences", ["applicant_id"], {:name=>"index_attended_conferences_on_applicant_id"})

   -> 0.0024s

-- add_index("attended_conferences", ["identifier"], {:name=>"index_attended_conferences_on_identifier"})

   -> 0.0021s

-- create_table("background_check_accounts", {:force=>true})

   -> 0.0032s

-- add_index("background_check_accounts", ["program_id", "partner_identifier"], {:name=>"program_id_vendor_unique_id", :unique=>true})

   -> 0.0022s

-- create_table("background_check_requests", {:force=>true})

   -> 0.0028s

-- create_table("campus_designations", {:force=>true})

   -> 0.0032s

-- add_index("campus_designations", ["applicant_id"], {:name=>"index_campus_designations_on_applicant_id"})

   -> 0.0023s

-- add_index("campus_designations", ["campus_id"], {:name=>"index_campus_designations_on_campus_id"})

   -> 0.0022s

-- add_index("campus_designations", ["designation_id"], {:name=>"index_campus_designations_on_designation_id"})

   -> 0.0023s

-- add_index("campus_designations", ["organization_id"], {:name=>"index_campus_designations_on_organization_id"})

   -> 0.0020s

-- create_table("campuses", {:force=>true})

   -> 0.0031s

-- create_table("canadian_citizenship_statuses", {:force=>true})

   -> 0.0031s

-- create_table("cas_attachment_programs", {:force=>true})

   -> 0.0027s

-- add_index("cas_attachment_programs", ["applicant_id"], {:name=>"index_cas_attachment_programs_on_applicant_id"})

   -> 0.0021s

-- add_index("cas_attachment_programs", ["program_id", "cas_attachment_id"], {:name=>"unique_cas_attachment_programs", :unique=>true})

   -> 0.0027s

-- create_table("cas_attachments", {:force=>true})

   -> 0.0036s

-- add_index("cas_attachments", ["applicant_id"], {:name=>"index_cas_attachments_on_applicant_id"})

   -> 0.0024s

-- add_index("cas_attachments", ["identifier"], {:name=>"index_cas_attachments_on_identifier"})

   -> 0.0021s

-- add_index("cas_attachments", ["owner_id"], {:name=>"index_cas_attachments_on_owner_id"})

   -> 0.0022s

-- add_index("cas_attachments", ["owner_type"], {:name=>"index_cas_attachments_on_owner_type"})

   -> 0.0022s

-- add_index("cas_attachments", ["scope_type"], {:name=>"index_cas_attachments_on_scope_type"})

   -> 0.0021s

-- create_table("cas_comments", {:force=>true})

   -> 0.0035s

-- add_index("cas_comments", ["applicant_id"], {:name=>"index_cas_comments_on_applicant_id"})

   -> 0.0022s

-- add_index("cas_comments", ["association_id", "identifier"], {:name=>"index_cas_comments_on_association_id_and_identifier"})

   -> 0.0022s

-- add_index("cas_comments", ["association_id"], {:name=>"index_cas_comments_on_association_id"})

   -> 0.0023s

-- add_index("cas_comments", ["cas_management_id"], {:name=>"index_cas_comments_on_cas_management_id"})

   -> 0.0023s

-- add_index("cas_comments", ["identifier"], {:name=>"index_cas_comments_on_identifier"})

   -> 0.0021s

-- create_table("cas_gpa_types", {:force=>true})

   -> 0.0031s

-- create_table("cas_identifiers", {:force=>true})

   -> 0.0033s

-- add_index("cas_identifiers", ["identifier"], {:name=>"index_cas_identifiers_on_identifier", :unique=>true})

   -> 0.0024s

-- create_table("cas_managements", {:force=>true})

   -> 0.0033s

-- add_index("cas_managements", ["association_id", "identifier"], {:name=>"index_cas_managements_on_association_id_and_identifier"})

   -> 0.0024s

-- add_index("cas_managements", ["association_id"], {:name=>"index_cas_managements_on_association_id"})

   -> 0.0021s

-- add_index("cas_managements", ["identifier"], {:name=>"index_cas_managements_on_identifier"})

   -> 0.0026s

-- create_table("cas_splashes", {:force=>true})

   -> 0.0032s

-- add_index("cas_splashes", ["association_id"], {:name=>"index_cas_splashes_on_association_id"})

   -> 0.0024s

-- add_index("cas_splashes", ["splash_id"], {:name=>"index_cas_splashes_on_splash_id"})

   -> 0.0021s

-- create_table("certifications", {:force=>true})

   -> 0.0047s

-- add_index("certifications", ["applicant_id"], {:name=>"index_certifications_on_applicant_id"})

   -> 0.0041s

-- add_index("certifications", ["identifier"], {:name=>"index_certifications_on_identifier"})

   -> 0.0024s

-- add_index("certifications", ["user_entered_type"], {:name=>"index_certifications_on_type"})

   -> 0.0023s

-- create_table("change_requests", {:force=>true})

   -> 0.0033s

-- add_index("change_requests", ["requested_object_id"], {:name=>"index_change_requests_on_requested_object_id"})

   -> 0.0024s

-- add_index("change_requests", ["user_identity_requesting_id"], {:name=>"index_change_requests_on_user_identity_requesting_id"})

   -> 0.0024s

-- create_table("citizenship_statuses", {:force=>true})

   -> 0.0035s

-- add_index("citizenship_statuses", ["association_id", "identifier"], {:name=>"index_citizenship_statuses_on_association_id_and_identifier"})

   -> 0.0028s

-- add_index("citizenship_statuses", ["association_id"], {:name=>"index_citizenship_statuses_on_association_id"})

   -> 0.0023s

-- add_index("citizenship_statuses", ["identifier"], {:name=>"index_citizenship_statuses_on_identifier"})

   -> 0.0024s

-- create_table("classifications_gpa_templates", {:force=>true})

   -> 0.0029s

-- add_index("classifications_gpa_templates", ["classification_id"], {:name=>"index_classifications_gpa_templates_on_classification_id"})

   -> 0.0023s

-- add_index("classifications_gpa_templates", ["gpa_template_id"], {:name=>"index_classifications_gpa_templates_on_gpa_template_id"})

   -> 0.0021s

-- create_table("clauses", {:force=>true})

   -> 0.0029s

-- add_index("clauses", ["field_id"], {:name=>"index_clauses_on_field_id"})

   -> 0.0026s

-- add_index("clauses", ["field_operator_id"], {:name=>"index_clauses_on_field_operator_id"})

   -> 0.0022s

-- add_index("clauses", ["list_id"], {:name=>"index_clauses_on_list_id"})

   -> 0.0021s

-- create_table("college_attendeds", {:force=>true})

   -> 0.0051s

-- add_index("college_attendeds", ["academic_year_id"], {:name=>"index_college_attendeds_on_academic_year_id"})

   -> 0.0025s

-- add_index("college_attendeds", ["applicant_id"], {:name=>"index_college_attendeds_on_applicant_id"})

   -> 0.0023s

-- add_index("college_attendeds", ["cas_answer_set_id"], {:name=>"index_college_attendeds_on_cas_answer_set_id"})

   -> 0.0026s

-- add_index("college_attendeds", ["college_id"], {:name=>"index_college_attendeds_on_college_id"})

   -> 0.0022s

-- add_index("college_attendeds", ["dental_degree_id"], {:name=>"index_college_attendeds_on_dental_degree_id"})

   -> 0.0025s

-- add_index("college_attendeds", ["identifier"], {:name=>"index_college_attendeds_on_identifier"})

   -> 0.0022s

-- add_index("college_attendeds", ["school_type_id"], {:name=>"index_college_attendeds_on_school_type_id"})

   -> 0.0027s

-- add_index("college_attendeds", ["type"], {:name=>"index_college_attendeds_on_type"})

   -> 0.0021s

-- create_table("college_bases", {:force=>true})

   -> 0.0034s

-- add_index("college_bases", ["association_id", "identifier"], {:name=>"index_college_bases_on_association_id_and_identifier"})

   -> 0.0025s

-- add_index("college_bases", ["association_id", "master_college_id"], {:name=>"index_college_bases_on_association_id_and_master_college_id", :unique=>true})

   -> 0.0027s

-- add_index("college_bases", ["association_id"], {:name=>"index_college_bases_on_association_id"})

   -> 0.0027s

-- add_index("college_bases", ["identifier"], {:name=>"index_colleges_on_identifier"})

   -> 0.0023s

-- add_index("college_bases", ["mdb_code"], {:name=>"index_colleges_on_mdb_code"})

   -> 0.0024s

-- add_index("college_bases", ["type"], {:name=>"index_college_bases_on_type"})

   -> 0.0021s

-- create_table("color_maps", {:force=>true})

   -> 0.0037s

-- create_table("column_grouping_types", {:force=>true})

   -> 0.0031s

-- create_table("combined_degrees", {:force=>true})

   -> 0.0030s

-- add_index("combined_degrees", ["program_id"], {:name=>"index_combined_degrees_on_program_id"})

   -> 0.0021s

-- create_table("component_list_operators", {:force=>true})

   -> 0.0033s

-- create_table("component_lists", {:force=>true})

   -> 0.0028s

-- add_index("component_lists", ["component_list_operator_id"], {:name=>"index_component_lists_on_component_list_operator_id"})

   -> 0.0021s

-- add_index("component_lists", ["composite_list_id"], {:name=>"index_component_lists_on_composite_list_id"})

   -> 0.0025s

-- add_index("component_lists", ["list_id"], {:name=>"index_component_lists_on_list_id"})

   -> 0.0021s

-- create_table("config_portal_sync_logs", {:force=>true})

   -> 0.0032s

-- create_table("contact_preferences", {:force=>true})

   -> 0.0032s

-- add_index("contact_preferences", ["association_id", "identifier"], {:name=>"index_contact_preferences_on_association_id_and_identifier"})

   -> 0.0030s

-- add_index("contact_preferences", ["association_id"], {:name=>"index_contact_preferences_on_association_id"})

   -> 0.0024s

-- add_index("contact_preferences", ["identifier"], {:name=>"index_contact_preferences_on_identifier"})

   -> 0.0019s

-- add_index("contact_preferences", ["type"], {:name=>"index_contact_preferences_on_type"})

   -> 0.0020s

-- create_table("contact_types", {:force=>true})

   -> 0.0028s

-- add_index("contact_types", ["name"], {:name=>"index_contact_types_on_name"})

   -> 0.0023s

-- create_table("contacts", {:force=>true})

   -> 0.0044s

-- add_index("contacts", ["applicant_id"], {:name=>"index_contacts_on_applicant_id"})

   -> 0.0030s

-- add_index("contacts", ["contact_type_id"], {:name=>"index_contacts_on_contact_type_id"})

   -> 0.0024s

-- add_index("contacts", ["owner_id", "owner_type"], {:name=>"index_contacts_on_owner_type_and_owner_id"})

   -> 0.0021s

-- create_table("counties", {:force=>true})

   -> 0.0032s

-- add_index("counties", ["association_id", "identifier"], {:name=>"index_counties_on_association_id_and_identifier"})

   -> 0.0022s

-- add_index("counties", ["association_id"], {:name=>"index_counties_on_association_id"})

   -> 0.0025s

-- add_index("counties", ["identifier"], {:name=>"index_counties_on_identifier"})

   -> 0.0025s

-- create_table("countries", {:force=>true})

   -> 0.0034s

-- add_index("countries", ["abbreviation", "association_id"], {:name=>"index_countries_on_abbreviation_and_association_id", :unique=>true})

   -> 0.0024s

-- add_index("countries", ["association_id", "identifier"], {:name=>"index_countries_on_association_id_and_identifier"})

   -> 0.0027s

-- add_index("countries", ["association_id"], {:name=>"index_countries_on_association_id"})

   -> 0.0021s

-- add_index("countries", ["identifier"], {:name=>"index_countries_on_identifier"})

   -> 0.0023s

-- add_index("countries", ["name"], {:name=>"index_countries_on_name"})

   -> 0.0021s

-- create_table("county_indicators", {:force=>true})

   -> 0.0030s

-- create_table("courses", {:force=>true})

   -> 0.0046s

-- add_index("courses", ["academic_session_id"], {:name=>"index_courses_on_academic_session_id"})

   -> 0.0027s

-- add_index("courses", ["applicant_id"], {:name=>"index_courses_on_applicant_id"})

   -> 0.0022s

-- add_index("courses", ["association_id", "identifier"], {:name=>"index_courses_on_association_id_and_identifier"})

   -> 0.0030s

-- add_index("courses", ["association_id"], {:name=>"index_courses_on_association_id"})

   -> 0.0020s

-- add_index("courses", ["classification_id"], {:name=>"index_courses_on_classification_id"})

   -> 0.0024s

-- add_index("courses", ["identifier"], {:name=>"index_courses_on_identifier"})

   -> 0.0022s

-- add_index("courses", ["subject_id"], {:name=>"index_courses_on_subject_id"})

   -> 0.0020s

-- create_table("courses_local_gpas", {:id=>false, :force=>true})

   -> 0.0020s

-- add_index("courses_local_gpas", ["course_id"], {:name=>"index_courses_local_gpas_on_course_id"})

   -> 0.0020s

-- add_index("courses_local_gpas", ["local_gpa_id"], {:name=>"index_courses_local_gpas_on_local_gpa_id"})

   -> 0.0027s

-- create_table("credit_hour_inclusion_types", {:force=>true})

   -> 0.0030s

-- create_table("credit_inclusion_types", {:force=>true})

   -> 0.0037s

-- create_table("criteria", {:force=>true})

   -> 0.0037s

-- add_index("criteria", ["requirement_id", "requirement_type"], {:name=>"index_criteria_on_requirement_id_and_requirement_type"})

   -> 0.0025s

-- add_index("criteria", ["requirement_id"], {:name=>"index_criteria_on_requirement_id"})

   -> 0.0020s

-- create_table("criteria_comments", {:force=>true})

   -> 0.0027s

-- add_index("criteria_comments", ["criterion_id"], {:name=>"index_criteria_comments_on_criterion_id"})

   -> 0.0022s

-- create_table("cumulative_gpa_by_transcripts", {:force=>true})

   -> 0.0029s

-- add_index("cumulative_gpa_by_transcripts", ["applicant_id"], {:name=>"index_cumulative_gpa_by_transcripts_on_applicant_id"})

   -> 0.0021s

-- add_index("cumulative_gpa_by_transcripts", ["cumulative_gpa"], {:name=>"index_cumulative_gpa_by_transcripts_on_cumulative_gpa"})

   -> 0.0026s

-- add_index("cumulative_gpa_by_transcripts", ["total_credit_hours"], {:name=>"index_cumulative_gpa_by_transcripts_on_total_credit_hours"})

   -> 0.0023s

-- add_index("cumulative_gpa_by_transcripts", ["total_quality_points"], {:name=>"index_cumulative_gpa_by_transcripts_on_total_quality_points"})

   -> 0.0021s

-- add_index("cumulative_gpa_by_transcripts", ["type"], {:name=>"index_cumulative_gpa_by_transcripts_on_type"})

   -> 0.0022s

-- create_table("custom_choices", {:force=>true})

   -> 0.0030s

-- create_table("custom_field_types", {:force=>true})

   -> 0.0036s

-- create_table("custom_fields_programs", {:force=>true})

   -> 0.0027s

-- add_index("custom_fields_programs", ["custom_field_id"], {:name=>"index_custom_fields_programs_on_custom_field_id"})

   -> 0.0022s

-- add_index("custom_fields_programs", ["program_id"], {:name=>"index_custom_fields_programs_on_program_id"})

   -> 0.0022s

-- create_table("cycles", {:force=>true})

   -> 0.0035s

-- create_table("decision_descriptions", {:force=>true})

   -> 0.0039s

-- add_index("decision_descriptions", ["organization_id", "decision_id"], {:name=>"index_decision_descriptions_on_organization_id_and_decision_id", :unique=>true})

   -> 0.0024s

-- create_table("decisions", {:force=>true})

   -> 0.0040s

-- add_index("decisions", ["association_id", "identifier"], {:name=>"index_decisions_on_association_id_and_identifier"})

   -> 0.0021s

-- add_index("decisions", ["association_id"], {:name=>"index_decisions_on_association_id"})

   -> 0.0027s

-- add_index("decisions", ["identifier"], {:name=>"index_decisions_on_identifier"})

   -> 0.0022s

-- create_table("degree_bases", {:force=>true})

   -> 0.0032s

-- add_index("degree_bases", ["association_id", "identifier"], {:name=>"index_degree_bases_on_association_id_and_identifier"})

   -> 0.0023s

-- add_index("degree_bases", ["association_id"], {:name=>"index_degrees_on_association_id"})

   -> 0.0021s

-- add_index("degree_bases", ["identifier"], {:name=>"index_degrees_on_identifier"})

   -> 0.0021s

-- add_index("degree_bases", ["type"], {:name=>"index_degree_bases_on_type"})

   -> 0.0023s

-- create_table("degree_statuses", {:force=>true})

   -> 0.0033s

-- add_index("degree_statuses", ["association_id", "identifier"], {:name=>"index_degree_statuses_on_association_id_and_identifier"})

   -> 0.0022s

-- add_index("degree_statuses", ["association_id"], {:name=>"index_degree_statuses_on_association_id"})

   -> 0.0020s

-- add_index("degree_statuses", ["identifier"], {:name=>"index_degree_statuses_on_identifier"})

   -> 0.0025s

-- create_table("deleted_applicants", {:force=>true})

   -> 0.0036s

-- create_table("designation_evaluations", {:force=>true})

   -> 0.0033s

-- add_index("designation_evaluations", ["applicant_id"], {:name=>"index_designation_evaluations_on_applicant_id"})

   -> 0.0026s

-- add_index("designation_evaluations", ["association_id", "identifier"], {:name=>"index_designation_evaluations_on_association_id_and_identifier"})

   -> 0.0025s

-- add_index("designation_evaluations", ["association_id"], {:name=>"index_designation_evaluations_on_association_id"})

   -> 0.0021s

-- add_index("designation_evaluations", ["designation_id"], {:name=>"index_designation_evaluations_on_designation_id"})

   -> 0.0022s

-- add_index("designation_evaluations", ["evaluation_id"], {:name=>"index_designation_evaluations_on_evaluation_id"})

   -> 0.0025s

-- add_index("designation_evaluations", ["identifier"], {:name=>"index_designation_evaluations_on_identifier"})

   -> 0.0023s

-- add_index("designation_evaluations", ["program_id"], {:name=>"index_designation_evaluations_on_program_id"})

   -> 0.0021s

-- create_table("designation_optional_offerings", {:force=>true})

   -> 0.0030s

-- add_index("designation_optional_offerings", ["designation_id"], {:name=>"index_designation_optional_offerings_on_designation_id"})

   -> 0.0023s

-- add_index("designation_optional_offerings", ["optional_offering_id"], {:name=>"index_designation_optional_offerings_on_optional_offering_id"})

   -> 0.0029s

-- create_table("designations", {:force=>true})

   -> 0.0046s

-- add_index("designations", ["academic_update_status_id"], {:name=>"index_designations_on_academic_update_status_id"})

   -> 0.0025s

-- add_index("designations", ["applicant_id", "application_status_id"], {:name=>"index_designations_on_applicant_id_and_application_status_id"})

   -> 0.0027s

-- add_index("designations", ["applicant_id", "program_id"], {:name=>"index_designations_on_applicant_id_and_program_id", :unique=>true})

   -> 0.0021s

-- add_index("designations", ["applicant_id"], {:name=>"index_designations_on_applicant_id"})

   -> 0.0022s

-- add_index("designations", ["application_status_id"], {:name=>"index_designations_on_application_status_id"})

   -> 0.0022s

-- add_index("designations", ["association_id", "identifier"], {:name=>"index_designations_on_association_id_and_identifier"})

   -> 0.0025s

-- add_index("designations", ["association_id"], {:name=>"index_designations_on_association_id"})

   -> 0.0026s

-- add_index("designations", ["decision_id"], {:name=>"index_designations_on_decision_id"})

   -> 0.0021s

-- add_index("designations", ["identifier"], {:name=>"index_designations_on_identifier"})

   -> 0.0022s

-- add_index("designations", ["local_status_id"], {:name=>"index_designations_on_local_status_id"})

   -> 0.0024s

-- add_index("designations", ["program_id", "identifier"], {:name=>"index_designations_on_program_id_and_identifier"})

   -> 0.0022s

-- add_index("designations", ["program_id"], {:name=>"index_designations_on_program_id"})

   -> 0.0022s

-- create_table("details", {:force=>true})

   -> 0.0135s

-- add_index("details", ["additional_language_id"], {:name=>"index_details_on_additional_language_id"})

   -> 0.0028s

-- add_index("details", ["applicant_id"], {:name=>"index_details_on_applicant_id"})

   -> 0.0025s

-- add_index("details", ["canadian_visa_type_id"], {:name=>"index_details_on_canadian_visa_type_id"})

   -> 0.0023s

-- add_index("details", ["certification_ecfmg_id"], {:name=>"index_details_on_certification_ecfmg_id"})

   -> 0.0027s

-- add_index("details", ["citizenship_country_id"], {:name=>"index_details_on_citizenship_country_id"})

   -> 0.0023s

-- add_index("details", ["citizenship_status_id"], {:name=>"index_details_on_citizenship_status_id"})

   -> 0.0023s

-- add_index("details", ["country_of_birth_id"], {:name=>"index_details_on_country_of_birth_id"})

   -> 0.0022s

-- add_index("details", ["country_of_residence_id"], {:name=>"index_details_on_country_of_residence_id"})

   -> 0.0022s

-- add_index("details", ["county_of_birth_id"], {:name=>"index_details_on_county_of_birth_id"})

   -> 0.0023s

-- add_index("details", ["county_of_residence_id"], {:name=>"index_details_on_county_of_residence_id"})

   -> 0.0022s

-- add_index("details", ["first_heard_education_id"], {:name=>"index_details_on_first_heard_education_id"})

   -> 0.0022s

-- add_index("details", ["gender_id"], {:name=>"index_details_on_gender_id"})

   -> 0.0025s

-- add_index("details", ["highest_degree_earned_id"], {:name=>"index_details_on_highest_degree_earned_id"})

   -> 0.0023s

-- add_index("details", ["influential_factor_id"], {:name=>"index_details_on_influential_factor_id"})

   -> 0.0024s

-- add_index("details", ["military_status_id"], {:name=>"index_details_on_military_status_id"})

   -> 0.0022s

-- add_index("details", ["phone_type_preference_id"], {:name=>"index_details_on_phone_type_preference_id"})

   -> 0.0023s

-- add_index("details", ["preferred_address_type_id"], {:name=>"index_details_on_preferred_address_type_id"})

   -> 0.0027s

-- add_index("details", ["previous_state_of_residence_id"], {:name=>"index_details_on_previous_state_of_residence_id"})

   -> 0.0024s

-- add_index("details", ["previously_enrolled_specify_id"], {:name=>"index_details_on_previously_enrolled_specify_id"})

   -> 0.0023s

-- add_index("details", ["previously_school_attended_id"], {:name=>"index_details_on_previously_school_attended_id"})

   -> 0.0022s

-- add_index("details", ["second_citizenship_country_id"], {:name=>"index_details_on_second_citizenship_country_id"})

   -> 0.0023s

-- add_index("details", ["state_of_birth_id"], {:name=>"index_details_on_state_of_birth_id"})

   -> 0.0026s

-- add_index("details", ["state_of_residence_id"], {:name=>"index_details_on_state_of_residence_id"})

   -> 0.0023s

-- add_index("details", ["student_status_id"], {:name=>"index_details_on_student_status_id"})

   -> 0.0022s

-- add_index("details", ["visa_type_id"], {:name=>"index_details_on_visa_type_id"})

   -> 0.0023s

-- create_table("diplomas", {:force=>true})

   -> 0.0035s

-- add_index("diplomas", ["applicant_id"], {:name=>"index_diplomas_on_applicant_id"})

   -> 0.0023s

-- create_table("document_sources", {:force=>true})

   -> 0.0033s

-- add_index("document_sources", ["association_id"], {:name=>"index_document_sources_on_association_id"})

   -> 0.0023s

-- create_table("documents_mailing_sources", {:force=>true})

   -> 0.0034s

-- add_index("documents_mailing_sources", ["association_id"], {:name=>"index_documents_mailing_sources_on_association_id"})

   -> 0.0029s

-- create_table("email_address_preferences", {:force=>true})

   -> 0.0050s

-- add_index("email_address_preferences", ["identifier"], {:name=>"index_email_address_preferences_on_identifier"})

   -> 0.0024s

-- create_table("email_address_programs", {:force=>true})

   -> 0.0029s

-- add_index("email_address_programs", ["address_id"], {:name=>"index_email_address_programs_on_address_id"})

   -> 0.0023s

-- add_index("email_address_programs", ["program_id"], {:name=>"index_email_address_programs_on_program_id"})

   -> 0.0024s

-- create_table("email_addresses", {:force=>true})

   -> 0.0044s

-- add_index("email_addresses", ["bcc_preference_id"], {:name=>"index_email_addresses_on_bcc_preference_id"})

   -> 0.0023s

-- add_index("email_addresses", ["cc_preference_id"], {:name=>"index_email_addresses_on_cc_preference_id"})

   -> 0.0022s

-- add_index("email_addresses", ["owner_type", "owner_id"], {:name=>"index_email_addresses_on_owner_type_and_owner_id"})

   -> 0.0022s

-- add_index("email_addresses", ["reply_to_preference_id"], {:name=>"index_email_addresses_on_reply_to_preference_id"})

   -> 0.0022s

-- create_table("email_ccs", {:force=>true})

   -> 0.0029s

-- add_index("email_ccs", ["email_address_id"], {:name=>"index_email_ccs_on_email_address_id"})

   -> 0.0022s

-- add_index("email_ccs", ["email_id"], {:name=>"index_email_ccs_on_email_id"})

   -> 0.0023s

-- create_table("email_events", {:force=>true})

   -> 0.0037s

-- add_index("email_events", ["applicants_email_id"], {:name=>"index_email_events_on_applicants_email_id"})

   -> 0.0031s

-- create_table("email_reply_to", {:id=>false, :force=>true})

   -> 0.0020s

-- add_index("email_reply_to", ["email_address_id"], {:name=>"index_email_reply_to_on_email_address_id"})

   -> 0.0023s

-- add_index("email_reply_to", ["email_id"], {:name=>"index_email_reply_to_on_email_id"})

   -> 0.0023s

-- create_table("email_templates", {:force=>true})

   -> 0.0036s

-- add_index("email_templates", ["active"], {:name=>"index_email_templates_on_active"})

   -> 0.0025s

-- add_index("email_templates", ["organization_id"], {:name=>"index_email_templates_on_organization_id"})

   -> 0.0021s

-- add_index("email_templates", ["user_id"], {:name=>"index_email_templates_on_user_id"})

   -> 0.0021s

-- add_index("email_templates", ["user_identity_id"], {:name=>"index_email_templates_on_user_identity_id"})

   -> 0.0022s

-- add_index("email_templates", ["visibility"], {:name=>"index_email_templates_on_visibility"})

   -> 0.0022s

-- create_table("email_templates_programs", {:force=>true})

   -> 0.0029s

-- add_index("email_templates_programs", ["email_template_id"], {:name=>"index_email_template_designations_on_email_template_id"})

   -> 0.0023s

-- add_index("email_templates_programs", ["program_id"], {:name=>"index_email_template_designations_on_program_id"})

   -> 0.0022s

-- create_table("emails", {:force=>true})

   -> 0.0038s

-- add_index("emails", ["email_template_id"], {:name=>"index_emails_on_email_template_id"})

   -> 0.0022s

-- add_index("emails", ["user_id"], {:name=>"index_emails_on_user_id"})

   -> 0.0021s

-- add_index("emails", ["user_identity_id"], {:name=>"index_emails_on_user_identity_id"})

   -> 0.0026s

-- create_table("essay_programs", {:force=>true})

   -> 0.0029s

-- add_index("essay_programs", ["applicant_id"], {:name=>"index_essay_programs_on_applicant_id"})

   -> 0.0022s

-- add_index("essay_programs", ["essay_id"], {:name=>"index_essay_programs_on_essay_id"})

   -> 0.0021s

-- add_index("essay_programs", ["identifier"], {:name=>"index_essay_programs_on_identifier"})

   -> 0.0020s

-- add_index("essay_programs", ["program_id"], {:name=>"index_essay_programs_on_program_id"})

   -> 0.0022s

-- create_table("essays", {:force=>true})

   -> 0.0044s

-- add_index("essays", ["applicant_id"], {:name=>"index_essays_on_applicant_id"})

   -> 0.0023s

-- add_index("essays", ["identifier"], {:name=>"index_essays_on_identifier"})

   -> 0.0021s

-- add_index("essays", ["turnitin_document_id"], {:name=>"index_essays_on_turnitin_document_id"})

   -> 0.0024s

-- create_table("ethnicities", {:force=>true})

   -> 0.0036s

-- add_index("ethnicities", ["category"], {:name=>"index_ethnicities_on_category"})

   -> 0.0023s

-- add_index("ethnicities", ["identifier", "field_type"], {:name=>"index_ethnicities_on_identifier_and_field_type", :unique=>true})

   -> 0.0023s

-- create_table("etl_runs", {:force=>true})

   -> 0.0036s

-- add_index("etl_runs", ["association_id"], {:name=>"index_etl_runs_on_cas_id"})

   -> 0.0022s

-- create_table("evaluation_additional_evaluators", {:force=>true})

   -> 0.0036s

-- add_index("evaluation_additional_evaluators", ["evaluation_id"], {:name=>"index_evaluation_additional_evaluators_on_evaluation_id"})

   -> 0.0027s

-- create_table("evaluation_answers", {:force=>true})

   -> 0.0034s

-- add_index("evaluation_answers", ["answered_by_id"], {:name=>"index_evaluation_answers_on_answered_by_id"})

   -> 0.0036s

-- add_index("evaluation_answers", ["applicant_id"], {:name=>"index_evaluation_answers_on_applicant_id"})

   -> 0.0023s

-- add_index("evaluation_answers", ["evaluation_id"], {:name=>"index_evaluation_answers_on_evaluation_id"})

   -> 0.0021s

-- add_index("evaluation_answers", ["question_base_id"], {:name=>"index_evaluation_answers_on_question_base_id"})

   -> 0.0022s

-- add_index("evaluation_answers", ["supplemental_lookup_id"], {:name=>"index_evaluation_answers_on_supplemental_lookup_id"})

   -> 0.0021s

-- create_table("evaluation_requests", {:force=>true})

   -> 0.0036s

-- add_index("evaluation_requests", ["applicant_id"], {:name=>"index_evaluation_requests_on_applicant_id"})

   -> 0.0023s

-- create_table("evaluation_summaries", {:force=>true})

   -> 0.0027s

-- add_index("evaluation_summaries", ["applicant_id"], {:name=>"index_evaluation_summaries_on_applicant_id"})

   -> 0.0022s

-- create_table("evaluation_types", {:force=>true})

   -> 0.0095s

-- add_index("evaluation_types", ["association_id", "identifier"], {:name=>"index_evaluation_types_on_association_id_and_identifier"})

   -> 0.0049s

-- add_index("evaluation_types", ["association_id"], {:name=>"index_evaluation_types_on_association_id"})

   -> 0.0090s

-- add_index("evaluation_types", ["identifier"], {:name=>"index_evaluation_types_on_identifier"})

   -> 0.0029s

-- create_table("evaluations", {:force=>true})

   -> 0.0074s

-- add_index("evaluations", ["applicant_id"], {:name=>"index_evaluations_on_applicant_id"})

   -> 0.0025s

-- add_index("evaluations", ["association_id", "identifier"], {:name=>"index_evaluations_on_association_id_and_identifier"})

   -> 0.0021s

-- add_index("evaluations", ["association_id"], {:name=>"index_evaluations_on_association_id"})

   -> 0.0022s

-- add_index("evaluations", ["cas_evaluator_id"], {:name=>"index_evaluations_on_cas_evaluator_id"})

   -> 0.0020s

-- add_index("evaluations", ["evaluation_type_id"], {:name=>"index_evaluations_on_evaluation_type_id"})

   -> 0.0021s

-- add_index("evaluations", ["evaluator_type"], {:name=>"index_evaluations_on_evaluator_type"})

   -> 0.0025s

-- add_index("evaluations", ["how_well_known_id"], {:name=>"index_evaluations_on_how_well_known_id"})

   -> 0.0022s

-- add_index("evaluations", ["identifier"], {:name=>"index_evaluations_on_identifier"})

   -> 0.0027s

-- add_index("evaluations", ["length_known_id"], {:name=>"index_evaluations_on_length_known_id"})

   -> 0.0023s

-- add_index("evaluations", ["organization_id"], {:name=>"index_evaluations_on_organization_id"})

   -> 0.0022s

-- add_index("evaluations", ["scope_type"], {:name=>"index_evaluations_on_scope_type"})

   -> 0.0025s

-- create_table("evaluators", {:force=>true})

   -> 0.0045s

-- add_index("evaluators", ["association_id", "identifier"], {:name=>"index_evaluators_on_association_id_and_identifier"})

   -> 0.0030s

-- add_index("evaluators", ["association_id"], {:name=>"index_evaluators_on_association_id"})

   -> 0.0023s

-- add_index("evaluators", ["identifier"], {:name=>"index_evaluators_on_identifier"})

   -> 0.0024s

-- add_index("evaluators", ["occupation_id"], {:name=>"index_evaluators_on_occupation_id"})

   -> 0.0023s

-- add_index("evaluators", ["phone_type_id"], {:name=>"index_evaluators_on_phone_type_id"})

   -> 0.0022s

-- add_index("evaluators", ["type"], {:name=>"index_evaluators_on_type"})

   -> 0.0022s

-- create_table("events", {:force=>true})

   -> 0.0035s

-- add_index("events", ["applicant_id"], {:name=>"index_events_on_applicant_id"})

   -> 0.0023s

-- add_index("events", ["local_status_id"], {:name=>"index_events_on_local_status_id"})

   -> 0.0023s

-- add_index("events", ["old_local_status_id"], {:name=>"index_events_on_old_local_status_id"})

   -> 0.0025s

-- add_index("events", ["program_id"], {:name=>"index_events_on_program_id"})

   -> 0.0022s

-- add_index("events", ["user_id"], {:name=>"index_events_on_user_id"})

   -> 0.0023s

-- create_table("experience_frequencies", {:force=>true})

   -> 0.0032s

-- add_index("experience_frequencies", ["association_id", "identifier"], {:name=>"index_experience_frequencies_on_association_id_and_identifier"})

   -> 0.0023s

-- add_index("experience_frequencies", ["association_id"], {:name=>"index_experience_frequencies_on_association_id"})

   -> 0.0022s

-- add_index("experience_frequencies", ["identifier"], {:name=>"index_experience_frequencies_on_identifier"})

   -> 0.0021s

-- create_table("experience_pay_types", {:force=>true})

   -> 0.0033s

-- add_index("experience_pay_types", ["association_id", "identifier"], {:name=>"index_experience_pay_types_on_association_id_and_identifier"})

   -> 0.0023s

-- add_index("experience_pay_types", ["association_id"], {:name=>"index_experience_pay_types_on_association_id"})

   -> 0.0020s

-- add_index("experience_pay_types", ["identifier"], {:name=>"index_experience_pay_types_on_identifier"})

   -> 0.0026s

-- create_table("experience_positions", {:force=>true})

   -> 0.0027s

-- create_table("experience_settings", {:force=>true})

   -> 0.0030s

-- add_index("experience_settings", ["association_id", "identifier"], {:name=>"index_experience_settings_on_association_id_and_identifier"})

   -> 0.0022s

-- add_index("experience_settings", ["association_id"], {:name=>"index_experience_settings_on_association_id"})

   -> 0.0020s

-- add_index("experience_settings", ["identifier"], {:name=>"index_experience_settings_on_identifier"})

   -> 0.0021s

-- create_table("experience_type_total_hours", {:force=>true})

   -> 0.0030s

-- create_table("experience_types", {:force=>true})

   -> 0.0032s

-- add_index("experience_types", ["association_id", "identifier"], {:name=>"index_experience_types_on_association_id_and_identifier"})

   -> 0.0025s

-- add_index("experience_types", ["association_id"], {:name=>"index_experience_types_on_association_id"})

   -> 0.0026s

-- add_index("experience_types", ["identifier"], {:name=>"index_experience_types_on_identifier"})

   -> 0.0022s

-- create_table("experiences", {:force=>true})

   -> 0.0060s

-- add_index("experiences", ["applicant_id"], {:name=>"index_experiences_on_applicant_id"})

   -> 0.0026s

-- add_index("experiences", ["employment_experience_timeframe_id"], {:name=>"index_experiences_on_employment_experience_timeframe_id"})

   -> 0.0026s

-- add_index("experiences", ["experience_setting_id"], {:name=>"index_experiences_on_experience_setting_id"})

   -> 0.0022s

-- add_index("experiences", ["experience_timeframe_id"], {:name=>"index_experiences_on_experience_timeframe_id"})

   -> 0.0023s

-- add_index("experiences", ["experience_type_id"], {:name=>"index_experiences_on_experience_type_id"})

   -> 0.0023s

-- add_index("experiences", ["health_care_profession_id"], {:name=>"index_experiences_on_health_care_profession_id"})

   -> 0.0027s

-- add_index("experiences", ["health_care_setting_id"], {:name=>"index_experiences_on_health_care_setting_id"})

   -> 0.0021s

-- add_index("experiences", ["identifier"], {:name=>"index_experiences_on_identifier"})

   -> 0.0021s

-- add_index("experiences", ["status_id"], {:name=>"index_experiences_on_status_id"})

   -> 0.0024s

-- add_index("experiences", ["type"], {:name=>"index_experiences_on_type"})

   -> 0.0021s

-- create_table("export_files", {:force=>true})

   -> 0.0033s

-- add_index("export_files", ["export_id"], {:name=>"index_export_files_on_export_id"})

   -> 0.0020s

-- create_table("export_formats", {:force=>true})

   -> 0.0034s

-- create_table("export_limit_associations", {:force=>true})

   -> 0.0032s

-- create_table("exports", {:force=>true})

   -> 0.0036s

-- add_index("exports", ["decision_id"], {:name=>"index_exports_on_decision_id"})

   -> 0.0027s

-- add_index("exports", ["export_format_id"], {:name=>"index_exports_on_export_format_id"})

   -> 0.0021s

-- add_index("exports", ["show_on_toolbar"], {:name=>"index_exports_on_show_on_toolbar"})

   -> 0.0020s

-- add_index("exports", ["static_list_id"], {:name=>"index_exports_on_static_list_id"})

   -> 0.0023s

-- add_index("exports", ["type"], {:name=>"index_exports_on_type"})

   -> 0.0020s

-- add_index("exports", ["user_id"], {:name=>"index_exports_on_user_id"})

   -> 0.0020s

-- add_index("exports", ["user_identity_id"], {:name=>"index_exports_on_user_identity_id"})

   -> 0.0023s

-- create_table("exports_fields", {:force=>true})

   -> 0.0029s

-- add_index("exports_fields", ["export_id"], {:name=>"index_exports_fields_on_export_id"})

   -> 0.0022s

-- add_index("exports_fields", ["field_id"], {:name=>"index_exports_fields_on_field_id"})

   -> 0.0024s

-- create_table("faqs", {:force=>true})

   -> 0.0032s

-- add_index("faqs", ["association_id"], {:name=>"index_faqs_on_association_id"})

   -> 0.0020s

-- create_table("feature_assignments", {:force=>true})

   -> 0.0028s

-- add_index("feature_assignments", ["assignee_type", "assignee_id"], {:name=>"index_feature_assignments_on_assignee_type_and_assignee_id"})

   -> 0.0023s

-- add_index("feature_assignments", ["feature_id"], {:name=>"index_feature_assignments_on_feature_id"})

   -> 0.0021s

-- create_table("features", {:force=>true})

   -> 0.0035s

-- create_table("field_categories", {:force=>true})

   -> 0.0036s

-- add_index("field_categories", ["identifier"], {:name=>"index_field_categories_on_identifier"})

   -> 0.0021s

-- add_index("field_categories", ["omit_from_clause_value_list"], {:name=>"index_field_categories_on_omit_from_clause_value_list"})

   -> 0.0022s

-- create_table("field_operators", {:force=>true})

   -> 0.0036s

-- add_index("field_operators", ["comparison_type_id"], {:name=>"index_field_operators_on_comparison_type_id"})

   -> 0.0021s

-- create_table("field_operators_field_types", {:id=>false, :force=>true})

   -> 0.0020s

-- add_index("field_operators_field_types", ["field_operator_id"], {:name=>"index_field_operators_field_types_on_field_operator_id"})

   -> 0.0023s

-- add_index("field_operators_field_types", ["field_type_id"], {:name=>"index_field_operators_field_types_on_field_type_id"})

   -> 0.0025s

-- create_table("field_transformations", {:force=>true})

   -> 0.0035s

-- create_table("field_types", {:force=>true})

   -> 0.0029s

-- add_index("field_types", ["default_field_operator_id"], {:name=>"index_field_types_on_default_field_operator_id"})

   -> 0.0022s

-- create_table("fields", {:force=>true})

   -> 0.0053s

-- add_index("fields", ["default_field_operator_id"], {:name=>"index_fields_on_default_field_operator_id"})

   -> 0.0024s

-- add_index("fields", ["field_category_id"], {:name=>"index_fields_on_field_category_id"})

   -> 0.0023s

-- add_index("fields", ["field_type_id"], {:name=>"index_fields_on_field_type_id"})

   -> 0.0025s

-- add_index("fields", ["identifier"], {:name=>"index_fields_on_identifier"})

   -> 0.0028s

-- add_index("fields", ["in_progress_export_order"], {:name=>"index_fields_on_in_progress_export_order"})

   -> 0.0020s

-- add_index("fields", ["organization_id"], {:name=>"index_fields_on_organization_id"})

   -> 0.0024s

-- add_index("fields", ["owner_type", "owner_id"], {:name=>"index_fields_on_owner_type_and_owner_id"})

   -> 0.0028s

-- add_index("fields", ["program_id"], {:name=>"index_fields_on_program_id"})

   -> 0.0022s

-- add_index("fields", ["relation_name", "narrow_field_name", "narrow_field_value"], {:name=>"narrow_field_lookup"})

   -> 0.0024s

-- add_index("fields", ["relation_name"], {:name=>"index_fields_on_relation_name"})

   -> 0.0021s

-- add_index("fields", ["sort_order"], {:name=>"index_fields_on_sort_order"})

   -> 0.0026s

-- create_table("first_heard_sources", {:force=>true})

   -> 0.0037s

-- add_index("first_heard_sources", ["association_id", "identifier"], {:name=>"index_first_heard_sources_on_association_id_and_identifier"})

   -> 0.0024s

-- add_index("first_heard_sources", ["association_id"], {:name=>"index_first_heard_sources_on_association_id"})

   -> 0.0023s

-- add_index("first_heard_sources", ["identifier"], {:name=>"index_first_heard_sources_on_identifier"})

   -> 0.0021s

-- create_table("first_post_graduate_years", {:force=>true})

   -> 0.0041s

-- add_index("first_post_graduate_years", ["applicant_id"], {:name=>"index_first_post_graduate_years_on_applicant_id"})

   -> 0.0023s

-- create_table("foreign_evaluations", {:force=>true})

   -> 0.0036s

-- add_index("foreign_evaluations", ["applicant_id"], {:name=>"index_foreign_evaluations_on_applicant_id"})

   -> 0.0023s

-- add_index("foreign_evaluations", ["identifier"], {:name=>"index_foreign_evaluations_on_identifier"})

   -> 0.0025s

-- create_table("genders", {:force=>true})

   -> 0.0034s

-- add_index("genders", ["association_id", "identifier"], {:name=>"index_genders_on_association_id_and_identifier"})

   -> 0.0024s

-- add_index("genders", ["association_id"], {:name=>"index_genders_on_association_id"})

   -> 0.0027s

-- add_index("genders", ["identifier"], {:name=>"index_genders_on_identifier"})

   -> 0.0022s

-- create_table("general_education_courses", {:force=>true})

   -> 0.0042s

-- add_index("general_education_courses", ["applicant_id", "subject_identifier"], {:name=>"idx_general_education_courses_applicant_id_subject_identifier", :unique=>true})

   -> 0.0025s

-- create_table("geographic_areas", {:force=>true})

   -> 0.0035s

-- add_index("geographic_areas", ["association_id", "identifier"], {:name=>"index_geographic_areas_on_association_id_and_identifier"})

   -> 0.0026s

-- add_index("geographic_areas", ["association_id"], {:name=>"index_geographic_areas_on_association_id"})

   -> 0.0021s

-- add_index("geographic_areas", ["identifier"], {:name=>"index_geographic_areas_on_identifier"})

   -> 0.0023s

-- create_table("geographic_indicators", {:force=>true})

   -> 0.0036s

-- add_index("geographic_indicators", ["applicant_id"], {:name=>"index_geographic_indicators_on_applicant_id"})

   -> 0.0026s

-- create_table("global_lookups", {:force=>true})

   -> 0.0036s

-- add_index("global_lookups", ["identifier", "type"], {:name=>"index_global_lookups_on_identifier_and_type", :unique=>true})

   -> 0.0029s

-- add_index("global_lookups", ["type"], {:name=>"index_global_lookups_on_type"})

   -> 0.0022s

-- create_table("gpa_by_academic_years", {:force=>true})

   -> 0.0039s

-- add_index("gpa_by_academic_years", ["academic_status_id"], {:name=>"index_gpa_by_academic_years_on_academic_status_id"})

   -> 0.0025s

-- add_index("gpa_by_academic_years", ["academic_year_id"], {:name=>"index_gpa_by_academic_years_on_academic_year_id"})

   -> 0.0026s

-- add_index("gpa_by_academic_years", ["applicant_id"], {:name=>"index_gpa_by_academic_years_on_applicant_id"})

   -> 0.0027s

-- add_index("gpa_by_academic_years", ["code"], {:name=>"index_gpa_by_academic_years_on_code"})

   -> 0.0020s

-- add_index("gpa_by_academic_years", ["identifier", "applicant_id"], {:name=>"index_gpa_by_academic_years_on_applicant_id_and_identifier"})

   -> 0.0023s

-- add_index("gpa_by_academic_years", ["identifier"], {:name=>"index_gpa_by_academic_years_on_identifier"})

   -> 0.0021s

-- add_index("gpa_by_academic_years", ["total_gpa"], {:name=>"index_gpa_by_academic_years_on_total_gpa"})

   -> 0.0021s

-- create_table("gpa_by_subjects", {:force=>true})

   -> 0.0034s

-- add_index("gpa_by_subjects", ["applicant_id"], {:name=>"index_gpa_by_subjects_on_applicant_id"})

   -> 0.0021s

-- add_index("gpa_by_subjects", ["identifier", "applicant_id"], {:name=>"index_gpa_by_subjects_on_identifier_and_applicant_id"})

   -> 0.0022s

-- add_index("gpa_by_subjects", ["identifier"], {:name=>"index_gpa_by_subjects_on_identifier"})

   -> 0.0021s

-- add_index("gpa_by_subjects", ["option_id"], {:name=>"index_gpa_by_subjects_on_option_id"})

   -> 0.0020s

-- add_index("gpa_by_subjects", ["subject_id"], {:name=>"index_gpa_by_subjects_on_subject_id"})

   -> 0.0025s

-- create_table("gpa_by_transcripts", {:force=>true})

   -> 0.0030s

-- add_index("gpa_by_transcripts", ["applicant_id"], {:name=>"index_gpa_by_transcripts_on_applicant_id"})

   -> 0.0022s

-- create_table("gpa_calculator_course_filters", {:force=>true})

   -> 0.0025s

-- create_table("gpa_supplemental_hours", {:force=>true})

   -> 0.0034s

-- add_index("gpa_supplemental_hours", ["applicant_id"], {:name=>"index_gpa_supplemental_hours_on_applicant_id"})

   -> 0.0025s

-- create_table("gpa_templates", {:force=>true})

   -> 0.0036s

-- add_index("gpa_templates", ["association_id"], {:name=>"index_gpa_templates_on_association_id"})

   -> 0.0022s

-- add_index("gpa_templates", ["organization_id"], {:name=>"index_gpa_templates_on_organization_id"})

   -> 0.0021s

-- create_table("gpa_templates_programs", {:force=>true})

   -> 0.0027s

-- add_index("gpa_templates_programs", ["gpa_template_id"], {:name=>"index_gpa_templates_programs_on_gpa_template_id"})

   -> 0.0023s

-- add_index("gpa_templates_programs", ["program_id"], {:name=>"index_gpa_templates_programs_on_program_id"})

   -> 0.0024s

-- create_table("gpa_templates_subjects", {:force=>true})

   -> 0.0031s

-- add_index("gpa_templates_subjects", ["gpa_template_id"], {:name=>"index_gpa_templates_subjects_on_gpa_template_id"})

   -> 0.0020s

-- add_index("gpa_templates_subjects", ["subject_id"], {:name=>"index_gpa_templates_subjects_on_subject_id"})

   -> 0.0022s

-- create_table("gpas_by_classification", {:force=>true})

   -> 0.0032s

-- add_index("gpas_by_classification", ["applicant_id"], {:name=>"index_gpas_by_classification_on_applicant_id"})

   -> 0.0025s

-- add_index("gpas_by_classification", ["classification_id"], {:name=>"index_gpas_by_classification_on_classification_id"})

   -> 0.0021s

-- create_table("gpas_by_school", {:force=>true})

   -> 0.0036s

-- add_index("gpas_by_school", ["applicant_id"], {:name=>"index_gpas_by_school_on_applicant_id"})

   -> 0.0019s

-- add_index("gpas_by_school", ["college_id"], {:name=>"index_gpas_by_school_on_college_id"})

   -> 0.0029s

-- add_index("gpas_by_school", ["identifier"], {:name=>"index_gpas_by_school_on_identifier"})

   -> 0.0019s

-- create_table("grade_numeric_converters", {:force=>true})

   -> 0.0027s

-- create_table("grades", {:force=>true})

   -> 0.0035s

-- add_index("grades", ["association_id"], {:name=>"index_grades_on_association_id"})

   -> 0.0021s

-- add_index("grades", ["type"], {:name=>"index_grades_on_type"})

   -> 0.0023s

-- create_table("guardians", {:force=>true})

   -> 0.0044s

-- add_index("guardians", ["applicant_id"], {:name=>"index_guardians_on_applicant_id"})

   -> 0.0020s

-- create_table("health_related_certification_trainings", {:force=>true})

   -> 0.0030s

-- add_index("health_related_certification_trainings", ["applicant_id"], {:name=>"index_health_related_certification_trainings_on_applicant_id"})

   -> 0.0021s

-- add_index("health_related_certification_trainings", ["identifier"], {:name=>"index_health_related_certification_trainings_on_identifier"})

   -> 0.0020s

-- add_index("health_related_certification_trainings", ["type"], {:name=>"index_health_related_certification_trainings_on_type"})

   -> 0.0020s

-- create_table("help_texts", {:force=>true})

   -> 0.0031s

-- create_table("honors_and_awards", {:force=>true})

   -> 0.0033s

-- add_index("honors_and_awards", ["applicant_id"], {:name=>"index_honors_and_awards_on_applicant_id"})

   -> 0.0019s

-- add_index("honors_and_awards", ["identifier"], {:name=>"index_honors_and_awards_on_identifier"})

   -> 0.0019s

-- create_table("indicators", {:force=>true})

   -> 0.0024s

-- create_table("influential_factors", {:force=>true})

   -> 0.0033s

-- add_index("influential_factors", ["association_id", "identifier"], {:name=>"index_influential_factors_on_association_id_and_identifier"})

   -> 0.0020s

-- add_index("influential_factors", ["association_id"], {:name=>"index_influential_factors_on_association_id"})

   -> 0.0020s

-- add_index("influential_factors", ["identifier"], {:name=>"index_influential_factors_on_identifier"})

   -> 0.0022s

-- create_table("inpatient_settings", {:force=>true})

   -> 0.0034s

-- add_index("inpatient_settings", ["applicant_id"], {:name=>"index_inpatient_settings_on_applicant_id"})

   -> 0.0021s

-- add_index("inpatient_settings", ["observation_hour_id"], {:name=>"index_inpatient_settings_on_observation_hour_id"})

   -> 0.0021s

-- create_table("institutions", {:force=>true})

   -> 0.0036s

-- create_table("interview_dates", {:force=>true})

   -> 0.0028s

-- add_index("interview_dates", ["interview_type_id"], {:name=>"index_interview_dates_on_interview_type_id"})

   -> 0.0019s

-- create_table("interview_locations", {:force=>true})

   -> 0.0024s

-- add_index("interview_locations", ["interview_type_id"], {:name=>"index_interview_locations_on_interview_type_id"})

   -> 0.0018s

-- create_table("interview_slots", {:force=>true})

   -> 0.0025s

-- add_index("interview_slots", ["interview_date_id"], {:name=>"index_interview_slots_on_interview_date_id"})

   -> 0.0020s

-- add_index("interview_slots", ["interview_time_id"], {:name=>"index_interview_slots_on_interview_time_id"})

   -> 0.0024s

-- add_index("interview_slots", ["interview_type_id"], {:name=>"index_interview_slots_on_interview_type_id"})

   -> 0.0026s

-- create_table("interview_slots_user_identities", {:id=>false, :force=>true})

   -> 0.0021s

-- create_table("interview_slots_users", {:id=>false, :force=>true})

   -> 0.0025s

-- add_index("interview_slots_users", ["interview_slot_id"], {:name=>"index_interview_slots_users_on_interview_slot_id"})

   -> 0.0028s

-- add_index("interview_slots_users", ["user_id"], {:name=>"index_interview_slots_users_on_user_id"})

   -> 0.0022s

-- create_table("interview_times", {:force=>true})

   -> 0.0034s

-- add_index("interview_times", ["interview_type_id"], {:name=>"index_interview_times_on_interview_type_id"})

   -> 0.0024s

-- create_table("known_cases", {:force=>true})

   -> 0.0030s

-- create_table("known_organizations", {:force=>true})

   -> 0.0026s

-- add_index("known_organizations", ["organization_id"], {:name=>"index_known_organizations_on_organization_id"})

   -> 0.0022s

-- add_index("known_organizations", ["source_id", "source_type"], {:name=>"index_known_organizations_on_source_id_and_source_type"})

   -> 0.0020s

-- add_index("known_organizations", ["user_id"], {:name=>"index_known_organizations_on_user_id"})

   -> 0.0020s

-- create_table("language_proficiencies", {:force=>true})

   -> 0.0029s

-- add_index("language_proficiencies", ["applicant_id"], {:name=>"index_language_proficiencies_on_applicant_id"})

   -> 0.0021s

-- add_index("language_proficiencies", ["identifier"], {:name=>"index_language_proficiencies_on_identifier"})

   -> 0.0021s

-- add_index("language_proficiencies", ["language_id"], {:name=>"index_language_proficiencies_on_language_id"})

   -> 0.0023s

-- add_index("language_proficiencies", ["language_proficiency_level_id"], {:name=>"index_language_proficiencies_on_language_proficiency_level_id"})

   -> 0.0021s

-- add_index("language_proficiencies", ["listening_proficiency_id"], {:name=>"index_language_proficiencies_on_listening_proficiency_id"})

   -> 0.0020s

-- add_index("language_proficiencies", ["reading_proficiency_id"], {:name=>"index_language_proficiencies_on_reading_proficiency_id"})

   -> 0.0027s

-- add_index("language_proficiencies", ["speaking_proficiency_id"], {:name=>"index_language_proficiencies_on_speaking_proficiency_id"})

   -> 0.0021s

-- add_index("language_proficiencies", ["writing_proficiency_id"], {:name=>"index_language_proficiencies_on_writing_proficiency_id"})

   -> 0.0021s

-- create_table("language_proficiency_levels", {:force=>true})

   -> 0.0031s

-- add_index("language_proficiency_levels", ["association_id", "identifier"], {:name=>"index_language_proficiency_levels_db172cd1dd"})

   -> 0.0023s

-- add_index("language_proficiency_levels", ["association_id"], {:name=>"index_language_proficiency_levels_on_association_id"})

   -> 0.0025s

-- add_index("language_proficiency_levels", ["identifier"], {:name=>"index_language_proficiency_levels_on_identifier"})

   -> 0.0026s

-- create_table("languages", {:force=>true})

   -> 0.0038s

-- add_index("languages", ["association_id", "identifier"], {:name=>"index_languages_on_association_id_and_identifier"})

   -> 0.0032s

-- add_index("languages", ["association_id"], {:name=>"index_languages_on_association_id"})

   -> 0.0027s

-- add_index("languages", ["identifier"], {:name=>"index_languages_on_identifier"})

   -> 0.0033s

-- create_table("licenses", {:force=>true})

   -> 0.0041s

-- add_index("licenses", ["applicant_id"], {:name=>"index_licenses_on_applicant_id"})

   -> 0.0027s

-- add_index("licenses", ["identifier"], {:name=>"index_licenses_on_identifier"})

   -> 0.0028s

-- add_index("licenses", ["narrow_field_type"], {:name=>"index_licenses_on_narrow_field_type"})

   -> 0.0022s

-- create_table("list_exclude", {:id=>false, :force=>true})

   -> 0.0024s

-- add_index("list_exclude", ["applicant_id"], {:name=>"index_list_exclude_on_applicant_id"})

   -> 0.0032s

-- add_index("list_exclude", ["list_id"], {:name=>"index_list_exclude_on_list_id"})

   -> 0.0023s

-- create_table("list_include", {:id=>false, :force=>true})

   -> 0.0021s

-- add_index("list_include", ["applicant_id"], {:name=>"index_list_include_on_applicant_id"})

   -> 0.0021s

-- add_index("list_include", ["list_id"], {:name=>"index_list_include_on_list_id"})

   -> 0.0021s

-- create_table("list_operators", {:force=>true})

   -> 0.0031s

-- create_table("list_statuses", {:force=>true})

   -> 0.0034s

-- add_index("list_statuses", ["list_id", "user_identity_id"], {:name=>"index_list_statuses_on_list_id_and_user_identity_id", :unique=>true})

   -> 0.0024s

-- create_table("list_user_settings", {:force=>true})

   -> 0.0036s

-- add_index("list_user_settings", ["list_id"], {:name=>"index_list_user_settings_on_list_id"})

   -> 0.0024s

-- add_index("list_user_settings", ["user_id"], {:name=>"index_list_user_settings_on_user_id"})

   -> 0.0025s

-- create_table("lists", {:force=>true})

   -> 0.0046s

-- add_index("lists", ["list_operator_id"], {:name=>"index_lists_on_list_operator_id"})

   -> 0.0027s

-- add_index("lists", ["organization_id"], {:name=>"index_lists_on_organization_id"})

   -> 0.0023s

-- add_index("lists", ["program_id"], {:name=>"index_lists_on_program_id"})

   -> 0.0030s

-- add_index("lists", ["type"], {:name=>"index_lists_on_type"})

   -> 0.0025s

-- add_index("lists", ["user_id"], {:name=>"index_lists_on_user_id"})

   -> 0.0025s

-- add_index("lists", ["user_identity_id"], {:name=>"index_lists_on_user_identity_id"})

   -> 0.0021s

-- add_index("lists", ["visibility"], {:name=>"index_lists_on_visibility"})

   -> 0.0030s

-- create_table("local_gpas", {:force=>true})

   -> 0.0041s

-- add_index("local_gpas", ["applicant_id", "gpa_template_id"], {:name=>"index_local_gpas_on_applicant_id_and_gpa_template_id", :unique=>true})

   -> 0.0026s

-- add_index("local_gpas", ["applicant_id"], {:name=>"index_local_gpas_on_applicant_id"})

   -> 0.0021s

-- add_index("local_gpas", ["gpa_template_id"], {:name=>"index_local_gpas_on_gpa_template_id"})

   -> 0.0022s

-- create_table("local_gpas_courses", {:force=>true})

   -> 0.0032s

-- add_index("local_gpas_courses", ["course_id", "local_gpa_id"], {:name=>"index_local_gpas_courses_on_course_id_and_local_gpa_id"})

   -> 0.0037s

-- add_index("local_gpas_courses", ["course_id"], {:name=>"index_local_gpas_courses_on_course_id"})

   -> 0.0023s

-- add_index("local_gpas_courses", ["local_gpa_id"], {:name=>"index_local_gpas_courses_on_local_gpa_id"})

   -> 0.0025s

-- create_table("local_statuses", {:force=>true})

   -> 0.0040s

-- add_index("local_statuses", ["color_map_id"], {:name=>"index_local_statuses_on_color_map_id"})

   -> 0.0025s

-- add_index("local_statuses", ["decision_id"], {:name=>"index_local_statuses_on_decision_id"})

   -> 0.0020s

-- add_index("local_statuses", ["email_template_id"], {:name=>"index_local_statuses_on_email_template_id"})

   -> 0.0025s

-- add_index("local_statuses", ["organization_id"], {:name=>"index_local_statuses_on_organization_id"})

   -> 0.0028s

-- create_table("local_statuses_programs", {:force=>true})

   -> 0.0033s

-- add_index("local_statuses_programs", ["local_status_id"], {:name=>"index_local_status_designations_on_local_status_id"})

   -> 0.0612s

-- add_index("local_statuses_programs", ["program_id"], {:name=>"index_local_status_designations_on_program_id"})

   -> 0.0027s

-- create_table("lookup_updates", {:force=>true})

   -> 0.0029s

-- add_index("lookup_updates", ["association_id"], {:name=>"index_lookup_updates_on_association_id"})

   -> 0.0022s

-- create_table("lookups", {:force=>true})

   -> 0.0031s

-- add_index("lookups", ["association_id", "identifier"], {:name=>"index_lookups_on_association_id_and_identifier"})

   -> 0.0024s

-- add_index("lookups", ["association_id"], {:name=>"index_lookups_on_association_id"})

   -> 0.0021s

-- add_index("lookups", ["identifier"], {:name=>"index_lookups_on_identifier"})

   -> 0.0020s

-- add_index("lookups", ["type"], {:name=>"index_lookups_on_type"})

   -> 0.0021s

-- create_table("mailings", {:force=>true})

   -> 0.0028s

-- add_index("mailings", ["association_id", "identifier"], {:name=>"index_mailings_on_association_id_and_identifier"})

   -> 0.0023s

-- add_index("mailings", ["association_id"], {:name=>"index_mailings_on_association_id"})

   -> 0.0020s

-- add_index("mailings", ["identifier"], {:name=>"index_mailings_on_identifier"})

   -> 0.0021s

-- add_index("mailings", ["mailing_number"], {:name=>"index_mailings_on_mailing_number"})

   -> 0.0020s

-- create_table("majors", {:force=>true})

   -> 0.0029s

-- add_index("majors", ["association_id", "identifier"], {:name=>"index_majors_on_association_id_and_identifier"})

   -> 0.0021s

-- add_index("majors", ["association_id"], {:name=>"index_majors_on_association_id"})

   -> 0.0020s

-- add_index("majors", ["identifier"], {:name=>"index_majors_on_identifier"})

   -> 0.0020s

-- create_table("master_colleges", {:force=>true})

   -> 0.0031s

-- create_table("master_secondary_schools", {:force=>true})

   -> 0.0034s

-- create_table("mean_personal_potential_index_scores", {:force=>true})

   -> 0.0029s

-- add_index("mean_personal_potential_index_scores", ["applicant_id"], {:name=>"index_mean_personal_potential_index_scores_on_applicant_id"})

   -> 0.0021s

-- add_index("mean_personal_potential_index_scores", ["identifier"], {:name=>"index_mean_personal_potential_index_scores_on_identifier"})

   -> 0.0021s

-- create_table("medical_trainings", {:force=>true})

   -> 0.0032s

-- add_index("medical_trainings", ["applicant_id"], {:name=>"index_medical_trainings_on_applicant_id"})

   -> 0.0022s

-- add_index("medical_trainings", ["identifier"], {:name=>"index_medical_trainings_on_identifier"})

   -> 0.0021s

-- add_index("medical_trainings", ["medical_training_type_id"], {:name=>"index_medical_trainings_on_medical_training_type_id"})

   -> 0.0022s

-- add_index("medical_trainings", ["type"], {:name=>"index_medical_trainings_on_type"})

   -> 0.0023s

-- create_table("military_statuses", {:force=>true})

   -> 0.0031s

-- add_index("military_statuses", ["association_id", "identifier"], {:name=>"index_military_statuses_on_association_id_and_identifier"})

   -> 0.0022s

-- add_index("military_statuses", ["association_id"], {:name=>"index_military_statuses_on_association_id"})

   -> 0.0020s

-- add_index("military_statuses", ["identifier"], {:name=>"index_military_statuses_on_identifier"})

   -> 0.0020s

-- create_table("notes", {:force=>true})

   -> 0.0031s

-- add_index("notes", ["owner_type", "owner_id"], {:name=>"index_notes_on_owner_type_and_owner_id"})

   -> 0.0022s

-- add_index("notes", ["user_id"], {:name=>"index_notes_on_user_id"})

   -> 0.0021s

-- create_table("notification_subscriptions", {:force=>true})

   -> 0.0029s

-- add_index("notification_subscriptions", ["user_identity_id", "notification_type"], {:name=>"index_notification_subscriptions_on_user_identity_id_and_type", :unique=>true})

   -> 0.0023s

-- create_table("numeric_conversions", {:force=>true})

   -> 0.0027s

-- create_table("observation_hours", {:force=>true})

   -> 0.0056s

-- add_index("observation_hours", ["applicant_id"], {:name=>"index_occupational_therapy_observation_hours_on_applicant_id"})

   -> 0.0022s

-- add_index("observation_hours", ["experience_pay_type_id"], {:name=>"index_occupational_therapy_observation_hours_fc05c4c6f0"})

   -> 0.0018s

-- add_index("observation_hours", ["identifier"], {:name=>"index_occupational_therapy_observation_hours_on_identifier"})

   -> 0.0022s

-- add_index("observation_hours", ["observation_type_id"], {:name=>"index_occupational_therapy_observation_hours_8b1118c87e"})

   -> 0.0025s

-- add_index("observation_hours", ["status_id"], {:name=>"index_occupational_therapy_observation_hours_on_status_id"})

   -> 0.0024s

-- create_table("observation_statuses", {:force=>true})

   -> 0.0030s

-- add_index("observation_statuses", ["association_id", "identifier"], {:name=>"index_observation_statuses_on_association_id_and_identifier"})

   -> 0.0023s

-- add_index("observation_statuses", ["association_id"], {:name=>"index_observation_statuses_on_association_id"})

   -> 0.0021s

-- add_index("observation_statuses", ["identifier"], {:name=>"index_observation_statuses_on_identifier"})

   -> 0.0021s

-- create_table("observation_types", {:force=>true})

   -> 0.0030s

-- add_index("observation_types", ["association_id", "identifier"], {:name=>"index_observation_types_on_association_id_and_identifier"})

   -> 0.0024s

-- add_index("observation_types", ["association_id"], {:name=>"index_observation_types_on_association_id"})

   -> 0.0025s

-- add_index("observation_types", ["identifier"], {:name=>"index_observation_types_on_identifier"})

   -> 0.0020s

-- create_table("occupations", {:force=>true})

   -> 0.0031s

-- add_index("occupations", ["association_id", "identifier"], {:name=>"index_occupations_on_association_id_and_identifier"})

   -> 0.0022s

-- add_index("occupations", ["association_id"], {:name=>"index_occupations_on_association_id"})

   -> 0.0021s

-- add_index("occupations", ["identifier"], {:name=>"index_occupations_on_identifier"})

   -> 0.0021s

-- add_index("occupations", ["type"], {:name=>"index_occupations_on_type"})

   -> 0.0022s

-- create_table("offer_types", {:force=>true})

   -> 0.0028s

-- create_table("official_ece_gpas", {:force=>true})

   -> 0.0035s

-- add_index("official_ece_gpas", ["applicant_id"], {:name=>"index_official_ece_gpas_on_applicant_id"})

   -> 0.0023s

-- add_index("official_ece_gpas", ["identifier"], {:name=>"index_official_ece_gpas_on_identifier"})

   -> 0.0026s

-- create_table("organization_evaluations", {:force=>true})

   -> 0.0032s

-- add_index("organization_evaluations", ["association_id"], {:name=>"index_organization_evaluations_on_association_id"})

   -> 0.0023s

-- add_index("organization_evaluations", ["evaluation_id"], {:name=>"index_organization_evaluations_on_evaluation_id"})

   -> 0.0021s

-- add_index("organization_evaluations", ["identifier"], {:name=>"index_organization_evaluations_on_identifier"})

   -> 0.0021s

-- add_index("organization_evaluations", ["organization_id"], {:name=>"index_organization_evaluations_on_organization_id"})

   -> 0.0021s

-- create_table("organization_resumes", {:force=>true})

   -> 0.0031s

-- add_index("organization_resumes", ["association_id"], {:name=>"index_organization_resumes_on_association_id"})

   -> 0.0023s

-- add_index("organization_resumes", ["identifier"], {:name=>"index_organization_resumes_on_identifier"})

   -> 0.0022s

-- add_index("organization_resumes", ["organization_id"], {:name=>"index_organization_resumes_on_organization_id"})

   -> 0.0022s

-- add_index("organization_resumes", ["resume_id"], {:name=>"index_organization_resumes_on_resume_id"})

   -> 0.0021s

-- create_table("organizations", {:force=>true})

   -> 0.0042s

-- add_index("organizations", ["association_id", "identifier"], {:name=>"index_organizations_on_association_id_and_identifier"})

   -> 0.0022s

-- add_index("organizations", ["association_id"], {:name=>"index_organizations_on_association_id"})

   -> 0.0027s

-- add_index("organizations", ["identifier"], {:name=>"index_organizations_on_identifier"})

   -> 0.0024s

-- add_index("organizations", ["institution_id", "association_id"], {:name=>"idx_organizations_on_institution_id_association_id"})

   -> 0.0026s

-- add_index("organizations", ["institution_id"], {:name=>"index_organizations_on_institution_id"})

   -> 0.0025s

-- add_index("organizations", ["temp_identifier"], {:name=>"index_organizations_on_association_org_identifier", :unique=>true})

   -> 0.0022s

-- add_index("organizations", ["unique_identifier", "identifier"], {:name=>"index_organizations_on_unique_identifier_and_identifier", :unique=>true})

   -> 0.0024s

-- create_table("other_applications", {:force=>true})

   -> 0.0034s

-- add_index("other_applications", ["applicant_id"], {:name=>"index_other_applications_on_applicant_id"})

   -> 0.0025s

-- create_table("outpatient_settings", {:force=>true})

   -> 0.0047s

-- add_index("outpatient_settings", ["observation_hour_id"], {:name=>"index_outpatient_settings_on_observation_hour_id"})

   -> 0.0025s

-- create_table("pages", {:force=>true})

   -> 0.0032s

-- add_index("pages", ["association_id"], {:name=>"index_pages_on_association_id"})

   -> 0.0022s

-- create_table("parent_educations", {:force=>true})

   -> 0.0034s

-- add_index("parent_educations", ["association_id", "identifier"], {:name=>"index_parent_educations_on_association_id_and_identifier"})

   -> 0.0024s

-- add_index("parent_educations", ["association_id"], {:name=>"index_parent_educations_on_association_id"})

   -> 0.0020s

-- add_index("parent_educations", ["identifier"], {:name=>"index_parent_educations_on_identifier"})

   -> 0.0021s

-- create_table("parent_statuses", {:force=>true})

   -> 0.0034s

-- add_index("parent_statuses", ["association_id", "identifier"], {:name=>"index_parent_statuses_on_association_id_and_identifier"})

   -> 0.0024s

-- add_index("parent_statuses", ["association_id"], {:name=>"index_parent_statuses_on_association_id"})

   -> 0.0022s

-- add_index("parent_statuses", ["identifier"], {:name=>"index_parent_statuses_on_identifier"})

   -> 0.0022s

-- create_table("parents", {:force=>true})

   -> 0.0038s

-- add_index("parents", ["applicant_id"], {:name=>"index_parents_on_applicant_id"})

   -> 0.0022s

-- add_index("parents", ["education_id"], {:name=>"index_parents_on_education_id"})

   -> 0.0021s

-- add_index("parents", ["identifier"], {:name=>"index_parents_on_identifier"})

   -> 0.0022s

-- add_index("parents", ["occupation_id"], {:name=>"index_parents_on_occupation_id"})

   -> 0.0022s

-- add_index("parents", ["parent_status_id"], {:name=>"index_parents_on_parent_status_id"})

   -> 0.0021s

-- add_index("parents", ["relationship_id"], {:name=>"index_parents_on_relationship_id"})

   -> 0.0022s

-- create_table("pdf_manager_batches", {:force=>true})

   -> 0.0036s

-- add_index("pdf_manager_batches", ["pdf_manager_template_id", "user_identity_id"], {:name=>"index_pdf_manager_batches_pdf_manager_template_user_identity", :unique=>true})

   -> 0.0024s

-- create_table("pdf_manager_template_subpanels", {:force=>true})

   -> 0.0028s

-- create_table("pdf_manager_templates", {:force=>true})

   -> 0.0033s

-- add_index("pdf_manager_templates", ["static_list_id"], {:name=>"index_pdf_manager_templates_on_static_list_id"})

   -> 0.0026s

-- add_index("pdf_manager_templates", ["user_identity_id"], {:name=>"index_pdf_manager_templates_on_user_identity_id"})

   -> 0.0023s

-- create_table("pdf_manager_zip_files", {:force=>true})

   -> 0.0028s

-- add_index("pdf_manager_zip_files", ["pdf_manager_batch_id"], {:name=>"index_pdf_manager_zip_files_on_pdf_manager_batch_id"})

   -> 0.0024s

-- create_table("personal_potential_indices", {:force=>true})

   -> 0.0041s

-- add_index("personal_potential_indices", ["applicant_id"], {:name=>"index_personal_potential_indices_on_applicant_id"})

   -> 0.0023s

-- add_index("personal_potential_indices", ["identifier"], {:name=>"index_personal_potential_indices_on_identifier"})

   -> 0.0022s

-- add_index("personal_potential_indices", ["ppi_evaluator_id"], {:name=>"index_personal_potential_indices_on_ppi_evaluator_id"})

   -> 0.0023s

-- create_table("photo_programs", {:force=>true})

   -> 0.0028s

-- add_index("photo_programs", ["photo_id", "program_id"], {:name=>"index_photo_programs_on_photo_id_and_program_id"})

   -> 0.0025s

-- add_index("photo_programs", ["photo_id"], {:name=>"index_photo_programs_on_photo_id"})

   -> 0.0021s

-- add_index("photo_programs", ["program_id"], {:name=>"index_photo_programs_on_program_id"})

   -> 0.0023s

-- create_table("photos", {:force=>true})

   -> 0.0033s

-- add_index("photos", ["applicant_id"], {:name=>"index_photos_on_applicant_id"})

   -> 0.0022s

-- create_table("postgraduate_levels", {:force=>true})

   -> 0.0032s

-- add_index("postgraduate_levels", ["association_id"], {:name=>"index_postgraduate_levels_on_association_id"})

   -> 0.0025s

-- create_table("postgraduate_programs", {:force=>true})

   -> 0.0035s

-- add_index("postgraduate_programs", ["applicant_id"], {:name=>"index_postgraduate_programs_on_applicant_id"})

   -> 0.0023s

-- add_index("postgraduate_programs", ["degree_id"], {:name=>"index_postgraduate_programs_on_degree_id"})

   -> 0.0022s

-- add_index("postgraduate_programs", ["identifier"], {:name=>"index_postgraduate_programs_on_identifier"})

   -> 0.0023s

-- add_index("postgraduate_programs", ["postgraduate_level_id"], {:name=>"index_postgraduate_programs_on_postgraduate_level_id"})

   -> 0.0021s

-- add_index("postgraduate_programs", ["postgraduate_type_id"], {:name=>"index_postgraduate_programs_on_postgraduate_type_id"})

   -> 0.0026s

-- create_table("postgraduate_types", {:force=>true})

   -> 0.0035s

-- add_index("postgraduate_types", ["association_id", "identifier"], {:name=>"index_postgraduate_types_on_association_id_and_identifier"})

   -> 0.0023s

-- add_index("postgraduate_types", ["association_id"], {:name=>"index_postgraduate_types_on_association_id"})

   -> 0.0020s

-- add_index("postgraduate_types", ["identifier"], {:name=>"index_postgraduate_types_on_identifier"})

   -> 0.0021s

-- create_table("preferred_names", {:force=>true})

   -> 0.0036s

-- add_index("preferred_names", ["applicant_id"], {:name=>"index_preferred_names_on_applicant_id"})

   -> 0.0024s

-- create_table("presentations", {:force=>true})

   -> 0.0032s

-- add_index("presentations", ["applicant_id"], {:name=>"index_presentations_on_applicant_id"})

   -> 0.0022s

-- create_table("previous_application_years", {:force=>true})

   -> 0.0033s

-- add_index("previous_application_years", ["applicant_id"], {:name=>"index_previous_application_years_on_applicant_id"})

   -> 0.0024s

-- add_index("previous_application_years", ["designation_id"], {:name=>"index_previous_application_years_on_designation_id"})

   -> 0.0022s

-- create_table("previous_matriculations", {:force=>true})

   -> 0.0038s

-- create_table("previously_attended_health_professions", {:force=>true})

   -> 0.0041s

-- add_index("previously_attended_health_professions", ["applicant_id"], {:name=>"index_previously_attended_health_professions_on_applicant_id"})

   -> 0.0023s

-- create_table("professional_references", {:force=>true})

   -> 0.0034s

-- add_index("professional_references", ["applicant_id"], {:name=>"index_professional_references_on_applicant_id"})

   -> 0.0024s

-- create_table("program_deliveries", {:force=>true})

   -> 0.0032s

-- create_table("program_requirements", {:force=>true})

   -> 0.0027s

-- add_index("program_requirements", ["program_id", "requirement_id"], {:name=>"index_program_requirements_on_program_id_and_requirement_id"})

   -> 0.0026s

-- add_index("program_requirements", ["program_id"], {:name=>"index_program_requirements_on_program_id"})

   -> 0.0022s

-- add_index("program_requirements", ["requirement_id", "requirement_type"], {:name=>"program_requirements_polymorphic_idx"})

   -> 0.0030s

-- add_index("program_requirements", ["requirement_id"], {:name=>"index_program_requirements_on_requirement_id"})

   -> 0.0025s

-- create_table("program_tracks", {:force=>true})

   -> 0.0040s

-- create_table("program_types", {:force=>true})

   -> 0.0035s

-- create_table("programs", {:force=>true})

   -> 0.0053s

-- add_index("programs", ["association_id"], {:name=>"index_programs_on_association_id"})

   -> 0.0025s

-- add_index("programs", ["degree_id"], {:name=>"index_programs_on_degree_id"})

   -> 0.0020s

-- add_index("programs", ["identifier", "association_id"], {:name=>"index_programs_on_identifier_and_association_id"})

   -> 0.0025s

-- add_index("programs", ["identifier"], {:name=>"index_programs_on_identifier"})

   -> 0.0021s

-- add_index("programs", ["level_id"], {:name=>"index_programs_on_level_id"})

   -> 0.0026s

-- add_index("programs", ["organization_id"], {:name=>"index_programs_on_organization_id"})

   -> 0.0022s

-- add_index("programs", ["type"], {:name=>"index_programs_on_type"})

   -> 0.0027s

-- add_index("programs", ["unique_identifier"], {:name=>"index_programs_on_unique_identifier", :unique=>true})

   -> 0.0022s

-- create_table("programs_users", {:force=>true})

   -> 0.0026s

-- add_index("programs_users", ["program_id", "user_id"], {:name=>"index_programs_users_on_program_id_and_user_id"})

   -> 0.0022s

-- add_index("programs_users", ["program_id"], {:name=>"index_programs_users_on_program_id"})

   -> 0.0020s

-- add_index("programs_users", ["user_id"], {:name=>"index_programs_users_on_user_id"})

   -> 0.0023s

-- create_table("publications", {:force=>true})

   -> 0.0036s

-- add_index("publications", ["applicant_id"], {:name=>"index_publications_on_applicant_id"})

   -> 0.0022s

-- add_index("publications", ["identifier"], {:name=>"index_publications_on_identifier"})

   -> 0.0020s

-- create_table("question_bases", {:force=>true})

   -> 0.0034s

-- add_index("question_bases", ["custom_field_type_id"], {:name=>"index_custom_fields_on_custom_field_type_id"})

   -> 0.0021s

-- add_index("question_bases", ["owner_id"], {:name=>"index_custom_fields_on_owner_id"})

   -> 0.0020s

-- add_index("question_bases", ["owner_type", "owner_id"], {:name=>"index_question_bases_on_owner_type_and_owner_id"})

   -> 0.0024s

-- add_index("question_bases", ["owner_type"], {:name=>"index_question_bases_on_owner_type"})

   -> 0.0019s

-- add_index("question_bases", ["question_identifier"], {:name=>"index_question_bases_on_question_identifier"})

   -> 0.0025s

-- add_index("question_bases", ["supplemental_field_type_id"], {:name=>"index_question_bases_on_supplemental_field_type_id"})

   -> 0.0025s

-- add_index("question_bases", ["supplemental_question_block_id"], {:name=>"index_question_bases_on_supplemental_question_block_id"})

   -> 0.0018s

-- add_index("question_bases", ["type"], {:name=>"index_question_bases_on_type"})

   -> 0.0020s

-- create_table("registrations", {:force=>true})

   -> 0.0030s

-- add_index("registrations", ["applicant_id"], {:name=>"index_registrations_on_applicant_id"})

   -> 0.0026s

-- add_index("registrations", ["identifier"], {:name=>"index_registrations_on_identifier"})

   -> 0.0021s

-- create_table("relations", {:force=>true})

   -> 0.0029s

-- add_index("relations", ["association_id", "identifier"], {:name=>"index_relations_on_association_id_and_identifier"})

   -> 0.0024s

-- add_index("relations", ["association_id"], {:name=>"index_relations_on_association_id"})

   -> 0.0023s

-- add_index("relations", ["identifier"], {:name=>"index_relations_on_identifier"})

   -> 0.0020s

-- create_table("remarks", {:force=>true})

   -> 0.0032s

-- add_index("remarks", ["assignment_type_base_id"], {:name=>"index_remarks_on_assignment_type_base_id"})

   -> 0.0022s

-- create_table("report_comparison_organizations", {:force=>true})

   -> 0.0032s

-- add_index("report_comparison_organizations", ["organization_id"], {:name=>"index_report_comparison_organizations_on_organization_id"})

   -> 0.0025s

-- add_index("report_comparison_organizations", ["report_id"], {:name=>"index_report_comparison_organizations_on_report_id"})

   -> 0.0022s

-- create_table("report_decisions", {:force=>true})

   -> 0.0030s

-- add_index("report_decisions", ["decision_id"], {:name=>"index_report_decisions_on_decision_id"})

   -> 0.0024s

-- add_index("report_decisions", ["report_id"], {:name=>"index_report_decisions_on_report_id"})

   -> 0.0020s

-- create_table("requirements", {:force=>true})

   -> 0.0036s

-- add_index("requirements", ["id", "type"], {:name=>"index_requirements_on_id_and_type"})

   -> 0.0023s

-- add_index("requirements", ["organization_id"], {:name=>"index_requirements_on_organization_id"})

   -> 0.0021s

-- add_index("requirements", ["type"], {:name=>"index_requirements_on_type"})

   -> 0.0021s

-- create_table("research_hours", {:force=>true})

   -> 0.0028s

-- add_index("research_hours", ["applicant_id"], {:name=>"index_research_hours_on_applicant_id"})

   -> 0.0025s

-- create_table("resumes", {:force=>true})

   -> 0.0031s

-- add_index("resumes", ["applicant_id"], {:name=>"index_resumes_on_applicant_id"})

   -> 0.0022s

-- add_index("resumes", ["identifier"], {:name=>"index_resumes_on_identifier"})

   -> 0.0021s

-- create_table("revisions", {:force=>true})

   -> 0.0029s

-- add_index("revisions", ["applicant_id", "date", "field_category_id"], {:name=>"index_revisions_on_applicant_id_and_date_and_field_category_id"})

   -> 0.0025s

-- add_index("revisions", ["applicant_id"], {:name=>"index_revisions_on_applicant_id"})

   -> 0.0020s

-- add_index("revisions", ["date"], {:name=>"index_revisions_on_date"})

   -> 0.0020s

-- add_index("revisions", ["field_category_id"], {:name=>"index_revisions_on_field_category_id"})

   -> 0.0023s

-- create_table("right_assignments", {:force=>true})

   -> 0.0029s

-- add_index("right_assignments", ["right_id"], {:name=>"index_right_assignments_on_right_id"})

   -> 0.0021s

-- add_index("right_assignments", ["role_id", "right_id"], {:name=>"index_right_assignments_on_role_id_and_right_id", :unique=>true})

   -> 0.0022s

-- add_index("right_assignments", ["role_id"], {:name=>"index_right_assignments_on_role_id"})

   -> 0.0022s

-- create_table("rights", {:force=>true})

   -> 0.0032s

-- add_index("rights", ["feature_id"], {:name=>"index_rights_on_feature_id"})

   -> 0.0022s

-- create_table("roles", {:force=>true})

   -> 0.0034s

-- create_table("scaffold_courses", {:force=>true})

   -> 0.0037s

-- add_index("scaffold_courses", ["applicant_identifier"], {:name=>"index_scaffold_courses_on_applicant_identifier"})

   -> 0.0025s

-- create_table("score_runs", {:force=>true})

   -> 0.0032s

-- create_table("scoring_model_assignments", {:force=>true})

   -> 0.0027s

-- add_index("scoring_model_assignments", ["program_id"], {:name=>"index_scoring_model_assignments_on_program_id"})

   -> 0.0030s

-- add_index("scoring_model_assignments", ["scoring_model_id"], {:name=>"index_scoring_model_assignments_on_scoring_model_id"})

   -> 0.0023s

-- create_table("scoring_model_components", {:force=>true})

   -> 0.0030s

-- add_index("scoring_model_components", ["field_id"], {:name=>"index_scoring_model_components_on_field_id"})

   -> 0.0024s

-- add_index("scoring_model_components", ["point_table_id"], {:name=>"index_scoring_model_components_on_point_table_id"})

   -> 0.0021s

-- add_index("scoring_model_components", ["scoring_model_id"], {:name=>"index_scoring_model_components_on_scoring_model_id"})

   -> 0.0022s

-- create_table("scoring_models", {:force=>true})

   -> 0.0032s

-- add_index("scoring_models", ["organization_id"], {:name=>"index_scoring_models_on_organization_id"})

   -> 0.0022s

-- create_table("scoring_point_table_entries", {:force=>true})

   -> 0.0027s

-- add_index("scoring_point_table_entries", ["point_table_id"], {:name=>"index_scoring_point_table_entries_on_point_table_id"})

   -> 0.0022s

-- create_table("scoring_point_table_entry_numbers", {:force=>true})

   -> 0.0026s

-- add_index("scoring_point_table_entry_numbers", ["point_table_entry_id"], {:name=>"index_scoring_point_table_entry_numbers_on_point_table_entry_id"})

   -> 0.0025s

-- create_table("scoring_point_table_entry_ranges", {:force=>true})

   -> 0.0029s

-- add_index("scoring_point_table_entry_ranges", ["point_table_entry_id"], {:name=>"index_scoring_point_table_entry_ranges_on_point_table_entry_id"})

   -> 0.0024s

-- create_table("scoring_point_table_entry_strings", {:force=>true})

   -> 0.0028s

-- add_index("scoring_point_table_entry_strings", ["point_table_entry_id"], {:name=>"index_scoring_point_table_entry_strings_on_point_table_entry_id"})

   -> 0.0025s

-- create_table("scoring_point_table_types", {:force=>true})

   -> 0.0032s

-- create_table("scoring_point_tables", {:force=>true})

   -> 0.0037s

-- add_index("scoring_point_tables", ["organization_id"], {:name=>"index_scoring_point_tables_on_organization_id"})

   -> 0.0028s

-- add_index("scoring_point_tables", ["scoring_point_table_type_id"], {:name=>"index_scoring_point_tables_on_scoring_point_table_type_id"})

   -> 0.0023s

-- create_table("secondary_school_courses", {:force=>true})

   -> 0.0041s

-- add_index("secondary_school_courses", ["applicant_id"], {:name=>"index_secondary_school_courses_on_applicant_id"})

   -> 0.0024s

-- add_index("secondary_school_courses", ["association_id"], {:name=>"index_secondary_school_courses_on_association_id"})

   -> 0.0022s

-- add_index("secondary_school_courses", ["secondary_school_grade_level_id"], {:name=>"ssc_secondary_school_grade_level_id"})

   -> 0.0023s

-- add_index("secondary_school_courses", ["secondary_school_id"], {:name=>"index_secondary_school_courses_on_secondary_school_id"})

   -> 0.0022s

-- add_index("secondary_school_courses", ["secondary_school_subject_id"], {:name=>"index_secondary_school_courses_on_subject_id"})

   -> 0.0022s

-- create_table("secondary_school_details", {:force=>true})

   -> 0.0036s

-- create_table("secondary_school_grade_levels", {:force=>true})

   -> 0.0035s

-- add_index("secondary_school_grade_levels", ["applicant_id"], {:name=>"index_secondary_school_grade_levels_on_applicant_id"})

   -> 0.0025s

-- add_index("secondary_school_grade_levels", ["association_id"], {:name=>"index_secondary_school_grade_levels_on_association_id"})

   -> 0.0023s

-- add_index("secondary_school_grade_levels", ["secondary_school_id"], {:name=>"index_secondary_school_grade_levels_on_secondary_school_id"})

   -> 0.0024s

-- create_table("secondary_school_subjects", {:force=>true})

   -> 0.0036s

-- add_index("secondary_school_subjects", ["association_id"], {:name=>"index_secondary_school_subjects_on_association_id"})

   -> 0.0026s

-- add_index("secondary_school_subjects", ["identifier"], {:name=>"index_secondary_school_subjects_on_identifier", :unique=>true})

   -> 0.0024s

-- create_table("secondary_schools", {:force=>true})

   -> 0.0045s

-- add_index("secondary_schools", ["applicant_id"], {:name=>"index_secondary_schools_on_applicant_id"})

   -> 0.0031s

-- add_index("secondary_schools", ["identifier"], {:name=>"index_secondary_schools_on_identifier"})

   -> 0.0024s

-- create_table("secondary_subject_summaries", {:force=>true})

   -> 0.0034s

-- add_index("secondary_subject_summaries", ["applicant_id"], {:name=>"index_secondary_subject_summaries_on_applicant_id"})

   -> 0.0025s

-- add_index("secondary_subject_summaries", ["secondary_school_subject_id"], {:name=>"index_ss_summaries_on_ss_subject_id"})

   -> 0.0025s

-- create_table("settings_transfer_details", {:force=>true})

   -> 0.0035s

-- add_index("settings_transfer_details", ["organization_id"], {:name=>"index_settings_transfers_on_organization_id", :unique=>true})

   -> 0.0024s

-- create_table("siblings", {:force=>true})

   -> 0.0029s

-- add_index("siblings", ["applicant_id"], {:name=>"index_siblings_on_applicant_id"})

   -> 0.0024s

-- create_table("splashes", {:force=>true})

   -> 0.0034s

-- create_table("states", {:force=>true})

   -> 0.0034s

-- create_table("statuses", {:force=>true})

   -> 0.0036s

-- add_index("statuses", ["association_id", "identifier"], {:name=>"index_statuses_on_association_id_and_identifier"})

   -> 0.0030s

-- add_index("statuses", ["association_id"], {:name=>"index_statuses_on_association_id"})

   -> 0.0024s

-- add_index("statuses", ["identifier"], {:name=>"index_statuses_on_identifier"})

   -> 0.0020s

-- add_index("statuses", ["show"], {:name=>"index_statuses_on_show"})

   -> 0.0019s

-- add_index("statuses", ["title"], {:name=>"index_statuses_on_title"})

   -> 0.0021s

-- add_index("statuses", ["type", "identifier"], {:name=>"index_statuses_on_type_and_identifier"})

   -> 0.0021s

-- add_index("statuses", ["type"], {:name=>"index_statuses_on_type"})

   -> 0.0023s

-- create_table("student_statuses", {:force=>true})

   -> 0.0033s

-- add_index("student_statuses", ["association_id", "identifier"], {:name=>"index_student_statuses_on_association_id_and_identifier"})

   -> 0.0022s

-- add_index("student_statuses", ["association_id"], {:name=>"index_student_statuses_on_association_id"})

   -> 0.0023s

-- add_index("student_statuses", ["identifier"], {:name=>"index_student_statuses_on_identifier"})

   -> 0.0021s

-- create_table("subjects", {:force=>true})

   -> 0.0034s

-- add_index("subjects", ["association_id", "identifier"], {:name=>"index_subjects_on_association_id_and_identifier"})

   -> 0.0022s

-- add_index("subjects", ["association_id"], {:name=>"index_subjects_on_association_id"})

   -> 0.0019s

-- add_index("subjects", ["identifier"], {:name=>"index_subjects_on_identifier"})

   -> 0.0020s

-- add_index("subjects", ["option_set_id"], {:name=>"index_subjects_on_option_set_id"})

   -> 0.0020s

-- create_table("subpanel_assignments", {:force=>true})

   -> 0.0028s

-- create_table("subpanels", {:force=>true})

   -> 0.0031s

-- create_table("supplemental_lookups", {:force=>true})

   -> 0.0031s

-- add_index("supplemental_lookups", ["association_id", "identifier"], {:name=>"index_supplemental_lookups_on_association_id_and_identifier"})

   -> 0.0022s

-- add_index("supplemental_lookups", ["association_id"], {:name=>"index_supplemental_lookups_on_association_id"})

   -> 0.0026s

-- add_index("supplemental_lookups", ["identifier"], {:name=>"index_supplemental_lookups_on_identifier"})

   -> 0.0027s

-- add_index("supplemental_lookups", ["type"], {:name=>"index_supplemental_lookups_on_type"})

   -> 0.0027s

-- create_table("supplemental_question_blocks", {:force=>true})

   -> 0.0036s

-- add_index("supplemental_question_blocks", ["identifier"], {:name=>"index_supplemental_question_blocks_on_identifier"})

   -> 0.0023s

-- create_table("term_types", {:force=>true})

   -> 0.0031s

-- add_index("term_types", ["association_id", "identifier"], {:name=>"index_term_types_on_association_id_and_identifier"})

   -> 0.0029s

-- add_index("term_types", ["association_id"], {:name=>"index_term_types_on_association_id"})

   -> 0.0027s

-- add_index("term_types", ["identifier"], {:name=>"index_term_types_on_identifier"})

   -> 0.0022s

-- create_table("terms", {:force=>true})

   -> 0.0029s

-- add_index("terms", ["association_id", "identifier"], {:name=>"index_terms_on_association_id_and_identifier"})

   -> 0.0026s

-- add_index("terms", ["association_id"], {:name=>"index_terms_on_association_id"})

   -> 0.0022s

-- add_index("terms", ["identifier"], {:name=>"index_terms_on_identifier"})

   -> 0.0023s

-- create_table("test_receipts", {:force=>true})

   -> 0.0029s

-- add_index("test_receipts", ["organization_id"], {:name=>"index_tests_official_result_receiveds_on_organization_id"})

   -> 0.0023s

-- add_index("test_receipts", ["test_id"], {:name=>"index_tests_official_result_receiveds_on_test_id"})

   -> 0.0021s

-- create_table("test_receivers", {:force=>true})

   -> 0.0029s

-- add_index("test_receivers", ["applicant_id"], {:name=>"index_test_receivers_on_applicant_id"})

   -> 0.0022s

-- add_index("test_receivers", ["association_id", "identifier"], {:name=>"index_test_receivers_on_association_id_and_identifier"})

   -> 0.0024s

-- add_index("test_receivers", ["organization_id", "test_id"], {:name=>"index_test_receivers_on_organization_id_and_test_id"})

   -> 0.0022s

-- add_index("test_receivers", ["organization_id"], {:name=>"index_test_receivers_on_organization_id"})

   -> 0.0021s

-- add_index("test_receivers", ["test_id"], {:name=>"index_test_receivers_on_test_id"})

   -> 0.0021s

-- create_table("test_scores_accuplacer", {:force=>true})

   -> 0.0031s

-- add_index("test_scores_accuplacer", ["applicant_id"], {:name=>"index_test_scores_accuplacer_on_applicant_id"})

   -> 0.0022s

-- add_index("test_scores_accuplacer", ["test_id"], {:name=>"index_test_scores_accuplacer_on_test_id"})

   -> 0.0026s

-- create_table("test_scores_act", {:force=>true})

   -> 0.0033s

-- add_index("test_scores_act", ["applicant_id"], {:name=>"index_test_scores_act_on_applicant_id"})

   -> 0.0025s

-- add_index("test_scores_act", ["test_id"], {:name=>"index_test_scores_act_on_test_id"})

   -> 0.0020s

-- create_table("test_scores_act_after_sept_2015", {:force=>true})

   -> 0.0031s

-- add_index("test_scores_act_after_sept_2015", ["applicant_id"], {:name=>"index_test_scores_act_after_sept_2015_on_applicant_id"})

   -> 0.0021s

-- add_index("test_scores_act_after_sept_2015", ["test_id"], {:name=>"index_test_scores_act_after_sept_2015_on_test_id"})

   -> 0.0022s

-- create_table("test_scores_act_official_after_sept_2015", {:force=>true})

   -> 0.0033s

-- add_index("test_scores_act_official_after_sept_2015", ["applicant_id"], {:name=>"index_test_scores_act_official_after_sept_2015_on_applicant_id"})

   -> 0.0024s

-- add_index("test_scores_act_official_after_sept_2015", ["test_id"], {:name=>"index_test_scores_act_official_after_sept_2015_on_test_id"})

   -> 0.0027s

-- create_table("test_scores_act_official_before_sept_2015", {:force=>true})

   -> 0.0042s

-- add_index("test_scores_act_official_before_sept_2015", ["applicant_id"], {:name=>"idx_test_scores_act_official_before_sept_2015_on_applicant_id"})

   -> 0.0036s

-- add_index("test_scores_act_official_before_sept_2015", ["test_id"], {:name=>"index_test_scores_act_official_before_sept_2015_on_test_id"})

   -> 0.0025s

-- create_table("test_scores_adat_official", {:force=>true})

   -> 0.0034s

-- add_index("test_scores_adat_official", ["applicant_id"], {:name=>"index_test_scores_adat_official_on_applicant_id"})

   -> 0.0023s

-- add_index("test_scores_adat_official", ["test_id"], {:name=>"index_test_scores_adat_official_on_test_id"})

   -> 0.0023s

-- create_table("test_scores_ap", {:force=>true})

   -> 0.0035s

-- add_index("test_scores_ap", ["applicant_id"], {:name=>"index_test_scores_ap_on_applicant_id"})

   -> 0.0021s

-- add_index("test_scores_ap", ["test_id"], {:name=>"index_test_scores_ap_on_test_id"})

   -> 0.0020s

-- create_table("test_scores_canadian_dat", {:force=>true})

   -> 0.0033s

-- add_index("test_scores_canadian_dat", ["applicant_id"], {:name=>"index_test_scores_canadian_dat_on_applicant_id"})

   -> 0.0027s

-- add_index("test_scores_canadian_dat", ["test_id"], {:name=>"index_test_scores_canadian_dat_on_test_id"})

   -> 0.0022s

-- create_table("test_scores_clep", {:force=>true})

   -> 0.0030s

-- add_index("test_scores_clep", ["applicant_id"], {:name=>"index_test_scores_clep_on_applicant_id"})

   -> 0.0029s

-- create_table("test_scores_dat", {:force=>true})

   -> 0.0037s

-- add_index("test_scores_dat", ["applicant_id"], {:name=>"index_test_scores_dat_on_applicant_id"})

   -> 0.0022s

-- add_index("test_scores_dat", ["test_id"], {:name=>"index_test_scores_dat_on_test_id"})

   -> 0.0020s

-- create_table("test_scores_dat_official", {:force=>true})

   -> 0.0030s

-- add_index("test_scores_dat_official", ["applicant_id"], {:name=>"index_test_scores_dat_official_on_applicant_id"})

   -> 0.0022s

-- add_index("test_scores_dat_official", ["test_id"], {:name=>"index_test_scores_dat_official_on_test_id"})

   -> 0.0021s

-- create_table("test_scores_exadep", {:force=>true})

   -> 0.0033s

-- add_index("test_scores_exadep", ["applicant_id"], {:name=>"index_test_scores_exadep_on_applicant_id"})

   -> 0.0029s

-- add_index("test_scores_exadep", ["test_id"], {:name=>"index_test_scores_exadep_on_test_id"})

   -> 0.0021s

-- create_table("test_scores_gce", {:force=>true})

   -> 0.0029s

-- add_index("test_scores_gce", ["applicant_id"], {:name=>"index_test_scores_gce_on_applicant_id"})

   -> 0.0024s

-- create_table("test_scores_gmat", {:force=>true})

   -> 0.0032s

-- add_index("test_scores_gmat", ["applicant_id"], {:name=>"index_test_scores_gmat_on_applicant_id"})

   -> 0.0025s

-- add_index("test_scores_gmat", ["test_id"], {:name=>"index_test_scores_gmat_on_test_id"})

   -> 0.0021s

-- create_table("test_scores_gmat_official", {:force=>true})

   -> 0.0037s

-- add_index("test_scores_gmat_official", ["applicant_id"], {:name=>"index_test_scores_gmat_official_on_applicant_id"})

   -> 0.0026s

-- add_index("test_scores_gmat_official", ["test_id"], {:name=>"index_test_scores_gmat_official_on_test_id"})

   -> 0.0023s

-- create_table("test_scores_gre2", {:force=>true})

   -> 0.0034s

-- add_index("test_scores_gre2", ["applicant_id"], {:name=>"index_test_scores_gre2_on_applicant_id"})

   -> 0.0023s

-- add_index("test_scores_gre2", ["organization_id"], {:name=>"index_test_scores_gre2_on_organization_id"})

   -> 0.0022s

-- add_index("test_scores_gre2", ["score_1_type_id"], {:name=>"index_test_scores_gre2_on_score_1_type_id"})

   -> 0.0021s

-- add_index("test_scores_gre2", ["score_2_type_id"], {:name=>"index_test_scores_gre2_on_score_2_type_id"})

   -> 0.0021s

-- add_index("test_scores_gre2", ["score_3_type_id"], {:name=>"index_test_scores_gre2_on_score_3_type_id"})

   -> 0.0023s

-- add_index("test_scores_gre2", ["score_4_type_id"], {:name=>"index_test_scores_gre2_on_score_4_type_id"})

   -> 0.0022s

-- add_index("test_scores_gre2", ["test_id"], {:name=>"index_test_scores_gre2_on_test_id"})

   -> 0.0022s

-- add_index("test_scores_gre2", ["type_id"], {:name=>"index_test_scores_gre2_on_type_id"})

   -> 0.0023s

-- create_table("test_scores_gre_general", {:force=>true})

   -> 0.0032s

-- add_index("test_scores_gre_general", ["applicant_id"], {:name=>"index_test_scores_gre_general_on_applicant_id"})

   -> 0.0026s

-- add_index("test_scores_gre_general", ["test_id"], {:name=>"index_test_scores_gre_general_on_test_id"})

   -> 0.0027s

-- create_table("test_scores_gre_general_official", {:force=>true})

   -> 0.0037s

-- add_index("test_scores_gre_general_official", ["applicant_id"], {:name=>"index_test_scores_gre_general_official_on_applicant_id"})

   -> 0.0027s

-- add_index("test_scores_gre_general_official", ["test_id"], {:name=>"index_test_scores_gre_general_official_on_test_id"})

   -> 0.0024s

-- create_table("test_scores_gre_subject", {:force=>true})

   -> 0.0031s

-- add_index("test_scores_gre_subject", ["applicant_id"], {:name=>"index_test_scores_gre_subject_on_applicant_id"})

   -> 0.0024s

-- add_index("test_scores_gre_subject", ["test_id"], {:name=>"index_test_scores_gre_subject_on_test_id"})

   -> 0.0022s

-- add_index("test_scores_gre_subject", ["type_id"], {:name=>"index_test_scores_gre_subject_on_type_id"})

   -> 0.0022s

-- create_table("test_scores_gre_subject_official", {:force=>true})

   -> 0.0043s

-- add_index("test_scores_gre_subject_official", ["applicant_id"], {:name=>"index_test_scores_gre_subject_official_on_applicant_id"})

   -> 0.0026s

-- add_index("test_scores_gre_subject_official", ["test_id"], {:name=>"index_test_scores_gre_subject_official_on_test_id"})

   -> 0.0025s

-- add_index("test_scores_gre_subject_official", ["type_id"], {:name=>"index_test_scores_gre_subject_official_on_type_id"})

   -> 0.0023s

-- create_table("test_scores_hesi", {:force=>true})

   -> 0.0038s

-- add_index("test_scores_hesi", ["applicant_id"], {:name=>"index_test_scores_hesi_on_applicant_id"})

   -> 0.0028s

-- add_index("test_scores_hesi", ["test_id"], {:name=>"index_test_scores_hesi_on_test_id"})

   -> 0.0025s

-- create_table("test_scores_hobet", {:force=>true})

   -> 0.0034s

-- add_index("test_scores_hobet", ["applicant_id"], {:name=>"index_test_scores_hobet_on_applicant_id"})

   -> 0.0029s

-- add_index("test_scores_hobet", ["test_id"], {:name=>"index_test_scores_hobet_on_test_id"})

   -> 0.0028s

-- create_table("test_scores_hrst", {:force=>true})

   -> 0.0035s

-- add_index("test_scores_hrst", ["applicant_id"], {:name=>"index_test_scores_hrst_on_applicant_id"})

   -> 0.0033s

-- add_index("test_scores_hrst", ["test_id"], {:name=>"index_test_scores_hrst_on_test_id"})

   -> 0.0024s

-- create_table("test_scores_ielts", {:force=>true})

   -> 0.0041s

-- add_index("test_scores_ielts", ["applicant_id"], {:name=>"index_test_scores_ielts_on_applicant_id"})

   -> 0.0028s

-- add_index("test_scores_ielts", ["test_id"], {:name=>"index_test_scores_ielts_on_test_id"})

   -> 0.0024s

-- create_table("test_scores_ielts_official", {:force=>true})

   -> 0.0033s

-- add_index("test_scores_ielts_official", ["applicant_id"], {:name=>"index_test_scores_ielts_official_on_applicant_id"})

   -> 0.0024s

-- add_index("test_scores_ielts_official", ["test_id"], {:name=>"index_test_scores_ielts_official_on_test_id"})

   -> 0.0023s

-- create_table("test_scores_lsat", {:force=>true})

   -> 0.0030s

-- add_index("test_scores_lsat", ["applicant_id"], {:name=>"index_test_scores_lsat_on_applicant_id"})

   -> 0.0027s

-- add_index("test_scores_lsat", ["test_id"], {:name=>"index_test_scores_lsat_on_test_id"})

   -> 0.0026s

-- create_table("test_scores_mat", {:force=>true})

   -> 0.0030s

-- add_index("test_scores_mat", ["applicant_id"], {:name=>"index_test_scores_mat_on_applicant_id"})

   -> 0.0032s

-- add_index("test_scores_mat", ["test_id"], {:name=>"index_test_scores_mat_on_test_id"})

   -> 0.0022s

-- create_table("test_scores_mcat", {:force=>true})

   -> 0.0059s

-- add_index("test_scores_mcat", ["applicant_id"], {:name=>"index_test_scores_mcat_on_applicant_id"})

   -> 0.0026s

-- add_index("test_scores_mcat", ["test_id"], {:name=>"index_test_scores_mcat_on_test_id"})

   -> 0.0026s

-- create_table("test_scores_mcat_after_jan_31_2015", {:force=>true})

   -> 0.0035s

-- add_index("test_scores_mcat_after_jan_31_2015", ["applicant_id"], {:name=>"index_test_scores_mcat_after_jan_31_2015_on_applicant_id"})

   -> 0.0025s

-- add_index("test_scores_mcat_after_jan_31_2015", ["test_id"], {:name=>"index_test_scores_mcat_after_jan_31_2015_on_test_id"})

   -> 0.0024s

-- create_table("test_scores_mcat_official", {:force=>true})

   -> 0.0043s

-- add_index("test_scores_mcat_official", ["applicant_id"], {:name=>"index_test_scores_mcat_official_on_applicant_id"})

   -> 0.0025s

-- add_index("test_scores_mcat_official", ["received_on"], {:name=>"index_test_scores_mcat_official_on_received_on"})

   -> 0.0024s

-- add_index("test_scores_mcat_official", ["test_id"], {:name=>"index_test_scores_mcat_official_on_test_id"})

   -> 0.0025s

-- create_table("test_scores_mcat_official_after_jan_31_2015", {:force=>true})

   -> 0.0040s

-- add_index("test_scores_mcat_official_after_jan_31_2015", ["applicant_id"], {:name=>"idx_test_scores_mcat_official_after_jan_31_2015_on_applicant_id"})

   -> 0.0026s

-- add_index("test_scores_mcat_official_after_jan_31_2015", ["test_id"], {:name=>"index_test_scores_mcat_official_after_jan_31_2015_on_test_id"})

   -> 0.0024s

-- create_table("test_scores_melab", {:force=>true})

   -> 0.0030s

-- add_index("test_scores_melab", ["applicant_id"], {:name=>"index_test_scores_melab_on_applicant_id"})

   -> 0.0024s

-- add_index("test_scores_melab", ["test_id"], {:name=>"index_test_scores_melab_on_test_id"})

   -> 0.0024s

-- create_table("test_scores_nbde_1_2007", {:force=>true})

   -> 0.0029s

-- add_index("test_scores_nbde_1_2007", ["applicant_id"], {:name=>"index_test_scores_nbde_1_2007_on_applicant_id"})

   -> 0.0027s

-- add_index("test_scores_nbde_1_2007", ["result_id"], {:name=>"index_test_scores_nbde_1_2007_on_result_id"})

   -> 0.0024s

-- add_index("test_scores_nbde_1_2007", ["test_id"], {:name=>"index_test_scores_nbde_1_2007_on_test_id"})

   -> 0.0023s

-- create_table("test_scores_nbde_1_2012", {:force=>true})

   -> 0.0029s

-- add_index("test_scores_nbde_1_2012", ["applicant_id"], {:name=>"index_test_scores_nbde_1_2012_on_applicant_id"})

   -> 0.0025s

-- add_index("test_scores_nbde_1_2012", ["result_id"], {:name=>"index_test_scores_nbde_1_2012_on_result_id"})

   -> 0.0023s

-- add_index("test_scores_nbde_1_2012", ["test_id"], {:name=>"index_test_scores_nbde_1_2012_on_test_id"})

   -> 0.0027s

-- create_table("test_scores_nbde_1_pre2007", {:force=>true})

   -> 0.0034s

-- add_index("test_scores_nbde_1_pre2007", ["applicant_id"], {:name=>"index_test_scores_nbde_1_pre2007_on_applicant_id"})

   -> 0.0025s

-- add_index("test_scores_nbde_1_pre2007", ["result_id"], {:name=>"index_test_scores_nbde_1_pre2007_on_result_id"})

   -> 0.0022s

-- add_index("test_scores_nbde_1_pre2007", ["test_id"], {:name=>"index_test_scores_nbde_1_pre2007_on_test_id"})

   -> 0.0024s

-- create_table("test_scores_nbde_2_2012", {:force=>true})

   -> 0.0031s

-- add_index("test_scores_nbde_2_2012", ["applicant_id"], {:name=>"index_test_scores_nbde_2_2012_on_applicant_id"})

   -> 0.0022s

-- add_index("test_scores_nbde_2_2012", ["result_id"], {:name=>"index_test_scores_nbde_2_2012_on_result_id"})

   -> 0.0022s

-- add_index("test_scores_nbde_2_2012", ["test_id"], {:name=>"index_test_scores_nbde_2_2012_on_test_id"})

   -> 0.0022s

-- create_table("test_scores_nbde_2_pre2012", {:force=>true})

   -> 0.0032s

-- add_index("test_scores_nbde_2_pre2012", ["applicant_id"], {:name=>"index_test_scores_nbde_2_pre2012_on_applicant_id"})

   -> 0.0027s

-- add_index("test_scores_nbde_2_pre2012", ["result_id"], {:name=>"index_test_scores_nbde_2_pre2012_on_result_id"})

   -> 0.0022s

-- add_index("test_scores_nbde_2_pre2012", ["test_id"], {:name=>"index_test_scores_nbde_2_pre2012_on_test_id"})

   -> 0.0023s

-- create_table("test_scores_nelson_denny", {:force=>true})

   -> 0.0031s

-- add_index("test_scores_nelson_denny", ["applicant_id"], {:name=>"index_test_scores_nelson_denny_on_applicant_id"})

   -> 0.0024s

-- add_index("test_scores_nelson_denny", ["test_id"], {:name=>"index_test_scores_nelson_denny_on_test_id"})

   -> 0.0027s

-- create_table("test_scores_nln", {:force=>true})

   -> 0.0035s

-- add_index("test_scores_nln", ["applicant_id"], {:name=>"index_test_scores_nln_on_applicant_id"})

   -> 0.0029s

-- add_index("test_scores_nln", ["test_id"], {:name=>"index_test_scores_nln_on_test_id"})

   -> 0.0023s

-- create_table("test_scores_oat", {:force=>true})

   -> 0.0033s

-- add_index("test_scores_oat", ["applicant_id"], {:name=>"index_test_scores_oat_on_applicant_id"})

   -> 0.0023s

-- add_index("test_scores_oat", ["test_id"], {:name=>"index_test_scores_oat_on_test_id"})

   -> 0.0023s

-- create_table("test_scores_oat_official", {:force=>true})

   -> 0.0033s

-- add_index("test_scores_oat_official", ["applicant_id"], {:name=>"index_test_scores_oat_official_on_applicant_id"})

   -> 0.0026s

-- add_index("test_scores_oat_official", ["test_id"], {:name=>"index_test_scores_oat_official_on_test_id"})

   -> 0.0039s

-- create_table("test_scores_other", {:force=>true})

   -> 0.0034s

-- add_index("test_scores_other", ["applicant_id"], {:name=>"index_test_scores_other_on_applicant_id"})

   -> 0.0023s

-- add_index("test_scores_other", ["test_id"], {:name=>"index_test_scores_other_on_test_id"})

   -> 0.0021s

-- create_table("test_scores_pcat", {:force=>true})

   -> 0.0035s

-- add_index("test_scores_pcat", ["applicant_id"], {:name=>"index_test_scores_pcat_on_applicant_id"})

   -> 0.0024s

-- add_index("test_scores_pcat", ["test_id"], {:name=>"index_test_scores_pcat_on_test_id"})

   -> 0.0024s

-- create_table("test_scores_pcat_official", {:force=>true})

   -> 0.0039s

-- add_index("test_scores_pcat_official", ["applicant_id"], {:name=>"index_test_scores_pcat_official_on_applicant_id"})

   -> 0.0028s

-- add_index("test_scores_pcat_official", ["test_id"], {:name=>"index_test_scores_pcat_official_on_test_id"})

   -> 0.0028s

-- create_table("test_scores_pte", {:force=>true})

   -> 0.0038s

-- add_index("test_scores_pte", ["applicant_id"], {:name=>"index_test_scores_pte_on_applicant_id"})

   -> 0.0028s

-- add_index("test_scores_pte", ["test_id"], {:name=>"index_test_scores_pte_on_test_id"})

   -> 0.0026s

-- create_table("test_scores_pte_official", {:force=>true})

   -> 0.0148s

-- add_index("test_scores_pte_official", ["applicant_id"], {:name=>"index_test_scores_pte_official_on_applicant_id"})

   -> 0.0031s

-- add_index("test_scores_pte_official", ["test_id"], {:name=>"index_test_scores_pte_official_on_test_id"})

   -> 0.0028s

-- create_table("test_scores_sat", {:force=>true})

   -> 0.0036s

-- add_index("test_scores_sat", ["applicant_id"], {:name=>"index_test_scores_sat_on_applicant_id"})

   -> 0.0027s

-- add_index("test_scores_sat", ["test_id"], {:name=>"index_test_scores_sat_on_test_id"})

   -> 0.0024s

-- create_table("test_scores_sat_after_march_2016", {:force=>true})

   -> 0.0038s

-- add_index("test_scores_sat_after_march_2016", ["applicant_id"], {:name=>"index_test_scores_sat_after_march_2016_on_applicant_id"})

   -> 0.0027s

-- add_index("test_scores_sat_after_march_2016", ["test_id"], {:name=>"index_test_scores_sat_after_march_2016_on_test_id"})

   -> 0.0027s

-- create_table("test_scores_sat_official_after_march_2016", {:force=>true})

   -> 0.0044s

-- add_index("test_scores_sat_official_after_march_2016", ["applicant_id"], {:name=>"idx_test_scores_sat_official_after_march_2016_on_applicant_id"})

   -> 0.0035s

-- add_index("test_scores_sat_official_after_march_2016", ["test_id"], {:name=>"index_test_scores_sat_official_after_march_2016_on_test_id"})

   -> 0.0030s

-- create_table("test_scores_sat_official_before_march_2016", {:force=>true})

   -> 0.0046s

-- add_index("test_scores_sat_official_before_march_2016", ["applicant_id"], {:name=>"idx_test_scores_sat_official_before_march_2016_on_applicant_id"})

   -> 0.0033s

-- add_index("test_scores_sat_official_before_march_2016", ["test_id"], {:name=>"index_test_scores_sat_official_before_march_2016_on_test_id"})

   -> 0.0030s

-- create_table("test_scores_teas", {:force=>true})

   -> 0.0044s

-- add_index("test_scores_teas", ["applicant_id"], {:name=>"index_test_scores_teas_on_applicant_id"})

   -> 0.0039s

-- add_index("test_scores_teas", ["test_id"], {:name=>"index_test_scores_teas_on_test_id"})

   -> 0.0032s

-- create_table("test_scores_toefl", {:force=>true})

   -> 0.0042s

-- add_index("test_scores_toefl", ["applicant_id"], {:name=>"index_test_scores_toefl_on_applicant_id"})

   -> 0.0031s

-- add_index("test_scores_toefl", ["test_id"], {:name=>"index_test_scores_toefl_on_test_id"})

   -> 0.0029s

-- add_index("test_scores_toefl", ["type_id"], {:name=>"index_test_scores_toefl_on_type_id"})

   -> 0.0029s

-- create_table("test_scores_toefl_official", {:force=>true})

   -> 0.0040s

-- add_index("test_scores_toefl_official", ["applicant_id"], {:name=>"index_test_scores_toefl_official_on_applicant_id"})

   -> 0.0028s

-- add_index("test_scores_toefl_official", ["test_id"], {:name=>"index_test_scores_toefl_official_on_test_id"})

   -> 0.0025s

-- add_index("test_scores_toefl_official", ["type_id"], {:name=>"index_test_scores_toefl_official_on_type_id"})

   -> 0.0025s

-- create_table("tests", {:force=>true})

   -> 0.0045s

-- add_index("tests", ["applicant_id"], {:name=>"index_tests_on_applicant_id"})

   -> 0.0043s

-- add_index("tests", ["identifier"], {:name=>"index_tests_on_identifier"})

   -> 0.0028s

-- add_index("tests", ["status_id"], {:name=>"index_tests_on_status_id"})

   -> 0.0026s

-- add_index("tests", ["type"], {:name=>"index_tests_on_type"})

   -> 0.0027s

-- create_table("trainings", {:force=>true})

   -> 0.0049s

-- add_index("trainings", ["applicant_id"], {:name=>"index_trainings_on_applicant_id"})

   -> 0.0034s

-- add_index("trainings", ["identifier"], {:name=>"index_trainings_on_identifier"})

   -> 0.0031s

-- create_table("transcripts", {:force=>true})

   -> 0.0047s

-- add_index("transcripts", ["applicant_id"], {:name=>"index_transcripts_on_applicant_id"})

   -> 0.0034s

-- add_index("transcripts", ["association_id", "identifier"], {:name=>"index_transcripts_on_association_id_and_identifier"})

   -> 0.0036s

-- add_index("transcripts", ["association_id"], {:name=>"index_transcripts_on_association_id"})

   -> 0.0031s

-- add_index("transcripts", ["college_attended_id"], {:name=>"index_transcripts_on_college_attended_id"})

   -> 0.0036s

-- add_index("transcripts", ["college_id"], {:name=>"index_transcripts_on_college_id"})

   -> 0.0039s

-- add_index("transcripts", ["identifier"], {:name=>"index_transcripts_on_identifier"})

   -> 0.0031s

-- create_table("transformations", {:force=>true})

   -> 0.0036s

-- create_table("user_identities", {:force=>true})

   -> 0.0047s

-- add_index("user_identities", ["active"], {:name=>"index_user_identities_on_active"})

   -> 0.0036s

-- add_index("user_identities", ["user_id"], {:name=>"index_user_identities_on_user_id"})

   -> 0.0036s

-- create_table("user_identity_cases", {:force=>true})

   -> 0.0036s

-- add_index("user_identity_cases", ["association_id"], {:name=>"index_user_identity_cases_on_association_id"})

   -> 0.0026s

-- add_index("user_identity_cases", ["user_identity_id", "association_id"], {:name=>"index_user_identity_cases_on_user_identity_id_and_assoc_id"})

   -> 0.0038s

-- create_table("user_identity_colleges", {:force=>true})

   -> 0.0038s

-- create_table("user_identity_institutions", {:force=>true})

   -> 0.0035s

-- add_index("user_identity_institutions", ["institution_id"], {:name=>"index_user_identity_institutions_on_institution_id"})

   -> 0.0026s

-- add_index("user_identity_institutions", ["user_identity_id"], {:name=>"index_user_identity_institutions_on_user_identity_id"})

   -> 0.0026s

-- create_table("user_identity_organizations", {:force=>true})

   -> 0.0032s

-- add_index("user_identity_organizations", ["organization_id"], {:name=>"index_user_identity_organizations_on_organization_id"})

   -> 0.0036s

-- add_index("user_identity_organizations", ["user_identity_id", "organization_id"], {:name=>"index_user_identity_organization_on_user_identity_id_and_org_id"})

   -> 0.0029s

-- create_table("user_identity_programs", {:force=>true})

   -> 0.0033s

-- add_index("user_identity_programs", ["program_id"], {:name=>"index_user_identity_programs_on_program_id"})

   -> 0.0030s

-- add_index("user_identity_programs", ["user_identity_id", "program_id"], {:name=>"index_user_identity_programs_on_user_identity_id_and_program_id"})

   -> 0.0026s

-- create_table("user_identity_roles", {:force=>true})

   -> 0.0033s

-- add_index("user_identity_roles", ["user_identity_id"], {:name=>"index_user_identity_roles_on_user_identity_id"})

   -> 0.0034s

-- create_table("user_roles", {:force=>true})

   -> 0.0035s

-- add_index("user_roles", ["role_id"], {:name=>"index_user_roles_on_role_id"})

   -> 0.0030s

-- add_index("user_roles", ["user_id"], {:name=>"index_user_roles_on_user_id"})

   -> 0.0032s

-- create_table("users", {:force=>true})

   -> 0.0059s

-- add_index("users", ["association_id"], {:name=>"index_users_on_association_id"})

   -> 0.0035s

-- add_index("users", ["clipboard_id"], {:name=>"index_users_on_clipboard_id"})

   -> 0.0032s

-- add_index("users", ["email"], {:name=>"index_users_on_email"})

   -> 0.0026s

-- add_index("users", ["last_splash_id"], {:name=>"index_users_on_last_splash_id"})

   -> 0.0026s

-- add_index("users", ["organization_id"], {:name=>"index_users_on_organization_id"})

   -> 0.0029s

-- add_index("users", ["type"], {:name=>"index_users_on_type"})

   -> 0.0026s

-- create_table("view_report_files", {:force=>true})

   -> 0.0040s

-- add_index("view_report_files", ["view_report_key", "user_identity_id"], {:name=>"index_view_report_files_on_view_report_key_and_user_identity_id", :unique=>true})

   -> 0.0032s

-- create_table("visa_types", {:force=>true})

   -> 0.0042s

-- add_index("visa_types", ["association_id", "identifier"], {:name=>"index_visa_types_on_association_id_and_identifier"})

   -> 0.0034s

-- add_index("visa_types", ["association_id"], {:name=>"index_visa_types_on_association_id"})

   -> 0.0033s

-- add_index("visa_types", ["identifier"], {:name=>"index_visa_types_on_identifier"})

   -> 0.0031s

-- add_index("visa_types", ["type"], {:name=>"index_visa_types_on_type"})

   -> 0.0025s

-- create_table("wes_gpas", {:force=>true})

   -> 0.0034s

-- add_index("wes_gpas", ["applicant_id"], {:name=>"index_wes_gpas_on_applicant_id"})

   -> 0.0025s

-- add_index("wes_gpas", ["identifier"], {:name=>"index_wes_gpas_on_identifier"})

   -> 0.0027s

-- add_index("wes_gpas", ["type"], {:name=>"index_wes_gpas_on_type"})

   -> 0.0039s

-- add_foreign_key("about_mes", "applicants", {:name=>"about_mes_applicant_id_fk", :dependent=>:delete})

   -> 0.0043s

-- add_foreign_key("about_mes", "lookups", {:name=>"about_mes_csu_recent_college_id_fk", :column=>"csu_recent_college_id"})

   -> 0.0024s

-- add_foreign_key("about_mes", "lookups", {:name=>"about_mes_entry_status_id_fk", :column=>"entry_status_id"})

   -> 0.0017s

-- add_foreign_key("about_mes", "lookups", {:name=>"about_mes_us_veteran_status_id_fk", :column=>"us_veteran_status_id"})

   -> 0.0018s

-- add_foreign_key("additional_mcat_intent_indicators", "applicants", {:name=>"additional_mcat_intent_indicators_applicant_id_fk", :dependent=>:delete})

   -> 0.0019s

-- add_foreign_key("advisor_request_associations", "advisor_requests", {:name=>"advisor_request_associations_advisor_request_id_fk"})

   -> 0.0023s

-- add_foreign_key("advisor_request_associations", "associations", {:name=>"advisor_request_associations_association_id_fk"})

   -> 0.0044s

-- add_foreign_key("advisor_requests", "college_bases", {:name=>"advisor_requests_college_id_fk", :column=>"college_id"})

   -> 0.0038s

-- add_foreign_key("advisor_requests", "master_colleges", {:name=>"advisor_requests_master_college_id_fk"})

   -> 0.0033s

-- add_foreign_key("advisor_requests", "states", {:name=>"advisor_requests_state_id_fk", :dependent=>:nullify})

   -> 0.0041s

-- add_foreign_key("advisor_requests", "users", {:name=>"advisor_requests_user_id_fk"})

   -> 0.0045s

-- add_foreign_key("alternate_campuses", "applicants", {:name=>"alternate_campuses_applicant_id_fk"})

   -> 0.0038s

-- add_foreign_key("alternate_campuses", "organizations", {:name=>"alternate_campuses_organization_id_fk"})

   -> 0.0034s

-- add_foreign_key("applicant_college_details_warehouse", "counties", {:name=>"applicant_college_details_warehouse_county_id_fk"})

   -> 0.0072s

-- add_foreign_key("applicant_college_details_warehouse", "global_lookups", {:name=>"applicant_college_details_warehouse_county_med_underserved_id_f", :column=>"county_med_underserved_id"})

   -> 0.0057s

-- add_foreign_key("applicant_college_details_warehouse", "global_lookups", {:name=>"applicant_college_details_warehouse_county_urban_rural_id_fk", :column=>"county_urban_rural_id"})

   -> 0.0050s

-- add_foreign_key("applicant_ethnicities", "lookups", {:name=>"applicant_ethnicities_lookup_id_fk"})

   -> 0.0036s

-- add_foreign_key("applicant_gateway_activities", "applicants", {:name=>"applicant_gateway_activities_applicant_id_fk"})

   -> 0.0027s

-- add_foreign_key("applicant_gateway_activities", "programs", {:name=>"applicant_gateway_activities_program_id_fk"})

   -> 0.0049s

-- add_foreign_key("applicant_gateway_activity_configurations", "applicant_gateway_activity_types", {:name=>"activity_configurations_types_fk", :column=>"activity_type_id"})

   -> 0.0050s

-- add_foreign_key("applicant_gateway_activity_configurations", "programs", {:name=>"applicant_gateway_activity_configurations_program_id_fk", :dependent=>:delete})

   -> 0.0030s

-- add_foreign_key("applicant_gateway_fees", "applicant_gateway_activities", {:name=>"supplemental_application_fee_activity_fk", :dependent=>:delete})

   -> 0.0031s

-- add_foreign_key("applicant_gateway_fees", "applicants", {:name=>"applicant_gateway_supplemental_application_fees_applicant_id_fk", :dependent=>:delete})

   -> 0.0047s

-- add_foreign_key("applicant_majors", "college_attendeds", {:name=>"applicant_majors_college_attended_id_fk"})

   -> 0.0064s

-- add_foreign_key("applicant_minors", "college_attendeds", {:name=>"applicant_minors_college_attended_id_fk"})

   -> 0.0060s

-- add_foreign_key("applicant_preferred_genders", "applicants", {:name=>"applicant_preferred_genders_applicant_id_fk"})

   -> 0.0032s

-- add_foreign_key("applicant_preferred_genders", "lookups", {:name=>"applicant_preferred_genders_gender_behavior_id_fk", :column=>"gender_behavior_id"})

   -> 0.0025s

-- add_foreign_key("applicant_preferred_genders", "lookups", {:name=>"applicant_preferred_genders_gender_identity_id_fk", :column=>"gender_identity_id"})

   -> 0.0024s

-- add_foreign_key("applicant_preferred_genders", "lookups", {:name=>"applicant_preferred_genders_sexual_orientation_id_fk", :column=>"sexual_orientation_id"})

   -> 0.0031s

-- add_foreign_key("college_attendeds", "counties", {:name=>"college_attendeds_county_id_fk"})

   -> 0.0034s

-- add_foreign_key("college_attendeds", "global_lookups", {:name=>"college_attendeds_county_med_underserved_id_fk", :column=>"county_med_underserved_id"})

   -> 0.0024s

-- add_foreign_key("college_attendeds", "global_lookups", {:name=>"college_attendeds_county_urban_rural_id_fk", :column=>"county_urban_rural_id"})

   -> 0.0023s

-- add_foreign_key("details", "lookups", {:name=>"details_military_status_extended_id_fk", :column=>"military_status_extended_id"})

   -> 0.0051s

-- add_foreign_key("evaluation_summaries", "applicants", {:name=>"evaluation_summaries_applicant_id_fk", :dependent=>:delete})

   -> 0.0041s

-- add_foreign_key("general_education_courses", "applicants", {:name=>"general_education_courses_applicant_id_fk"})

   -> 0.0041s

-- add_foreign_key("guardians", "counties", {:name=>"guardians_mailing_county_id_fk", :column=>"mailing_county_id"})

   -> 0.0036s

-- add_foreign_key("guardians", "countries", {:name=>"guardians_first_prior_country_id_fk", :column=>"first_prior_country_id"})

   -> 0.0040s

-- add_foreign_key("guardians", "countries", {:name=>"guardians_mailing_country_id_fk", :column=>"mailing_country_id"})

   -> 0.0024s

-- add_foreign_key("guardians", "countries", {:name=>"guardians_second_prior_country_id_fk", :column=>"second_prior_country_id"})

   -> 0.0040s

-- add_foreign_key("guardians", "lookups", {:name=>"guardians_csu_education_id_fk", :column=>"csu_education_id"})

   -> 0.0041s

-- add_foreign_key("guardians", "states", {:name=>"guardians_first_prior_state_id_fk", :column=>"first_prior_state_id"})

   -> 0.0025s

-- add_foreign_key("guardians", "states", {:name=>"guardians_mailing_state_id_fk", :column=>"mailing_state_id"})

   -> 0.0023s

-- add_foreign_key("guardians", "states", {:name=>"guardians_second_prior_state_id_fk", :column=>"second_prior_state_id"})

   -> 0.0030s

-- add_foreign_key("pdf_manager_batches", "pdf_manager_templates", {:name=>"pdf_manager_batches_pdf_manager_template_id_fk", :dependent=>:delete})

   -> 0.0033s

-- add_foreign_key("pdf_manager_batches", "user_identities", {:name=>"pdf_manager_batches_user_identity_id_fk", :dependent=>:delete})

   -> 0.0037s

-- add_foreign_key("pdf_manager_template_subpanels", "pdf_manager_templates", {:name=>"pdf_manager_template_subpanels_pdf_manager_template_id_fk", :dependent=>:delete})

   -> 0.0035s

-- add_foreign_key("pdf_manager_template_subpanels", "subpanels", {:name=>"pdf_manager_template_subpanels_subpanel_id_fk", :dependent=>:delete})

   -> 0.0029s

-- add_foreign_key("pdf_manager_templates", "document_sources", {:name=>"pdf_manager_templates_document_source_id_fk"})

   -> 0.0030s

-- add_foreign_key("pdf_manager_templates", "user_identities", {:name=>"pdf_manager_templates_user_identity_id_fk"})

   -> 0.0025s

-- add_foreign_key("pdf_manager_zip_files", "pdf_manager_batches", {:name=>"pdf_manager_zip_files_pdf_manager_batch_id_fk", :dependent=>:delete})

   -> 0.0056s

-- add_foreign_key("previous_matriculations", "applicants", {:name=>"previous_matriculations_applicant_id_fk"})

   -> 0.0045s

-- add_foreign_key("research_hours", "applicants", {:name=>"research_hours_applicant_id_fk", :dependent=>:delete})

   -> 0.0037s

-- add_foreign_key("secondary_school_courses", "applicants", {:name=>"secondary_school_courses_applicant_id_fk"})

   -> 0.0035s

-- add_foreign_key("secondary_school_courses", "associations", {:name=>"secondary_school_courses_association_id_fk"})

   -> 0.0022s

-- add_foreign_key("secondary_school_courses", "global_lookups", {:name=>"secondary_school_courses_secondary_school_course_classification", :column=>"secondary_school_course_classification_id"})

   -> 0.0024s

-- add_foreign_key("secondary_school_courses", "global_lookups", {:name=>"secondary_school_courses_secondary_school_course_selection_id_f", :column=>"secondary_school_course_selection_id"})

   -> 0.0020s

-- add_foreign_key("secondary_school_courses", "global_lookups", {:name=>"secondary_school_courses_secondary_school_term_type_id_fk", :column=>"secondary_school_term_type_id"})

   -> 0.0022s

-- add_foreign_key("secondary_school_courses", "secondary_school_grade_levels", {:name=>"secondary_school_courses_secondary_school_grade_level_id_fk", :dependent=>:delete})

   -> 0.0029s

-- add_foreign_key("secondary_school_grade_levels", "applicants", {:name=>"secondary_school_grade_levels_applicant_id_fk"})

   -> 0.0023s

-- add_foreign_key("secondary_school_grade_levels", "associations", {:name=>"secondary_school_grade_levels_association_id_fk"})

   -> 0.0024s

-- add_foreign_key("secondary_school_grade_levels", "global_lookups", {:name=>"secondary_school_grade_levels_grade_level_id_fk", :column=>"grade_level_id"})

   -> 0.0017s

-- add_foreign_key("secondary_school_grade_levels", "secondary_schools", {:name=>"secondary_school_grade_levels_secondary_school_id_fk"})

   -> 0.0023s

-- add_foreign_key("secondary_schools", "master_secondary_schools", {:name=>"secondary_schools_master_secondary_school_id_fk"})

   -> 0.0020s

-- add_foreign_key("settings_transfer_details", "organizations", {:name=>"settings_transfers_organization_id_fk"})

   -> 0.0022s

-- add_foreign_key("subpanel_assignments", "associations", {:name=>"subpanel_assignments_association_id_fk", :dependent=>:delete})

   -> 0.0024s

-- add_foreign_key("subpanel_assignments", "subpanels", {:name=>"subpanel_assignments_subpanel_id_fk", :dependent=>:delete})

   -> 0.0022s

-- add_foreign_key("subpanels", "field_categories", {:name=>"subpanels_field_category_id_fk"})

   -> 0.0019s

-- add_foreign_key("test_scores_act_after_sept_2015", "applicants", {:name=>"test_scores_act_after_sept_2015_applicant_id_fk"})

   -> 0.0023s

-- add_foreign_key("test_scores_act_after_sept_2015", "lookups", {:name=>"test_scores_act_after_sept_2015_status_id_fk", :column=>"status_id"})

   -> 0.0018s

-- add_foreign_key("test_scores_act_after_sept_2015", "tests", {:name=>"test_scores_act_after_sept_2015_test_id_fk"})

   -> 0.0020s

-- add_foreign_key("test_scores_act_official_after_sept_2015", "applicants", {:name=>"test_scores_act_official_after_sept_2015_applicant_id_fk"})

   -> 0.0024s

-- add_foreign_key("test_scores_act_official_after_sept_2015", "tests", {:name=>"test_scores_act_official_after_sept_2015_test_id_fk"})

   -> 0.0020s

-- add_foreign_key("test_scores_act_official_before_sept_2015", "applicants", {:name=>"test_scores_act_official_before_sept_2015_applicant_id_fk"})

   -> 0.0027s

-- add_foreign_key("test_scores_act_official_before_sept_2015", "tests", {:name=>"test_scores_act_official_before_sept_2015_test_id_fk"})

   -> 0.0020s

-- add_foreign_key("test_scores_gmat_official", "tests", {:name=>"test_scores_gmat_official_test_id_fk", :dependent=>:delete})

   -> 0.0021s

-- add_foreign_key("test_scores_oat_official", "applicants", {:name=>"test_scores_oat_official_applicant_id_fk"})

   -> 0.0024s

-- add_foreign_key("test_scores_oat_official", "tests", {:name=>"test_scores_oat_official_test_id_fk"})

   -> 0.0018s

-- add_foreign_key("test_scores_pte", "applicants", {:name=>"test_scores_pte_applicant_id_fk"})

   -> 0.0022s

-- add_foreign_key("test_scores_pte", "lookups", {:name=>"test_scores_pte_status_id_fk", :column=>"status_id"})

   -> 0.0023s

-- add_foreign_key("test_scores_pte", "tests", {:name=>"test_scores_pte_test_id_fk"})

   -> 0.0022s

-- add_foreign_key("test_scores_pte_official", "applicants", {:name=>"test_scores_pte_official_applicant_id_fk"})

   -> 0.0031s

-- add_foreign_key("test_scores_pte_official", "tests", {:name=>"test_scores_pte_official_test_id_fk"})

   -> 0.0028s

-- add_foreign_key("test_scores_sat_after_march_2016", "applicants", {:name=>"test_scores_sat_after_march_2016_applicant_id_fk"})

   -> 0.0030s

-- add_foreign_key("test_scores_sat_after_march_2016", "lookups", {:name=>"test_scores_sat_after_march_2016_status_id_fk", :column=>"status_id"})

   -> 0.0021s

-- add_foreign_key("test_scores_sat_after_march_2016", "tests", {:name=>"test_scores_sat_after_march_2016_test_id_fk"})

   -> 0.0023s

-- add_foreign_key("test_scores_sat_official_after_march_2016", "applicants", {:name=>"test_scores_sat_official_after_march_2016_applicant_id_fk"})

   -> 0.0039s

-- add_foreign_key("test_scores_sat_official_after_march_2016", "tests", {:name=>"test_scores_sat_official_after_march_2016_test_id_fk"})

   -> 0.0036s

-- add_foreign_key("test_scores_sat_official_before_march_2016", "applicants", {:name=>"test_scores_sat_official_before_march_2016_applicant_id_fk"})

   -> 0.0034s

-- add_foreign_key("test_scores_sat_official_before_march_2016", "tests", {:name=>"test_scores_sat_official_before_march_2016_test_id_fk"})

   -> 0.0028s

-- add_foreign_key("user_identity_colleges", "college_bases", {:name=>"user_identity_colleges_college_base_id_fk", :column=>"college_base_id", :dependent=>:delete})

   -> 0.0023s

-- add_foreign_key("user_identity_colleges", "user_identities", {:name=>"user_identity_colleges_user_identity_id_fk", :dependent=>:delete})

   -> 0.0023s

-- initialize_schema_migrations_table()

   -> 0.0070s



travis_time:end:002dc90b:start=1502828512950048608,finish=1502828528475605742,duration=15525557134
[0Ktravis_fold:end:before_script.9
[0Ktravis_time:start:2ccdd629
[0K$ set -e ; if [[ -z "${RUN}" ]] ; then for test_suite in ${TEST_SUITE} ; do ( set -x ; bundle exec rake db:test:prepare ${test_suite} ) ; done ; else ${RUN} ; fi

++bundle exec rake db:test:prepare minitest:integration_split

Auto-loading of `.env.test` will be removed in 1.0. See https://github.com/bkeepers/dotenv-deployment if you would like to continue using this feature.

DEPRECATION WARNING:

Sass 3.5 will no longer support Ruby 1.9.3.

Please upgrade to Ruby 2.0.0 or greater as soon as possible.



** Invoke db:test:prepare (first_time)

** Invoke environment (first_time)

** Execute environment

DEPRECATION WARNING: config.whiny_nils option is deprecated and no longer works. (called from block in <top (required)> at /home/travis/build/Liaison-Intl/WebAdMIT/config/environments/test.rb:15)

INFO: It's now safe to remove /home/travis/build/Liaison-Intl/WebAdMIT/config/initializers/backports/backport_find_or_initialize_by_and_find_or_create_by.rb

INFO: It's now safe to remove /home/travis/build/Liaison-Intl/WebAdMIT/config/initializers/backports/try.rb

Running Rails 4.0.13

Running Ruby 1.9.3

Running PostgreSQL 9.5.7 on x86_64-pc-linux-gnu, compiled by gcc (Ubuntu 4.8.4-2ubuntu1~14.04.3) 4.8.4, 64-bit

DEPRECATION WARNING: The following options in your Designation.has_many :combined_degrees declaration are deprecated: :conditions. Please use a scope block instead. For example, the following:



    has_many :spam_comments, conditions: { spam: true }, class_name: 'Comment'



should be rewritten as the following:



    has_many :spam_comments, -> { where spam: true }, class_name: 'Comment'

. (called from <class:Designation> at /home/travis/build/Liaison-Intl/WebAdMIT/app/models/designation.rb:55)

DEPRECATION WARNING: The following options in your Designation.has_many :optional_offerings declaration are deprecated: :uniq. Please use a scope block instead. For example, the following:



    has_many :spam_comments, conditions: { spam: true }, class_name: 'Comment'



should be rewritten as the following:



    has_many :spam_comments, -> { where spam: true }, class_name: 'Comment'

. (called from <class:Designation> at /home/travis/build/Liaison-Intl/WebAdMIT/app/models/designation.rb:67)

DEPRECATION WARNING: The following options in your Designation.has_many :designation_evaluations declaration are deprecated: :order. Please use a scope block instead. For example, the following:



    has_many :spam_comments, conditions: { spam: true }, class_name: 'Comment'



should be rewritten as the following:



    has_many :spam_comments, -> { where spam: true }, class_name: 'Comment'

. (called from <class:Designation> at /home/travis/build/Liaison-Intl/WebAdMIT/app/models/designation.rb:69)

DEPRECATION WARNING: The following options in your ApplicantRequirement.has_many :courses declaration are deprecated: :uniq. Please use a scope block instead. For example, the following:



    has_many :spam_comments, conditions: { spam: true }, class_name: 'Comment'



should be rewritten as the following:



    has_many :spam_comments, -> { where spam: true }, class_name: 'Comment'

. (called from <class:ApplicantRequirement> at /home/travis/build/Liaison-Intl/WebAdMIT/app/models/applicant_requirement.rb:17)

DEPRECATION WARNING: The following options in your LocalGpa.has_many :applicant_courses declaration are deprecated: :uniq. Please use a scope block instead. For example, the following:



    has_many :spam_comments, conditions: { spam: true }, class_name: 'Comment'



should be rewritten as the following:



    has_many :spam_comments, -> { where spam: true }, class_name: 'Comment'

. (called from <class:LocalGpa> at /home/travis/build/Liaison-Intl/WebAdMIT/app/models/local_gpa.rb:10)

DEPRECATION WARNING: The following options in your LocalGpa.has_many :local_gpas_courses declaration are deprecated: :uniq. Please use a scope block instead. For example, the following:



    has_many :spam_comments, conditions: { spam: true }, class_name: 'Comment'



should be rewritten as the following:



    has_many :spam_comments, -> { where spam: true }, class_name: 'Comment'

. (called from <class:LocalGpa> at /home/travis/build/Liaison-Intl/WebAdMIT/app/models/local_gpa.rb:12)

DEPRECATION WARNING: The following options in your LocalGpa.has_many :courses declaration are deprecated: :uniq. Please use a scope block instead. For example, the following:



    has_many :spam_comments, conditions: { spam: true }, class_name: 'Comment'



should be rewritten as the following:



    has_many :spam_comments, -> { where spam: true }, class_name: 'Comment'

. (called from <class:LocalGpa> at /home/travis/build/Liaison-Intl/WebAdMIT/app/models/local_gpa.rb:13)

DEPRECATION WARNING: The following options in your LocalGpa.has_many :selected_courses declaration are deprecated: :order,:conditions. Please use a scope block instead. For example, the following:



    has_many :spam_comments, conditions: { spam: true }, class_name: 'Comment'



should be rewritten as the following:



    has_many :spam_comments, -> { where spam: true }, class_name: 'Comment'

. (called from <class:LocalGpa> at /home/travis/build/Liaison-Intl/WebAdMIT/app/models/local_gpa.rb:15)

DEPRECATION WARNING: The following options in your LocalGpa.has_many :deselected_courses declaration are deprecated: :uniq,:conditions. Please use a scope block instead. For example, the following:



    has_many :spam_comments, conditions: { spam: true }, class_name: 'Comment'



should be rewritten as the following:



    has_many :spam_comments, -> { where spam: true }, class_name: 'Comment'

. (called from <class:LocalGpa> at /home/travis/build/Liaison-Intl/WebAdMIT/app/models/local_gpa.rb:19)

DEPRECATION WARNING: The following options in your Scoring::PointTable.has_many :scoring_models declaration are deprecated: :uniq. Please use a scope block instead. For example, the following:



    has_many :spam_comments, conditions: { spam: true }, class_name: 'Comment'



should be rewritten as the following:



    has_many :spam_comments, -> { where spam: true }, class_name: 'Comment'

. (called from <class:PointTable> at /home/travis/build/Liaison-Intl/WebAdMIT/app/models/scoring/point_table.rb:20)

DEPRECATION WARNING: The following options in your Scoring::PointTable.has_many :entries declaration are deprecated: :include. Please use a scope block instead. For example, the following:



    has_many :spam_comments, conditions: { spam: true }, class_name: 'Comment'



should be rewritten as the following:



    has_many :spam_comments, -> { where spam: true }, class_name: 'Comment'

. (called from <class:PointTable> at /home/travis/build/Liaison-Intl/WebAdMIT/app/models/scoring/point_table.rb:23)

DEPRECATION WARNING: The following options in your GpaTemplateBase.has_many :gpa_templates_subjects declaration are deprecated: :conditions. Please use a scope block instead. For example, the following:



    has_many :spam_comments, conditions: { spam: true }, class_name: 'Comment'



should be rewritten as the following:



    has_many :spam_comments, -> { where spam: true }, class_name: 'Comment'

. (called from <class:GpaTemplateBase> at /home/travis/build/Liaison-Intl/WebAdMIT/app/models/gpa_template_base.rb:10)

DEPRECATION WARNING: The following options in your GpaTemplateBase.has_many :tracked_subjects declaration are deprecated: :uniq. Please use a scope block instead. For example, the following:



    has_many :spam_comments, conditions: { spam: true }, class_name: 'Comment'



should be rewritten as the following:



    has_many :spam_comments, -> { where spam: true }, class_name: 'Comment'

. (called from <class:GpaTemplateBase> at /home/travis/build/Liaison-Intl/WebAdMIT/app/models/gpa_template_base.rb:11)

DEPRECATION WARNING: The following options in your GpaTemplateBase.has_many :local_gpas declaration are deprecated: :uniq. Please use a scope block instead. For example, the following:



    has_many :spam_comments, conditions: { spam: true }, class_name: 'Comment'



should be rewritten as the following:



    has_many :spam_comments, -> { where spam: true }, class_name: 'Comment'

. (called from <class:GpaTemplateBase> at /home/travis/build/Liaison-Intl/WebAdMIT/app/models/gpa_template_base.rb:25)

** Invoke db:load_config (first_time)

** Execute db:load_config

** Execute db:test:prepare

** Invoke db:test:load (first_time)

** Invoke db:test:purge (first_time)

** Invoke environment

** Invoke db:load_config

** Execute db:test:purge

** Execute db:test:load

** Invoke db:test:load_schema (first_time)

** Invoke db:test:purge

** Execute db:test:load_schema

** Invoke db:schema:load (first_time)

** Invoke environment

** Invoke db:load_config

** Execute db:schema:load

** Invoke data:load_sql (first_time)

** Invoke environment

** Execute data:load_sql

Load sql views for: test

Index answer bases on question base id and applicant id.psql...

Index applicant college details warehouse on lower mdb code.psql...

Index applicant college details warehouse on lower name.psql...

Index applicant ethnicities on lower name.psql...

Index applicants on lower cas id.psql...

Index applicants on lower email.psql...

Index applicants on lower match id.psql...

Index associations on lower name.psql...

Index users on lower email.psql...

Applicant designation details mv.psql...

Update applicant college details triggers.psql...

Create answer for applicant question.psql...

Create applicant colleges view.psql...

Create applicant designation details view.psql...

Create applicant evaluation details view.psql...

Create applicant gateway activity fields view.psql...

Create applicant observation hours.psql...

Create applicant preferred contacts view.psql...

Create edw views.psql...

Create evaluation receipts view.psql...

Create high school coursework details.psql...

Create other employment details view.psql...

Create views applicant degrees.psql...

Create views applicant majors.psql...

Create views applicant minors.psql...

** Invoke minitest:integration_split (first_time)

** Execute minitest:integration_split

[32m[Coveralls] Set up the SimpleCov formatter.[0m

[32m[Coveralls] Using SimpleCov's default settings.[0m

Auto-loading of `.env.test` will be removed in 1.0. See https://github.com/bkeepers/dotenv-deployment if you would like to continue using this feature.

DEPRECATION WARNING:

Sass 3.5 will no longer support Ruby 1.9.3.

Please upgrade to Ruby 2.0.0 or greater as soon as possible.



DEPRECATION WARNING: config.whiny_nils option is deprecated and no longer works. (called from block in <top (required)> at /home/travis/build/Liaison-Intl/WebAdMIT/config/environments/test.rb:15)

config.eager_load is set to nil. Please update your config/environments/*.rb files accordingly:



  * development - set it to false

  * test - set it to false (unless you use a tool that preloads your test environment)

  * production - set it to true





INFO: It's now safe to remove /home/travis/build/Liaison-Intl/WebAdMIT/config/initializers/backports/backport_find_or_initialize_by_and_find_or_create_by.rb

INFO: It's now safe to remove /home/travis/build/Liaison-Intl/WebAdMIT/config/initializers/backports/try.rb

/home/travis/build/Liaison-Intl/WebAdMIT/config/initializers/certified.rb:1: warning: already initialized constant CERTIFIED_LOG_LOCATION

/home/travis/build/Liaison-Intl/WebAdMIT/config/initializers/certified.rb:2: warning: already initialized constant CERTIFIED_LOG_FILE

Running Rails 4.0.13

Running Ruby 1.9.3

/home/travis/build/Liaison-Intl/WebAdMIT/vendor/bundle/ruby/1.9.1/gems/actionpack-4.0.13/lib/action_dispatch/http/mime_type.rb:167: warning: already initialized constant PDF

/home/travis/build/Liaison-Intl/WebAdMIT/config/initializers/paperclip.rb:16: warning: already initialized constant EMPTY_TYPE

Running PostgreSQL 9.5.7 on x86_64-pc-linux-gnu, compiled by gcc (Ubuntu 4.8.4-2ubuntu1~14.04.3) 4.8.4, 64-bit

DEPRECATION WARNING: The following options in your Export.has_many :fields declaration are deprecated: :order. Please use a scope block instead. For example, the following:



    has_many :spam_comments, conditions: { spam: true }, class_name: 'Comment'



should be rewritten as the following:



    has_many :spam_comments, -> { where spam: true }, class_name: 'Comment'

. (called from <class:Export> at /home/travis/build/Liaison-Intl/WebAdMIT/app/models/export.rb:5)

DEPRECATION WARNING: The following options in your Applicant.has_many :applicant_college_details declaration are deprecated: :readonly. Please use a scope block instead. For example, the following:



    has_many :spam_comments, conditions: { spam: true }, class_name: 'Comment'



should be rewritten as the following:



    has_many :spam_comments, -> { where spam: true }, class_name: 'Comment'

. (called from <class:Applicant> at /home/travis/build/Liaison-Intl/WebAdMIT/app/models/applicant.rb:21)

DEPRECATION WARNING: The following options in your Applicant.has_many :applicant_gateway_attachments declaration are deprecated: :conditions. Please use a scope block instead. For example, the following:



    has_many :spam_comments, conditions: { spam: true }, class_name: 'Comment'



should be rewritten as the following:



    has_many :spam_comments, -> { where spam: true }, class_name: 'Comment'

. (called from <class:Applicant> at /home/travis/build/Liaison-Intl/WebAdMIT/app/models/applicant.rb:29)

DEPRECATION WARNING: The following options in your Applicant.has_many :cas_attachments declaration are deprecated: :conditions. Please use a scope block instead. For example, the following:



    has_many :spam_comments, conditions: { spam: true }, class_name: 'Comment'



should be rewritten as the following:



    has_many :spam_comments, -> { where spam: true }, class_name: 'Comment'

. (called from <class:Applicant> at /home/travis/build/Liaison-Intl/WebAdMIT/app/models/applicant.rb:50)

DEPRECATION WARNING: The following options in your Applicant.has_many :criteria declaration are deprecated: :uniq. Please use a scope block instead. For example, the following:



    has_many :spam_comments, conditions: { spam: true }, class_name: 'Comment'



should be rewritten as the following:



    has_many :spam_comments, -> { where spam: true }, class_name: 'Comment'

. (called from <class:Applicant> at /home/travis/build/Liaison-Intl/WebAdMIT/app/models/applicant.rb:60)

DEPRECATION WARNING: The following options in your Applicant.has_many :dental_school_details declaration are deprecated: :readonly. Please use a scope block instead. For example, the following:



    has_many :spam_comments, conditions: { spam: true }, class_name: 'Comment'



should be rewritten as the following:



    has_many :spam_comments, -> { where spam: true }, class_name: 'Comment'

. (called from <class:Applicant> at /home/travis/build/Liaison-Intl/WebAdMIT/app/models/applicant.rb:65)

DEPRECATION WARNING: The following options in your Applicant.has_many :essay_programs declaration are deprecated: :uniq. Please use a scope block instead. For example, the following:



    has_many :spam_comments, conditions: { spam: true }, class_name: 'Comment'



should be rewritten as the following:



    has_many :spam_comments, -> { where spam: true }, class_name: 'Comment'

. (called from <class:Applicant> at /home/travis/build/Liaison-Intl/WebAdMIT/app/models/applicant.rb:73)

DEPRECATION WARNING: The following options in your Applicant.has_many :evaluation_attachments declaration are deprecated: :conditions. Please use a scope block instead. For example, the following:



    has_many :spam_comments, conditions: { spam: true }, class_name: 'Comment'



should be rewritten as the following:



    has_many :spam_comments, -> { where spam: true }, class_name: 'Comment'

. (called from <class:Applicant> at /home/travis/build/Liaison-Intl/WebAdMIT/app/models/applicant.rb:76)

DEPRECATION WARNING: The following options in your Applicant.has_many :evaluation_details declaration are deprecated: :readonly. Please use a scope block instead. For example, the following:



    has_many :spam_comments, conditions: { spam: true }, class_name: 'Comment'



should be rewritten as the following:



    has_many :spam_comments, -> { where spam: true }, class_name: 'Comment'

. (called from <class:Applicant> at /home/travis/build/Liaison-Intl/WebAdMIT/app/models/applicant.rb:81)

DEPRECATION WARNING: The following options in your Applicant.has_many :evaluation_receipts declaration are deprecated: :readonly. Please use a scope block instead. For example, the following:



    has_many :spam_comments, conditions: { spam: true }, class_name: 'Comment'



should be rewritten as the following:



    has_many :spam_comments, -> { where spam: true }, class_name: 'Comment'

. (called from <class:Applicant> at /home/travis/build/Liaison-Intl/WebAdMIT/app/models/applicant.rb:82)

DEPRECATION WARNING: The following options in your Applicant.has_many :evaluations declaration are deprecated: :order. Please use a scope block instead. For example, the following:



    has_many :spam_comments, conditions: { spam: true }, class_name: 'Comment'



should be rewritten as the following:



    has_many :spam_comments, -> { where spam: true }, class_name: 'Comment'

. (called from <class:Applicant> at /home/travis/build/Liaison-Intl/WebAdMIT/app/models/applicant.rb:83)

DEPRECATION WARNING: The following options in your Applicant.has_many :general_college_details declaration are deprecated: :readonly. Please use a scope block instead. For example, the following:



    has_many :spam_comments, conditions: { spam: true }, class_name: 'Comment'



should be rewritten as the following:



    has_many :spam_comments, -> { where spam: true }, class_name: 'Comment'

. (called from <class:Applicant> at /home/travis/build/Liaison-Intl/WebAdMIT/app/models/applicant.rb:93)

DEPRECATION WARNING: The following options in your Applicant.has_many :mailings declaration are deprecated: :uniq. Please use a scope block instead. For example, the following:



    has_many :spam_comments, conditions: { spam: true }, class_name: 'Comment'



should be rewritten as the following:



    has_many :spam_comments, -> { where spam: true }, class_name: 'Comment'

. (called from <class:Applicant> at /home/travis/build/Liaison-Intl/WebAdMIT/app/models/applicant.rb:115)

DEPRECATION WARNING: The following options in your Applicant.has_many :mcat_graph_attachments declaration are deprecated: :conditions. Please use a scope block instead. For example, the following:



    has_many :spam_comments, conditions: { spam: true }, class_name: 'Comment'



should be rewritten as the following:



    has_many :spam_comments, -> { where spam: true }, class_name: 'Comment'

. (called from <class:Applicant> at /home/travis/build/Liaison-Intl/WebAdMIT/app/models/applicant.rb:117)

DEPRECATION WARNING: The following options in your Applicant.has_many :medical_college_details declaration are deprecated: :readonly. Please use a scope block instead. For example, the following:



    has_many :spam_comments, conditions: { spam: true }, class_name: 'Comment'



should be rewritten as the following:



    has_many :spam_comments, -> { where spam: true }, class_name: 'Comment'

. (called from <class:Applicant> at /home/travis/build/Liaison-Intl/WebAdMIT/app/models/applicant.rb:118)

DEPRECATION WARNING: The following options in your Applicant.has_many :observation_hours_details declaration are deprecated: :readonly. Please use a scope block instead. For example, the following:



    has_many :spam_comments, conditions: { spam: true }, class_name: 'Comment'



should be rewritten as the following:



    has_many :spam_comments, -> { where spam: true }, class_name: 'Comment'

. (called from <class:Applicant> at /home/travis/build/Liaison-Intl/WebAdMIT/app/models/applicant.rb:126)

DEPRECATION WARNING: The following options in your Applicant.has_many :organizations declaration are deprecated: :uniq. Please use a scope block instead. For example, the following:



    has_many :spam_comments, conditions: { spam: true }, class_name: 'Comment'



should be rewritten as the following:



    has_many :spam_comments, -> { where spam: true }, class_name: 'Comment'

. (called from <class:Applicant> at /home/travis/build/Liaison-Intl/WebAdMIT/app/models/applicant.rb:131)

DEPRECATION WARNING: The following options in your Applicant.has_many :pharmacy_school_details declaration are deprecated: :readonly. Please use a scope block instead. For example, the following:



    has_many :spam_comments, conditions: { spam: true }, class_name: 'Comment'



should be rewritten as the following:



    has_many :spam_comments, -> { where spam: true }, class_name: 'Comment'

. (called from <class:Applicant> at /home/travis/build/Liaison-Intl/WebAdMIT/app/models/applicant.rb:138)

DEPRECATION WARNING: The following options in your Applicant.has_many :programs declaration are deprecated: :uniq. Please use a scope block instead. For example, the following:



    has_many :spam_comments, conditions: { spam: true }, class_name: 'Comment'



should be rewritten as the following:



    has_many :spam_comments, -> { where spam: true }, class_name: 'Comment'

. (called from <class:Applicant> at /home/travis/build/Liaison-Intl/WebAdMIT/app/models/applicant.rb:151)

DEPRECATION WARNING: The following options in your Applicant.has_many :pt_college_details declaration are deprecated: :readonly. Please use a scope block instead. For example, the following:



    has_many :spam_comments, conditions: { spam: true }, class_name: 'Comment'



should be rewritten as the following:



    has_many :spam_comments, -> { where spam: true }, class_name: 'Comment'

. (called from <class:Applicant> at /home/travis/build/Liaison-Intl/WebAdMIT/app/models/applicant.rb:156)

DEPRECATION WARNING: The following options in your Applicant.has_many :requirements declaration are deprecated: :uniq. Please use a scope block instead. For example, the following:



    has_many :spam_comments, conditions: { spam: true }, class_name: 'Comment'



should be rewritten as the following:



    has_many :spam_comments, -> { where spam: true }, class_name: 'Comment'

. (called from <class:Applicant> at /home/travis/build/Liaison-Intl/WebAdMIT/app/models/applicant.rb:161)

DEPRECATION WARNING: The following options in your Applicant.has_many :transcripts declaration are deprecated: :order. Please use a scope block instead. For example, the following:



    has_many :spam_comments, conditions: { spam: true }, class_name: 'Comment'



should be rewritten as the following:



    has_many :spam_comments, -> { where spam: true }, class_name: 'Comment'

. (called from <class:Applicant> at /home/travis/build/Liaison-Intl/WebAdMIT/app/models/applicant.rb:180)

DEPRECATION WARNING: The following options in your Applicant.has_one :parent_1 declaration are deprecated: :conditions. Please use a scope block instead. For example, the following:



    has_many :spam_comments, conditions: { spam: true }, class_name: 'Comment'



should be rewritten as the following:



    has_many :spam_comments, -> { where spam: true }, class_name: 'Comment'

. (called from <class:Applicant> at /home/travis/build/Liaison-Intl/WebAdMIT/app/models/applicant.rb:240)

DEPRECATION WARNING: The following options in your Applicant.has_one :parent_2 declaration are deprecated: :conditions. Please use a scope block instead. For example, the following:



    has_many :spam_comments, conditions: { spam: true }, class_name: 'Comment'



should be rewritten as the following:



    has_many :spam_comments, -> { where spam: true }, class_name: 'Comment'

. (called from <class:Applicant> at /home/travis/build/Liaison-Intl/WebAdMIT/app/models/applicant.rb:241)

DEPRECATION WARNING: The following options in your Applicant.has_one :current_contact declaration are deprecated: :conditions. Please use a scope block instead. For example, the following:



    has_many :spam_comments, conditions: { spam: true }, class_name: 'Comment'



should be rewritten as the following:



    has_many :spam_comments, -> { where spam: true }, class_name: 'Comment'

. (called from <class:Applicant> at /home/travis/build/Liaison-Intl/WebAdMIT/app/models/applicant.rb:248)

DEPRECATION WARNING: The following options in your Applicant.has_one :permanent_contact declaration are deprecated: :conditions. Please use a scope block instead. For example, the following:



    has_many :spam_comments, conditions: { spam: true }, class_name: 'Comment'



should be rewritten as the following:



    has_many :spam_comments, -> { where spam: true }, class_name: 'Comment'

. (called from <class:Applicant> at /home/travis/build/Liaison-Intl/WebAdMIT/app/models/applicant.rb:252)

DEPRECATION WARNING: The following options in your Applicant.has_one :preferred_contact declaration are deprecated: :conditions. Please use a scope block instead. For example, the following:



    has_many :spam_comments, conditions: { spam: true }, class_name: 'Comment'



should be rewritten as the following:



    has_many :spam_comments, -> { where spam: true }, class_name: 'Comment'

. (called from <class:Applicant> at /home/travis/build/Liaison-Intl/WebAdMIT/app/models/applicant.rb:256)

DEPRECATION WARNING: The following options in your Applicant.has_one :alternate_contact declaration are deprecated: :conditions. Please use a scope block instead. For example, the following:



    has_many :spam_comments, conditions: { spam: true }, class_name: 'Comment'



should be rewritten as the following:



    has_many :spam_comments, -> { where spam: true }, class_name: 'Comment'

. (called from <class:Applicant> at /home/travis/build/Liaison-Intl/WebAdMIT/app/models/applicant.rb:260)

DEPRECATION WARNING: The following options in your Applicant.has_one :emergency_contact declaration are deprecated: :conditions. Please use a scope block instead. For example, the following:



    has_many :spam_comments, conditions: { spam: true }, class_name: 'Comment'



should be rewritten as the following:



    has_many :spam_comments, -> { where spam: true }, class_name: 'Comment'

. (called from <class:Applicant> at /home/travis/build/Liaison-Intl/WebAdMIT/app/models/applicant.rb:264)

DEPRECATION WARNING: The following options in your Course.has_many :local_gpas declaration are deprecated: :uniq. Please use a scope block instead. For example, the following:



    has_many :spam_comments, conditions: { spam: true }, class_name: 'Comment'



should be rewritten as the following:



    has_many :spam_comments, -> { where spam: true }, class_name: 'Comment'

. (called from <class:Course> at /home/travis/build/Liaison-Intl/WebAdMIT/app/models/course.rb:23)

DEPRECATION WARNING: The following options in your Course.has_many :applicant_criteria_courses declaration are deprecated: :uniq. Please use a scope block instead. For example, the following:



    has_many :spam_comments, conditions: { spam: true }, class_name: 'Comment'



should be rewritten as the following:



    has_many :spam_comments, -> { where spam: true }, class_name: 'Comment'

. (called from <class:Course> at /home/travis/build/Liaison-Intl/WebAdMIT/app/models/course.rb:25)

DEPRECATION WARNING: The following options in your Designation.has_many :combined_degrees declaration are deprecated: :conditions. Please use a scope block instead. For example, the following:



    has_many :spam_comments, conditions: { spam: true }, class_name: 'Comment'



should be rewritten as the following:



    has_many :spam_comments, -> { where spam: true }, class_name: 'Comment'

. (called from <class:Designation> at /home/travis/build/Liaison-Intl/WebAdMIT/app/models/designation.rb:55)

DEPRECATION WARNING: The following options in your Designation.has_many :optional_offerings declaration are deprecated: :uniq. Please use a scope block instead. For example, the following:



    has_many :spam_comments, conditions: { spam: true }, class_name: 'Comment'



should be rewritten as the following:



    has_many :spam_comments, -> { where spam: true }, class_name: 'Comment'

. (called from <class:Designation> at /home/travis/build/Liaison-Intl/WebAdMIT/app/models/designation.rb:67)

DEPRECATION WARNING: The following options in your Designation.has_many :designation_evaluations declaration are deprecated: :order. Please use a scope block instead. For example, the following:



    has_many :spam_comments, conditions: { spam: true }, class_name: 'Comment'



should be rewritten as the following:



    has_many :spam_comments, -> { where spam: true }, class_name: 'Comment'

. (called from <class:Designation> at /home/travis/build/Liaison-Intl/WebAdMIT/app/models/designation.rb:69)

DEPRECATION WARNING: [paperclip] [deprecation] AWS SDK v1 has been deprecated in paperclip 5. Please consider upgrading to AWS 2 before upgrading paperclip. (called from <class:ApplicantAttachment> at /home/travis/build/Liaison-Intl/WebAdMIT/app/models/applicant_attachment.rb:14)

DEPRECATION WARNING: [paperclip] [deprecation] Rails 3.2 and 4.1 are unsupported as of Rails 5 release. Please upgrade to Rails 4.2 before upgrading paperclip. (called from <class:ApplicantAttachment> at /home/travis/build/Liaison-Intl/WebAdMIT/app/models/applicant_attachment.rb:14)

DEPRECATION WARNING: The following options in your ApplicantCriterion.has_many :applicant_criteria_courses declaration are deprecated: :uniq. Please use a scope block instead. For example, the following:



    has_many :spam_comments, conditions: { spam: true }, class_name: 'Comment'



should be rewritten as the following:



    has_many :spam_comments, -> { where spam: true }, class_name: 'Comment'

. (called from <class:ApplicantCriterion> at /home/travis/build/Liaison-Intl/WebAdMIT/app/models/applicant_criterion.rb:10)

DEPRECATION WARNING: The following options in your ApplicantCriterion.has_many :courses declaration are deprecated: :uniq. Please use a scope block instead. For example, the following:



    has_many :spam_comments, conditions: { spam: true }, class_name: 'Comment'



should be rewritten as the following:



    has_many :spam_comments, -> { where spam: true }, class_name: 'Comment'

. (called from <class:ApplicantCriterion> at /home/travis/build/Liaison-Intl/WebAdMIT/app/models/applicant_criterion.rb:14)

DEPRECATION WARNING: The following options in your ApplicantRequirement.has_many :courses declaration are deprecated: :uniq. Please use a scope block instead. For example, the following:



    has_many :spam_comments, conditions: { spam: true }, class_name: 'Comment'



should be rewritten as the following:



    has_many :spam_comments, -> { where spam: true }, class_name: 'Comment'

. (called from <class:ApplicantRequirement> at /home/travis/build/Liaison-Intl/WebAdMIT/app/models/applicant_requirement.rb:17)

DEPRECATION WARNING: The following options in your ApplicationStatus.has_many :applicants declaration are deprecated: :uniq. Please use a scope block instead. For example, the following:



    has_many :spam_comments, conditions: { spam: true }, class_name: 'Comment'



should be rewritten as the following:



    has_many :spam_comments, -> { where spam: true }, class_name: 'Comment'

. (called from <class:ApplicationStatus> at /home/travis/build/Liaison-Intl/WebAdMIT/app/models/application_status.rb:18)

DEPRECATION WARNING: The following options in your Assignments::AssignmentTypeBase.has_many :programs declaration are deprecated: :uniq. Please use a scope block instead. For example, the following:



    has_many :spam_comments, conditions: { spam: true }, class_name: 'Comment'



should be rewritten as the following:



    has_many :spam_comments, -> { where spam: true }, class_name: 'Comment'

. (called from <class:AssignmentTypeBase> at /home/travis/build/Liaison-Intl/WebAdMIT/app/models/assignments/assignment_type_base.rb:33)

DEPRECATION WARNING: [paperclip] [deprecation] AWS SDK v1 has been deprecated in paperclip 5. Please consider upgrading to AWS 2 before upgrading paperclip. (called from <class:Association> at /home/travis/build/Liaison-Intl/WebAdMIT/app/models/association.rb:16)

DEPRECATION WARNING: [paperclip] [deprecation] Rails 3.2 and 4.1 are unsupported as of Rails 5 release. Please upgrade to Rails 4.2 before upgrading paperclip. (called from <class:Association> at /home/travis/build/Liaison-Intl/WebAdMIT/app/models/association.rb:16)

DEPRECATION WARNING: The following options in your Association.has_many :application_statuses declaration are deprecated: :order. Please use a scope block instead. For example, the following:



    has_many :spam_comments, conditions: { spam: true }, class_name: 'Comment'



should be rewritten as the following:



    has_many :spam_comments, -> { where spam: true }, class_name: 'Comment'

. (called from <class:Association> at /home/travis/build/Liaison-Intl/WebAdMIT/app/models/association.rb:80)

DEPRECATION WARNING: The following options in your Association.has_many :academic_update_statuses declaration are deprecated: :order. Please use a scope block instead. For example, the following:



    has_many :spam_comments, conditions: { spam: true }, class_name: 'Comment'



should be rewritten as the following:



    has_many :spam_comments, -> { where spam: true }, class_name: 'Comment'

. (called from <class:Association> at /home/travis/build/Liaison-Intl/WebAdMIT/app/models/association.rb:81)

DEPRECATION WARNING: The following options in your Association.has_many :features declaration are deprecated: :uniq,:include. Please use a scope block instead. For example, the following:



    has_many :spam_comments, conditions: { spam: true }, class_name: 'Comment'



should be rewritten as the following:



    has_many :spam_comments, -> { where spam: true }, class_name: 'Comment'

. (called from <class:Association> at /home/travis/build/Liaison-Intl/WebAdMIT/app/models/association.rb:89)

DEPRECATION WARNING: The following options in your Association.has_many :subpanel_assignments declaration are deprecated: :uniq. Please use a scope block instead. For example, the following:



    has_many :spam_comments, conditions: { spam: true }, class_name: 'Comment'



should be rewritten as the following:



    has_many :spam_comments, -> { where spam: true }, class_name: 'Comment'

. (called from <class:Association> at /home/travis/build/Liaison-Intl/WebAdMIT/app/models/association.rb:97)

[ETL] Config for nursing database does not exist in '/home/travis/build/Liaison-Intl/WebAdMIT/config/cas/nursing.yml'

DEPRECATION WARNING: The following options in your GpaTemplateBase.has_many :gpa_templates_subjects declaration are deprecated: :conditions. Please use a scope block instead. For example, the following:



    has_many :spam_comments, conditions: { spam: true }, class_name: 'Comment'



should be rewritten as the following:



    has_many :spam_comments, -> { where spam: true }, class_name: 'Comment'

. (called from <class:GpaTemplateBase> at /home/travis/build/Liaison-Intl/WebAdMIT/app/models/gpa_template_base.rb:10)

DEPRECATION WARNING: The following options in your GpaTemplateBase.has_many :tracked_subjects declaration are deprecated: :uniq. Please use a scope block instead. For example, the following:



    has_many :spam_comments, conditions: { spam: true }, class_name: 'Comment'



should be rewritten as the following:



    has_many :spam_comments, -> { where spam: true }, class_name: 'Comment'

. (called from <class:GpaTemplateBase> at /home/travis/build/Liaison-Intl/WebAdMIT/app/models/gpa_template_base.rb:11)

DEPRECATION WARNING: The following options in your GpaTemplateBase.has_many :local_gpas declaration are deprecated: :uniq. Please use a scope block instead. For example, the following:



    has_many :spam_comments, conditions: { spam: true }, class_name: 'Comment'



should be rewritten as the following:



    has_many :spam_comments, -> { where spam: true }, class_name: 'Comment'

. (called from <class:GpaTemplateBase> at /home/travis/build/Liaison-Intl/WebAdMIT/app/models/gpa_template_base.rb:25)

DEPRECATION WARNING: The following options in your CollegeAttended.has_one :applicant_college_detail declaration are deprecated: :readonly. Please use a scope block instead. For example, the following:



    has_many :spam_comments, conditions: { spam: true }, class_name: 'Comment'



should be rewritten as the following:



    has_many :spam_comments, -> { where spam: true }, class_name: 'Comment'

. (called from <class:CollegeAttended> at /home/travis/build/Liaison-Intl/WebAdMIT/app/models/college_attended.rb:9)

DEPRECATION WARNING: The following options in your Criterion.has_many :criteria_comments declaration are deprecated: :order. Please use a scope block instead. For example, the following:



    has_many :spam_comments, conditions: { spam: true }, class_name: 'Comment'



should be rewritten as the following:



    has_many :spam_comments, -> { where spam: true }, class_name: 'Comment'

. (called from <class:Criterion> at /home/travis/build/Liaison-Intl/WebAdMIT/app/models/criterion.rb:11)

DEPRECATION WARNING: The following options in your CustomField.has_many :programs declaration are deprecated: :uniq. Please use a scope block instead. For example, the following:



    has_many :spam_comments, conditions: { spam: true }, class_name: 'Comment'



should be rewritten as the following:



    has_many :spam_comments, -> { where spam: true }, class_name: 'Comment'

. (called from <class:CustomField> at /home/travis/build/Liaison-Intl/WebAdMIT/app/models/custom_field.rb:7)

DEPRECATION WARNING: The following options in your Email::Address.has_many :programs declaration are deprecated: :uniq. Please use a scope block instead. For example, the following:



    has_many :spam_comments, conditions: { spam: true }, class_name: 'Comment'



should be rewritten as the following:



    has_many :spam_comments, -> { where spam: true }, class_name: 'Comment'

. (called from <class:Address> at /home/travis/build/Liaison-Intl/WebAdMIT/app/models/email/address.rb:24)

DEPRECATION WARNING: The following options in your Email::Email.has_many :email_bccs declaration are deprecated: :conditions. Please use a scope block instead. For example, the following:



    has_many :spam_comments, conditions: { spam: true }, class_name: 'Comment'



should be rewritten as the following:



    has_many :spam_comments, -> { where spam: true }, class_name: 'Comment'

. (called from <class:Email> at /home/travis/build/Liaison-Intl/WebAdMIT/app/models/email/email.rb:47)

DEPRECATION WARNING: The following options in your Email::Email.has_many :email_ccs declaration are deprecated: :conditions. Please use a scope block instead. For example, the following:



    has_many :spam_comments, conditions: { spam: true }, class_name: 'Comment'



should be rewritten as the following:



    has_many :spam_comments, -> { where spam: true }, class_name: 'Comment'

. (called from <class:Email> at /home/travis/build/Liaison-Intl/WebAdMIT/app/models/email/email.rb:52)

DEPRECATION WARNING: The following options in your Email::Template.has_many :programs declaration are deprecated: :uniq. Please use a scope block instead. For example, the following:



    has_many :spam_comments, conditions: { spam: true }, class_name: 'Comment'



should be rewritten as the following:



    has_many :spam_comments, -> { where spam: true }, class_name: 'Comment'

. (called from <class:Template> at /home/travis/build/Liaison-Intl/WebAdMIT/app/models/email/template.rb:21)

DEPRECATION WARNING: [paperclip] [deprecation] AWS SDK v1 has been deprecated in paperclip 5. Please consider upgrading to AWS 2 before upgrading paperclip. (called from <class:ExportFile> at /home/travis/build/Liaison-Intl/WebAdMIT/app/models/export_file.rb:9)

DEPRECATION WARNING: [paperclip] [deprecation] Rails 3.2 and 4.1 are unsupported as of Rails 5 release. Please upgrade to Rails 4.2 before upgrading paperclip. (called from <class:ExportFile> at /home/travis/build/Liaison-Intl/WebAdMIT/app/models/export_file.rb:9)

DEPRECATION WARNING: The following options in your LocalGpa.has_many :applicant_courses declaration are deprecated: :uniq. Please use a scope block instead. For example, the following:



    has_many :spam_comments, conditions: { spam: true }, class_name: 'Comment'



should be rewritten as the following:



    has_many :spam_comments, -> { where spam: true }, class_name: 'Comment'

. (called from <class:LocalGpa> at /home/travis/build/Liaison-Intl/WebAdMIT/app/models/local_gpa.rb:10)

DEPRECATION WARNING: The following options in your LocalGpa.has_many :local_gpas_courses declaration are deprecated: :uniq. Please use a scope block instead. For example, the following:



    has_many :spam_comments, conditions: { spam: true }, class_name: 'Comment'



should be rewritten as the following:



    has_many :spam_comments, -> { where spam: true }, class_name: 'Comment'

. (called from <class:LocalGpa> at /home/travis/build/Liaison-Intl/WebAdMIT/app/models/local_gpa.rb:12)

DEPRECATION WARNING: The following options in your LocalGpa.has_many :courses declaration are deprecated: :uniq. Please use a scope block instead. For example, the following:



    has_many :spam_comments, conditions: { spam: true }, class_name: 'Comment'



should be rewritten as the following:



    has_many :spam_comments, -> { where spam: true }, class_name: 'Comment'

. (called from <class:LocalGpa> at /home/travis/build/Liaison-Intl/WebAdMIT/app/models/local_gpa.rb:13)

DEPRECATION WARNING: The following options in your LocalGpa.has_many :selected_courses declaration are deprecated: :order,:conditions. Please use a scope block instead. For example, the following:



    has_many :spam_comments, conditions: { spam: true }, class_name: 'Comment'



should be rewritten as the following:



    has_many :spam_comments, -> { where spam: true }, class_name: 'Comment'

. (called from <class:LocalGpa> at /home/travis/build/Liaison-Intl/WebAdMIT/app/models/local_gpa.rb:15)

DEPRECATION WARNING: The following options in your LocalGpa.has_many :deselected_courses declaration are deprecated: :uniq,:conditions. Please use a scope block instead. For example, the following:



    has_many :spam_comments, conditions: { spam: true }, class_name: 'Comment'



should be rewritten as the following:



    has_many :spam_comments, -> { where spam: true }, class_name: 'Comment'

. (called from <class:LocalGpa> at /home/travis/build/Liaison-Intl/WebAdMIT/app/models/local_gpa.rb:19)

DEPRECATION WARNING: The following options in your LocalStatus.has_many :programs declaration are deprecated: :uniq. Please use a scope block instead. For example, the following:



    has_many :spam_comments, conditions: { spam: true }, class_name: 'Comment'



should be rewritten as the following:



    has_many :spam_comments, -> { where spam: true }, class_name: 'Comment'

. (called from <class:LocalStatus> at /home/travis/build/Liaison-Intl/WebAdMIT/app/models/local_status.rb:31)

DEPRECATION WARNING: The following options in your Mailing.has_many :applicants declaration are deprecated: :uniq. Please use a scope block instead. For example, the following:



    has_many :spam_comments, conditions: { spam: true }, class_name: 'Comment'



should be rewritten as the following:



    has_many :spam_comments, -> { where spam: true }, class_name: 'Comment'

. (called from <class:Mailing> at /home/travis/build/Liaison-Intl/WebAdMIT/app/models/mailing.rb:13)

DEPRECATION WARNING: The following options in your Mailing.has_many :organizations declaration are deprecated: :uniq. Please use a scope block instead. For example, the following:



    has_many :spam_comments, conditions: { spam: true }, class_name: 'Comment'



should be rewritten as the following:



    has_many :spam_comments, -> { where spam: true }, class_name: 'Comment'

. (called from <class:Mailing> at /home/travis/build/Liaison-Intl/WebAdMIT/app/models/mailing.rb:15)

DEPRECATION WARNING: The following options in your Mailing.has_many :programs declaration are deprecated: :uniq. Please use a scope block instead. For example, the following:



    has_many :spam_comments, conditions: { spam: true }, class_name: 'Comment'



should be rewritten as the following:



    has_many :spam_comments, -> { where spam: true }, class_name: 'Comment'

. (called from <class:Mailing> at /home/travis/build/Liaison-Intl/WebAdMIT/app/models/mailing.rb:16)

DEPRECATION WARNING: The following options in your Organization.has_many :primary_users declaration are deprecated: :conditions. Please use a scope block instead. For example, the following:



    has_many :spam_comments, conditions: { spam: true }, class_name: 'Comment'



should be rewritten as the following:



    has_many :spam_comments, -> { where spam: true }, class_name: 'Comment'

. (called from <class:Organization> at /home/travis/build/Liaison-Intl/WebAdMIT/app/models/organization.rb:21)

DEPRECATION WARNING: The following options in your Organization.has_many :requirements declaration are deprecated: :conditions. Please use a scope block instead. For example, the following:



    has_many :spam_comments, conditions: { spam: true }, class_name: 'Comment'



should be rewritten as the following:



    has_many :spam_comments, -> { where spam: true }, class_name: 'Comment'

. (called from <class:Organization> at /home/travis/build/Liaison-Intl/WebAdMIT/app/models/organization.rb:31)

DEPRECATION WARNING: The following options in your Organization.has_many :prerequisites declaration are deprecated: :conditions. Please use a scope block instead. For example, the following:



    has_many :spam_comments, conditions: { spam: true }, class_name: 'Comment'



should be rewritten as the following:



    has_many :spam_comments, -> { where spam: true }, class_name: 'Comment'

. (called from <class:Organization> at /home/travis/build/Liaison-Intl/WebAdMIT/app/models/organization.rb:34)

DEPRECATION WARNING: The following options in your Organization.has_many :programs declaration are deprecated: :uniq. Please use a scope block instead. For example, the following:



    has_many :spam_comments, conditions: { spam: true }, class_name: 'Comment'



should be rewritten as the following:



    has_many :spam_comments, -> { where spam: true }, class_name: 'Comment'

. (called from <class:Organization> at /home/travis/build/Liaison-Intl/WebAdMIT/app/models/organization.rb:38)

DEPRECATION WARNING: The following options in your Organization.has_many :feature_assignments declaration are deprecated: :uniq. Please use a scope block instead. For example, the following:



    has_many :spam_comments, conditions: { spam: true }, class_name: 'Comment'



should be rewritten as the following:



    has_many :spam_comments, -> { where spam: true }, class_name: 'Comment'

. (called from <class:Organization> at /home/travis/build/Liaison-Intl/WebAdMIT/app/models/organization.rb:43)

DEPRECATION WARNING: The following options in your Organization.has_many :features declaration are deprecated: :uniq,:include. Please use a scope block instead. For example, the following:



    has_many :spam_comments, conditions: { spam: true }, class_name: 'Comment'



should be rewritten as the following:



    has_many :spam_comments, -> { where spam: true }, class_name: 'Comment'

. (called from <class:Organization> at /home/travis/build/Liaison-Intl/WebAdMIT/app/models/organization.rb:44)

DEPRECATION WARNING: The following options in your ProgramBase.has_one :pending_change_request declaration are deprecated: :conditions. Please use a scope block instead. For example, the following:



    has_many :spam_comments, conditions: { spam: true }, class_name: 'Comment'



should be rewritten as the following:



    has_many :spam_comments, -> { where spam: true }, class_name: 'Comment'

. (called from <class:ProgramBase> at /home/travis/build/Liaison-Intl/WebAdMIT/app/models/program_base.rb:12)

DEPRECATION WARNING: The :restrict option is deprecated. Please use :restrict_with_exception instead, which provides the same functionality. (called from <class:Program> at /home/travis/build/Liaison-Intl/WebAdMIT/app/models/program.rb:34)

DEPRECATION WARNING: The following options in your Parent.has_one :contact declaration are deprecated: :conditions. Please use a scope block instead. For example, the following:



    has_many :spam_comments, conditions: { spam: true }, class_name: 'Comment'



should be rewritten as the following:



    has_many :spam_comments, -> { where spam: true }, class_name: 'Comment'

. (called from <class:Parent> at /home/travis/build/Liaison-Intl/WebAdMIT/app/models/parent.rb:5)

DEPRECATION WARNING: The following options in your PdfManager::Template.has_many :template_subpanels declaration are deprecated: :uniq. Please use a scope block instead. For example, the following:



    has_many :spam_comments, conditions: { spam: true }, class_name: 'Comment'



should be rewritten as the following:



    has_many :spam_comments, -> { where spam: true }, class_name: 'Comment'

. (called from <class:Template> at /home/travis/build/Liaison-Intl/WebAdMIT/app/models/pdf_manager/template.rb:12)

DEPRECATION WARNING: [paperclip] [deprecation] AWS SDK v1 has been deprecated in paperclip 5. Please consider upgrading to AWS 2 before upgrading paperclip. (called from <class:ZipFile> at /home/travis/build/Liaison-Intl/WebAdMIT/app/models/pdf_manager/zip_file.rb:18)

DEPRECATION WARNING: [paperclip] [deprecation] Rails 3.2 and 4.1 are unsupported as of Rails 5 release. Please upgrade to Rails 4.2 before upgrading paperclip. (called from <class:ZipFile> at /home/travis/build/Liaison-Intl/WebAdMIT/app/models/pdf_manager/zip_file.rb:18)

DEPRECATION WARNING: The following options in your Permissions::Feature.has_many :feature_assignments declaration are deprecated: :uniq. Please use a scope block instead. For example, the following:



    has_many :spam_comments, conditions: { spam: true }, class_name: 'Comment'



should be rewritten as the following:



    has_many :spam_comments, -> { where spam: true }, class_name: 'Comment'

. (called from <class:Feature> at /home/travis/build/Liaison-Intl/WebAdMIT/app/models/permissions/feature.rb:4)

DEPRECATION WARNING: The following options in your Permissions::Feature.has_many :rights declaration are deprecated: :uniq. Please use a scope block instead. For example, the following:



    has_many :spam_comments, conditions: { spam: true }, class_name: 'Comment'



should be rewritten as the following:



    has_many :spam_comments, -> { where spam: true }, class_name: 'Comment'

. (called from <class:Feature> at /home/travis/build/Liaison-Intl/WebAdMIT/app/models/permissions/feature.rb:6)

DEPRECATION WARNING: The following options in your Permissions::Role.has_many :user_roles declaration are deprecated: :uniq. Please use a scope block instead. For example, the following:



    has_many :spam_comments, conditions: { spam: true }, class_name: 'Comment'



should be rewritten as the following:



    has_many :spam_comments, -> { where spam: true }, class_name: 'Comment'

. (called from <class:Role> at /home/travis/build/Liaison-Intl/WebAdMIT/app/models/permissions/role.rb:7)

DEPRECATION WARNING: The following options in your Permissions::Role.has_many :users declaration are deprecated: :uniq. Please use a scope block instead. For example, the following:



    has_many :spam_comments, conditions: { spam: true }, class_name: 'Comment'



should be rewritten as the following:



    has_many :spam_comments, -> { where spam: true }, class_name: 'Comment'

. (called from <class:Role> at /home/travis/build/Liaison-Intl/WebAdMIT/app/models/permissions/role.rb:8)

DEPRECATION WARNING: The following options in your Permissions::Role.has_many :right_assignments declaration are deprecated: :uniq,:include. Please use a scope block instead. For example, the following:



    has_many :spam_comments, conditions: { spam: true }, class_name: 'Comment'



should be rewritten as the following:



    has_many :spam_comments, -> { where spam: true }, class_name: 'Comment'

. (called from <class:Role> at /home/travis/build/Liaison-Intl/WebAdMIT/app/models/permissions/role.rb:10)

DEPRECATION WARNING: The following options in your Permissions::Role.has_many :rights declaration are deprecated: :uniq. Please use a scope block instead. For example, the following:



    has_many :spam_comments, conditions: { spam: true }, class_name: 'Comment'



should be rewritten as the following:



    has_many :spam_comments, -> { where spam: true }, class_name: 'Comment'

. (called from <class:Role> at /home/travis/build/Liaison-Intl/WebAdMIT/app/models/permissions/role.rb:15)

DEPRECATION WARNING: The following options in your Permissions::Right.has_many :right_assignments declaration are deprecated: :uniq. Please use a scope block instead. For example, the following:



    has_many :spam_comments, conditions: { spam: true }, class_name: 'Comment'



should be rewritten as the following:



    has_many :spam_comments, -> { where spam: true }, class_name: 'Comment'

. (called from <class:Right> at /home/travis/build/Liaison-Intl/WebAdMIT/app/models/permissions/right.rb:5)

DEPRECATION WARNING: The following options in your Permissions::Right.has_many :roles declaration are deprecated: :uniq. Please use a scope block instead. For example, the following:



    has_many :spam_comments, conditions: { spam: true }, class_name: 'Comment'



should be rewritten as the following:



    has_many :spam_comments, -> { where spam: true }, class_name: 'Comment'

. (called from <class:Right> at /home/travis/build/Liaison-Intl/WebAdMIT/app/models/permissions/right.rb:6)

DEPRECATION WARNING: [paperclip] [deprecation] AWS SDK v1 has been deprecated in paperclip 5. Please consider upgrading to AWS 2 before upgrading paperclip. (called from <class:Photo> at /home/travis/build/Liaison-Intl/WebAdMIT/app/models/photo.rb:2)

DEPRECATION WARNING: [paperclip] [deprecation] Rails 3.2 and 4.1 are unsupported as of Rails 5 release. Please upgrade to Rails 4.2 before upgrading paperclip. (called from <class:Photo> at /home/travis/build/Liaison-Intl/WebAdMIT/app/models/photo.rb:2)

DEPRECATION WARNING: The following options in your RequirementBase.has_many :criteria declaration are deprecated: :order. Please use a scope block instead. For example, the following:



    has_many :spam_comments, conditions: { spam: true }, class_name: 'Comment'



should be rewritten as the following:



    has_many :spam_comments, -> { where spam: true }, class_name: 'Comment'

. (called from <class:RequirementBase> at /home/travis/build/Liaison-Intl/WebAdMIT/app/models/requirement_base.rb:17)

DEPRECATION WARNING: The following options in your RequirementBase.has_many :programs declaration are deprecated: :uniq. Please use a scope block instead. For example, the following:



    has_many :spam_comments, conditions: { spam: true }, class_name: 'Comment'



should be rewritten as the following:



    has_many :spam_comments, -> { where spam: true }, class_name: 'Comment'

. (called from <class:RequirementBase> at /home/travis/build/Liaison-Intl/WebAdMIT/app/models/requirement_base.rb:28)

DEPRECATION WARNING: The following options in your PtCollege.has_one :pt_college_detail declaration are deprecated: :readonly. Please use a scope block instead. For example, the following:



    has_many :spam_comments, conditions: { spam: true }, class_name: 'Comment'



should be rewritten as the following:



    has_many :spam_comments, -> { where spam: true }, class_name: 'Comment'

. (called from <class:PtCollege> at /home/travis/build/Liaison-Intl/WebAdMIT/app/models/pt_college.rb:9)

DEPRECATION WARNING: The following options in your Reports::DataLoaders::PrimaryCollegeLoader.has_many :college_attendeds declaration are deprecated: :conditions. Please use a scope block instead. For example, the following:



    has_many :spam_comments, conditions: { spam: true }, class_name: 'Comment'



should be rewritten as the following:



    has_many :spam_comments, -> { where spam: true }, class_name: 'Comment'

. (called from <class:PrimaryCollegeLoader> at /home/travis/build/Liaison-Intl/WebAdMIT/app/models/reports/data_loaders/primary_college_loader.rb:16)

DEPRECATION WARNING: The following options in your Reports::DataLoaders::PrimaryCollegeLoader.has_many :applicants declaration are deprecated: :conditions. Please use a scope block instead. For example, the following:



    has_many :spam_comments, conditions: { spam: true }, class_name: 'Comment'



should be rewritten as the following:



    has_many :spam_comments, -> { where spam: true }, class_name: 'Comment'

. (called from <class:PrimaryCollegeLoader> at /home/travis/build/Liaison-Intl/WebAdMIT/app/models/reports/data_loaders/primary_college_loader.rb:18)

DEPRECATION WARNING: The following options in your Scoring::PointTable.has_many :scoring_models declaration are deprecated: :uniq. Please use a scope block instead. For example, the following:



    has_many :spam_comments, conditions: { spam: true }, class_name: 'Comment'



should be rewritten as the following:



    has_many :spam_comments, -> { where spam: true }, class_name: 'Comment'

. (called from <class:PointTable> at /home/travis/build/Liaison-Intl/WebAdMIT/app/models/scoring/point_table.rb:20)

DEPRECATION WARNING: The following options in your Scoring::PointTable.has_many :entries declaration are deprecated: :include. Please use a scope block instead. For example, the following:



    has_many :spam_comments, conditions: { spam: true }, class_name: 'Comment'



should be rewritten as the following:



    has_many :spam_comments, -> { where spam: true }, class_name: 'Comment'

. (called from <class:PointTable> at /home/travis/build/Liaison-Intl/WebAdMIT/app/models/scoring/point_table.rb:23)

DEPRECATION WARNING: The following options in your Scoring::ScoringModel.has_many :programs declaration are deprecated: :uniq. Please use a scope block instead. For example, the following:



    has_many :spam_comments, conditions: { spam: true }, class_name: 'Comment'



should be rewritten as the following:



    has_many :spam_comments, -> { where spam: true }, class_name: 'Comment'

. (called from <class:ScoringModel> at /home/travis/build/Liaison-Intl/WebAdMIT/app/models/scoring/scoring_model.rb:100)

DEPRECATION WARNING: The following options in your User.has_many :programs declaration are deprecated: :uniq. Please use a scope block instead. For example, the following:



    has_many :spam_comments, conditions: { spam: true }, class_name: 'Comment'



should be rewritten as the following:



    has_many :spam_comments, -> { where spam: true }, class_name: 'Comment'

. (called from included at /home/travis/build/Liaison-Intl/WebAdMIT/app/models/permissions/user_refactor_temporary_methods.rb:22)

DEPRECATION WARNING: [paperclip] [deprecation] AWS SDK v1 has been deprecated in paperclip 5. Please consider upgrading to AWS 2 before upgrading paperclip. (called from <class:ViewReportFile> at /home/travis/build/Liaison-Intl/WebAdMIT/app/models/view_report_file.rb:12)

DEPRECATION WARNING: [paperclip] [deprecation] Rails 3.2 and 4.1 are unsupported as of Rails 5 release. Please upgrade to Rails 4.2 before upgrading paperclip. (called from <class:ViewReportFile> at /home/travis/build/Liaison-Intl/WebAdMIT/app/models/view_report_file.rb:12)

You are using WebMock 1.19.0. VCR 2.8.0 has been tested against WebMock >= 1.8.0, < 1.16, and you are using a newer version. If you experience VCR issues, consider downgrading WebMock as it may fix it.

[1mLoaded Suite test/factories/tests,test/factories,test,test/models/tests,test/models/etl_updater,test/controllers/api/v1/tests,test/views/users,test/views/layouts,test/views/applicants/experiences,test/views/applicants/designations,test/workers,test/workers/pdf_manager,test/workers/documents,test/presenters,test/presenters/tabs,test/presenters/search,test/presenters/applicant_details,test/presenters/recent_files,test/presenters/applicants,test/db,test/services,test/services/parsers,test/services/cas3,test/config,test/factories/animal_experience,test/factories/applicant_gateway,test/factories/scoring,test/factories/pdf_manager,test/factories/permissions,test/factories/decision,test/factories/email,test/factories/tests/scores,test/factories/medical_training,test/factories/config_portal,test/factories/global_lookups,test/factories/lookups,test/factories/documents,test/factories/advisor,test/factories/applicant_supplied_question_sets,test/factories/interviews,test/factories/integration,test/support,test/support/matchers,test/support/page_objects,test/support/integration,test/support/integration/applicants,test/mailers,test/fields,test/fields/exports,test/requests/api/v1,test/requests,test/decorators,test/decorators/onboarding,test/decorators/admin,test/decorators/admin/lookups,test/queries,test/routes,test/routes/scoring,test/routes/liaison_staff,test/routes/api/v2,test/routes/api/v1/applicant_gateway,test/routes/api/v1,test/routes/onboarding,test/routes/onboarding/cas_identifiers,test/routes/admin/associations,test/routes/admin,test/routes/applicants,test/shared_assertions,test/shared_assertions/gpa_overview_panel,test/shared_assertions/recent_files,test/shared_assertions/standardized_tests_panel,test/models,test/models/assignments,test/models/views,test/models/applicant_gateway,test/models/initializers,test/models/tabs,test/models/scoring,test/models/scoring/field_fetcher,test/models/scoring/field_fetcher/field_record,test/models/pdf_manager,test/models/permissions,test/models/course,test/models/transferable,test/models/decision,test/models/background_check,test/models/read_only,test/models/email,test/models/email/template,test/models/etl_deleters,test/models/etl_deleters/certifications,test/models/etl_deleters/experiences,test/models/etl_deleters/honors_and_awards,test/models/direct_applicants,test/models/diplomas,test/models/lists,test/models/tests/scores,test/models/fields,test/models/fields/transformations,test/models/fields/operators,test/models/fields/types,test/models/exports,test/models/exports/formatter,test/models/cas,test/models/config_portal/applicant_gateway,test/models/config_portal,test/models/global_lookups,test/models/lookups,test/models/config_loader,test/models/documents,test/models/etl_loader,test/models/advisor,test/models/visual_analytics,test/models/loader,test/models/interviews,test/models/foreign_evaluation,test/models/reports,test/models/reports/colleges_attended_with_degrees,test/models/reports/evaluations,test/models/reports/degrees,test/models/reports/oat_comparative,test/models/reports/schools_attended_with_degrees,test/models/reports/gre_by_gender,test/models/reports/evaluator_report,test/models/reports/colleges_attended,test/models/reports/data_loaders,test/models/reports/gre_comparative,test/models/reports/mcat_official_after_jan_2015,test/models/reports/mcat_official,test/models/reports/dat_official,test/models/reports/pcat_official,test/models/medical_trainings,test/models/helpers,test/models/helpers/scoring,test/models/helpers/admin,test/controllers,test/controllers/pdf_manager,test/controllers/search,test/controllers/settings_transfer,test/controllers/lists,test/controllers/api/v2,test/controllers/api/v1,test/controllers/api/v1/applicant_gateway,test/controllers/api/v1/wes_gpas,test/controllers/api/v1/foreign_evaluations,test/controllers/api/v1/certifications,test/controllers/api/v1/diplomas,test/controllers/api/v1/experiences,test/controllers/api/v1/field_manager,test/controllers/api/v1/field_manager/by_identifier,test/controllers/api/v1/honors_and_awards,test/controllers/api/v1/by_identifier/applicant_gateway,test/controllers/api/v1/certiphi,test/controllers/api/v1/medical_trainings,test/controllers/controller_helpers,test/controllers/search_managers,test/controllers/advisor,test/controllers/users,test/controllers/interviews,test/controllers/admin,test/controllers/admin/lookups,test/controllers/reports,test/controllers/applicants,test/lib,test/lib/tableau,test/lib/cas3_logs/api,test/lib/scoring/field_fetcher/field_record,test/lib/pdf_manager,test/lib/pdf_manager/api,test/lib/config_cloner,test/lib/google,test/lib/export_filter,test/lib/settings_transfer/settings_bundler,test/lib/etl/field_helpers,test/lib/etl,test/lib/lists,test/lib/active_field,test/lib/active_field/filter,test/lib/active_field/view,test/lib/fields/accessibility_scope_policies,test/lib/fields,test/lib/paperclip_processors,test/lib/validators,test/lib/common_tasks/data_manipulation,test/lib/cas3,test/lib/export,test/lib/field_renderer,test/lib/field_renderer/integration,test/lib/config_portal,test/lib/config_portal/api,test/lib/gpa_bundler,test/lib/documents,test/lib/authlogic_shibboleth,test/lib/tasks,test/lib/tasks/data,test/lib/tasks/cron,test/lib/tasks/releases/5.25,test/lib/tasks/releases/5.82,test/lib/tasks/releases/5.73,test/lib/tasks/releases/5.46.3,test/lib/tasks/releases/5.34,test/lib/tasks/releases/5.85,test/lib/tasks/helpers,test/lib/webadmit,test/lib/benchmarking,test/lib/reports,test/integration,test/integration/scoring,test/integration/pdf_manager,test/integration/list_manager,test/integration/list_manager/list_actions,test/integration/liaison_staff,test/integration/direct_applicants,test/integration/search,test/integration/lists,test/integration/applicant_details/education,test/integration/applicant_details/applicant_gateway,test/integration/applicant_details/evaluations,test/integration/applicant_details,test/integration/applicant_details/contact,test/integration/applicant_details/applicant_reported_other_tests,test/integration/applicant_details/socioeconomic_indicators,test/integration/applicant_details/gpa_overview,test/integration/applicant_details/standardized_tests,test/integration/applicant_details/custom_questions,test/integration/applicant_details/residencies_and_fellowships,test/integration/applicant_details/official_mcats_before_jan_31_2015,test/integration/applicant_details/infractions,test/integration/applicant_details/conferences,test/integration/applicant_details/licenses_certifications,test/integration/applicant_details/references,test/integration/applicant_details/experiences,test/integration/applicant_details/high_school_transcripts,test/integration/applicant_details/achievements,test/integration/applicant_details/personal_statement,test/integration/applicant_details/personal_information,test/integration/applicant_details/essays,test/integration/applicant_details/designations,test/integration/applicant_details/documents,test/integration/applicant_details/transcripts,test/integration/applicant_details/official_mcats_after_jan_31_2015,test/integration/applicant_details/cas_custom_questions,test/integration/applicant_details/supplemental_questions,test/integration/applicant_details/advisor_user_identity,test/integration/advisor,test/integration/users,test/integration/programs,test/integration/interviews,test/integration/admin,test/integration/admin/lookups,test/integration/reports,test/integration/search_assignments,test/integration/recent_files,test/integration/institution_user_identity,test/integration/organization_user_identity,test/helpers,test/helpers/shared,test/helpers/applicant,test/helpers/lists,test/helpers/export,test/helpers/admin,test/helpers/reports,test/helpers/applicants,test/serializers/api/v1[0m



Started at Aug 15, 2017 at 8:22 PM w/ seed 64529.



DEPRECATION WARNING: You didn't set config.secret_key_base. Read the upgrade documentation to learn more about this new config option. (called from service at /home/travis/.rvm/rubies/ruby-1.9.3-p551/lib/ruby/1.9.1/webrick/httpserver.rb:138)

[32m.[0m[32m.[0m[32m.[0m[32m.[0m[32m.[0m[32m.[0m[32m.[0m[32m.[0m[32m.[0m[32m.[0m[32m.[0m[32m.[0m[32m.[0m[32m.[0m[32m.[0m[32m.[0m[32m.[0m[32m.[0m[32m.[0m[32m.[0m[32m.[0m[32m.[0m[32m.[0m[32m.[0mDEPRECATION WARNING: Relation#all is deprecated. If you want to eager-load a relation, you can call #load (e.g. `Post.where(published: true).load`). If you want to get an array of records from a relation, you can call #to_a (e.g. `Post.where(published: true).to_a`). (called from _app_views_layouts__advisor_sidebar_haml__4578835400478025503_343596640 at /home/travis/build/Liaison-Intl/WebAdMIT/app/views/layouts/_advisor_sidebar.haml:12)

[32m.[0mDEPRECATION WARNING: It looks like you are eager loading table(s) (one of: scoring_models, scoring_model_assignments, programs) that are referenced in a string SQL snippet. For example:



    Post.includes(:comments).where("comments.title = 'foo'")



Currently, Active Record recognizes the table in the string, and knows to JOIN the comments table to the query, rather than loading comments in a separate query. However, doing this without writing a full-blown SQL parser is inherently flawed. Since we don't want to write an SQL parser, we are removing this functionality. From now on, you must explicitly tell Active Record when you are referencing a table from a string:



    Post.includes(:comments).where("comments.title = 'foo'").references(:comments)



If you don't rely on implicit join references you can disable the feature entirely by setting `config.active_record.disable_implicit_join_references = true`. (called from score_for_scoring_models at /home/travis/build/Liaison-Intl/WebAdMIT/app/models/scoring/scorer.rb:50)

DEPRECATION WARNING: It looks like you are eager loading table(s) (one of: designations, programs, user_identity_programs) that are referenced in a string SQL snippet. For example:



    Post.includes(:comments).where("comments.title = 'foo'")



Currently, Active Record recognizes the table in the string, and knows to JOIN the comments table to the query, rather than loading comments in a separate query. However, doing this without writing a full-blown SQL parser is inherently flawed. Since we don't want to write an SQL parser, we are removing this functionality. From now on, you must explicitly tell Active Record when you are referencing a table from a string:



    Post.includes(:comments).where("comments.title = 'foo'").references(:comments)



If you don't rely on implicit join references you can disable the feature entirely by setting `config.active_record.disable_implicit_join_references = true`. (called from designations_received? at /home/travis/build/Liaison-Intl/WebAdMIT/app/models/applicant.rb:941)

[32m.[0mDEPRECATION WARNING: It looks like you are eager loading table(s) (one of: scoring_models, scoring_model_assignments, programs) that are referenced in a string SQL snippet. For example:



    Post.includes(:comments).where("comments.title = 'foo'")



Currently, Active Record recognizes the table in the string, and knows to JOIN the comments table to the query, rather than loading comments in a separate query. However, doing this without writing a full-blown SQL parser is inherently flawed. Since we don't want to write an SQL parser, we are removing this functionality. From now on, you must explicitly tell Active Record when you are referencing a table from a string:



    Post.includes(:comments).where("comments.title = 'foo'").references(:comments)



If you don't rely on implicit join references you can disable the feature entirely by setting `config.active_record.disable_implicit_join_references = true`. (called from score_for_scoring_models at /home/travis/build/Liaison-Intl/WebAdMIT/app/models/scoring/scorer.rb:50)

DEPRECATION WARNING: It looks like you are eager loading table(s) (one of: designations, programs, user_identity_programs) that are referenced in a string SQL snippet. For example:



    Post.includes(:comments).where("comments.title = 'foo'")



Currently, Active Record recognizes the table in the string, and knows to JOIN the comments table to the query, rather than loading comments in a separate query. However, doing this without writing a full-blown SQL parser is inherently flawed. Since we don't want to write an SQL parser, we are removing this functionality. From now on, you must explicitly tell Active Record when you are referencing a table from a string:



    Post.includes(:comments).where("comments.title = 'foo'").references(:comments)



If you don't rely on implicit join references you can disable the feature entirely by setting `config.active_record.disable_implicit_join_references = true`. (called from designations_received? at /home/travis/build/Liaison-Intl/WebAdMIT/app/models/applicant.rb:941)

[32m.[0mDEPRECATION WARNING: It looks like you are eager loading table(s) (one of: scoring_models, scoring_model_assignments, programs) that are referenced in a string SQL snippet. For example:



    Post.includes(:comments).where("comments.title = 'foo'")



Currently, Active Record recognizes the table in the string, and knows to JOIN the comments table to the query, rather than loading comments in a separate query. However, doing this without writing a full-blown SQL parser is inherently flawed. Since we don't want to write an SQL parser, we are removing this functionality. From now on, you must explicitly tell Active Record when you are referencing a table from a string:



    Post.includes(:comments).where("comments.title = 'foo'").references(:comments)



If you don't rely on implicit join references you can disable the feature entirely by setting `config.active_record.disable_implicit_join_references = true`. (called from score_for_scoring_models at /home/travis/build/Liaison-Intl/WebAdMIT/app/models/scoring/scorer.rb:50)

DEPRECATION WARNING: It looks like you are eager loading table(s) (one of: designations, programs, user_identity_programs) that are referenced in a string SQL snippet. For example:



    Post.includes(:comments).where("comments.title = 'foo'")



Currently, Active Record recognizes the table in the string, and knows to JOIN the comments table to the query, rather than loading comments in a separate query. However, doing this without writing a full-blown SQL parser is inherently flawed. Since we don't want to write an SQL parser, we are removing this functionality. From now on, you must explicitly tell Active Record when you are referencing a table from a string:



    Post.includes(:comments).where("comments.title = 'foo'").references(:comments)



If you don't rely on implicit join references you can disable the feature entirely by setting `config.active_record.disable_implicit_join_references = true`. (called from designations_received? at /home/travis/build/Liaison-Intl/WebAdMIT/app/models/applicant.rb:941)

[32m.[0mDEPRECATION WARNING: It looks like you are eager loading table(s) (one of: scoring_models, scoring_model_assignments, programs) that are referenced in a string SQL snippet. For example:



    Post.includes(:comments).where("comments.title = 'foo'")



Currently, Active Record recognizes the table in the string, and knows to JOIN the comments table to the query, rather than loading comments in a separate query. However, doing this without writing a full-blown SQL parser is inherently flawed. Since we don't want to write an SQL parser, we are removing this functionality. From now on, you must explicitly tell Active Record when you are referencing a table from a string:



    Post.includes(:comments).where("comments.title = 'foo'").references(:comments)



If you don't rely on implicit join references you can disable the feature entirely by setting `config.active_record.disable_implicit_join_references = true`. (called from score_for_scoring_models at /home/travis/build/Liaison-Intl/WebAdMIT/app/models/scoring/scorer.rb:50)

DEPRECATION WARNING: It looks like you are eager loading table(s) (one of: designations, programs, user_identity_programs) that are referenced in a string SQL snippet. For example:



    Post.includes(:comments).where("comments.title = 'foo'")



Currently, Active Record recognizes the table in the string, and knows to JOIN the comments table to the query, rather than loading comments in a separate query. However, doing this without writing a full-blown SQL parser is inherently flawed. Since we don't want to write an SQL parser, we are removing this functionality. From now on, you must explicitly tell Active Record when you are referencing a table from a string:



    Post.includes(:comments).where("comments.title = 'foo'").references(:comments)



If you don't rely on implicit join references you can disable the feature entirely by setting `config.active_record.disable_implicit_join_references = true`. (called from designations_received? at /home/travis/build/Liaison-Intl/WebAdMIT/app/models/applicant.rb:941)

[32m.[0mDEPRECATION WARNING: It looks like you are eager loading table(s) (one of: scoring_models, scoring_model_assignments, programs) that are referenced in a string SQL snippet. For example:



    Post.includes(:comments).where("comments.title = 'foo'")



Currently, Active Record recognizes the table in the string, and knows to JOIN the comments table to the query, rather than loading comments in a separate query. However, doing this without writing a full-blown SQL parser is inherently flawed. Since we don't want to write an SQL parser, we are removing this functionality. From now on, you must explicitly tell Active Record when you are referencing a table from a string:



    Post.includes(:comments).where("comments.title = 'foo'").references(:comments)



If you don't rely on implicit join references you can disable the feature entirely by setting `config.active_record.disable_implicit_join_references = true`. (called from score_for_scoring_models at /home/travis/build/Liaison-Intl/WebAdMIT/app/models/scoring/scorer.rb:50)

DEPRECATION WARNING: It looks like you are eager loading table(s) (one of: designations, programs, user_identity_programs) that are referenced in a string SQL snippet. For example:



    Post.includes(:comments).where("comments.title = 'foo'")



Currently, Active Record recognizes the table in the string, and knows to JOIN the comments table to the query, rather than loading comments in a separate query. However, doing this without writing a full-blown SQL parser is inherently flawed. Since we don't want to write an SQL parser, we are removing this functionality. From now on, you must explicitly tell Active Record when you are referencing a table from a string:



    Post.includes(:comments).where("comments.title = 'foo'").references(:comments)



If you don't rely on implicit join references you can disable the feature entirely by setting `config.active_record.disable_implicit_join_references = true`. (called from designations_received? at /home/travis/build/Liaison-Intl/WebAdMIT/app/models/applicant.rb:941)

[32m.[0mDEPRECATION WARNING: It looks like you are eager loading table(s) (one of: scoring_models, scoring_model_assignments, programs) that are referenced in a string SQL snippet. For example:



    Post.includes(:comments).where("comments.title = 'foo'")



Currently, Active Record recognizes the table in the string, and knows to JOIN the comments table to the query, rather than loading comments in a separate query. However, doing this without writing a full-blown SQL parser is inherently flawed. Since we don't want to write an SQL parser, we are removing this functionality. From now on, you must explicitly tell Active Record when you are referencing a table from a string:



    Post.includes(:comments).where("comments.title = 'foo'").references(:comments)



If you don't rely on implicit join references you can disable the feature entirely by setting `config.active_record.disable_implicit_join_references = true`. (called from score_for_scoring_models at /home/travis/build/Liaison-Intl/WebAdMIT/app/models/scoring/scorer.rb:50)

DEPRECATION WARNING: It looks like you are eager loading table(s) (one of: designations, programs, user_identity_programs) that are referenced in a string SQL snippet. For example:



    Post.includes(:comments).where("comments.title = 'foo'")



Currently, Active Record recognizes the table in the string, and knows to JOIN the comments table to the query, rather than loading comments in a separate query. However, doing this without writing a full-blown SQL parser is inherently flawed. Since we don't want to write an SQL parser, we are removing this functionality. From now on, you must explicitly tell Active Record when you are referencing a table from a string:



    Post.includes(:comments).where("comments.title = 'foo'").references(:comments)



If you don't rely on implicit join references you can disable the feature entirely by setting `config.active_record.disable_implicit_join_references = true`. (called from designations_received? at /home/travis/build/Liaison-Intl/WebAdMIT/app/models/applicant.rb:941)

[32m.[0mDEPRECATION WARNING: It looks like you are eager loading table(s) (one of: scoring_models, scoring_model_assignments, programs) that are referenced in a string SQL snippet. For example:



    Post.includes(:comments).where("comments.title = 'foo'")



Currently, Active Record recognizes the table in the string, and knows to JOIN the comments table to the query, rather than loading comments in a separate query. However, doing this without writing a full-blown SQL parser is inherently flawed. Since we don't want to write an SQL parser, we are removing this functionality. From now on, you must explicitly tell Active Record when you are referencing a table from a string:



    Post.includes(:comments).where("comments.title = 'foo'").references(:comments)



If you don't rely on implicit join references you can disable the feature entirely by setting `config.active_record.disable_implicit_join_references = true`. (called from score_for_scoring_models at /home/travis/build/Liaison-Intl/WebAdMIT/app/models/scoring/scorer.rb:50)

DEPRECATION WARNING: It looks like you are eager loading table(s) (one of: designations, programs, user_identity_programs) that are referenced in a string SQL snippet. For example:



    Post.includes(:comments).where("comments.title = 'foo'")



Currently, Active Record recognizes the table in the string, and knows to JOIN the comments table to the query, rather than loading comments in a separate query. However, doing this without writing a full-blown SQL parser is inherently flawed. Since we don't want to write an SQL parser, we are removing this functionality. From now on, you must explicitly tell Active Record when you are referencing a table from a string:



    Post.includes(:comments).where("comments.title = 'foo'").references(:comments)



If you don't rely on implicit join references you can disable the feature entirely by setting `config.active_record.disable_implicit_join_references = true`. (called from designations_received? at /home/travis/build/Liaison-Intl/WebAdMIT/app/models/applicant.rb:941)

[32m.[0mDEPRECATION WARNING: It looks like you are eager loading table(s) (one of: scoring_models, scoring_model_assignments, programs) that are referenced in a string SQL snippet. For example:



    Post.includes(:comments).where("comments.title = 'foo'")



Currently, Active Record recognizes the table in the string, and knows to JOIN the comments table to the query, rather than loading comments in a separate query. However, doing this without writing a full-blown SQL parser is inherently flawed. Since we don't want to write an SQL parser, we are removing this functionality. From now on, you must explicitly tell Active Record when you are referencing a table from a string:



    Post.includes(:comments).where("comments.title = 'foo'").references(:comments)



If you don't rely on implicit join references you can disable the feature entirely by setting `config.active_record.disable_implicit_join_references = true`. (called from score_for_scoring_models at /home/travis/build/Liaison-Intl/WebAdMIT/app/models/scoring/scorer.rb:50)

DEPRECATION WARNING: It looks like you are eager loading table(s) (one of: designations, programs, user_identity_programs) that are referenced in a string SQL snippet. For example:



    Post.includes(:comments).where("comments.title = 'foo'")



Currently, Active Record recognizes the table in the string, and knows to JOIN the comments table to the query, rather than loading comments in a separate query. However, doing this without writing a full-blown SQL parser is inherently flawed. Since we don't want to write an SQL parser, we are removing this functionality. From now on, you must explicitly tell Active Record when you are referencing a table from a string:



    Post.includes(:comments).where("comments.title = 'foo'").references(:comments)



If you don't rely on implicit join references you can disable the feature entirely by setting `config.active_record.disable_implicit_join_references = true`. (called from designations_received? at /home/travis/build/Liaison-Intl/WebAdMIT/app/models/applicant.rb:941)

[32m.[0mDEPRECATION WARNING: It looks like you are eager loading table(s) (one of: scoring_models, scoring_model_assignments, programs) that are referenced in a string SQL snippet. For example:



    Post.includes(:comments).where("comments.title = 'foo'")



Currently, Active Record recognizes the table in the string, and knows to JOIN the comments table to the query, rather than loading comments in a separate query. However, doing this without writing a full-blown SQL parser is inherently flawed. Since we don't want to write an SQL parser, we are removing this functionality. From now on, you must explicitly tell Active Record when you are referencing a table from a string:



    Post.includes(:comments).where("comments.title = 'foo'").references(:comments)



If you don't rely on implicit join references you can disable the feature entirely by setting `config.active_record.disable_implicit_join_references = true`. (called from score_for_scoring_models at /home/travis/build/Liaison-Intl/WebAdMIT/app/models/scoring/scorer.rb:50)

DEPRECATION WARNING: It looks like you are eager loading table(s) (one of: designations, programs, user_identity_programs) that are referenced in a string SQL snippet. For example:



    Post.includes(:comments).where("comments.title = 'foo'")



Currently, Active Record recognizes the table in the string, and knows to JOIN the comments table to the query, rather than loading comments in a separate query. However, doing this without writing a full-blown SQL parser is inherently flawed. Since we don't want to write an SQL parser, we are removing this functionality. From now on, you must explicitly tell Active Record when you are referencing a table from a string:



    Post.includes(:comments).where("comments.title = 'foo'").references(:comments)



If you don't rely on implicit join references you can disable the feature entirely by setting `config.active_record.disable_implicit_join_references = true`. (called from designations_received? at /home/travis/build/Liaison-Intl/WebAdMIT/app/models/applicant.rb:941)

[32m.[0mDEPRECATION WARNING: It looks like you are eager loading table(s) (one of: scoring_models, scoring_model_assignments, programs) that are referenced in a string SQL snippet. For example:



    Post.includes(:comments).where("comments.title = 'foo'")



Currently, Active Record recognizes the table in the string, and knows to JOIN the comments table to the query, rather than loading comments in a separate query. However, doing this without writing a full-blown SQL parser is inherently flawed. Since we don't want to write an SQL parser, we are removing this functionality. From now on, you must explicitly tell Active Record when you are referencing a table from a string:



    Post.includes(:comments).where("comments.title = 'foo'").references(:comments)



If you don't rely on implicit join references you can disable the feature entirely by setting `config.active_record.disable_implicit_join_references = true`. (called from score_for_scoring_models at /home/travis/build/Liaison-Intl/WebAdMIT/app/models/scoring/scorer.rb:50)

DEPRECATION WARNING: It looks like you are eager loading table(s) (one of: designations, programs, user_identity_programs) that are referenced in a string SQL snippet. For example:



    Post.includes(:comments).where("comments.title = 'foo'")



Currently, Active Record recognizes the table in the string, and knows to JOIN the comments table to the query, rather than loading comments in a separate query. However, doing this without writing a full-blown SQL parser is inherently flawed. Since we don't want to write an SQL parser, we are removing this functionality. From now on, you must explicitly tell Active Record when you are referencing a table from a string:



    Post.includes(:comments).where("comments.title = 'foo'").references(:comments)



If you don't rely on implicit join references you can disable the feature entirely by setting `config.active_record.disable_implicit_join_references = true`. (called from designations_received? at /home/travis/build/Liaison-Intl/WebAdMIT/app/models/applicant.rb:941)

[32m.[0mDEPRECATION WARNING: It looks like you are eager loading table(s) (one of: scoring_models, scoring_model_assignments, programs) that are referenced in a string SQL snippet. For example:



    Post.includes(:comments).where("comments.title = 'foo'")



Currently, Active Record recognizes the table in the string, and knows to JOIN the comments table to the query, rather than loading comments in a separate query. However, doing this without writing a full-blown SQL parser is inherently flawed. Since we don't want to write an SQL parser, we are removing this functionality. From now on, you must explicitly tell Active Record when you are referencing a table from a string:



    Post.includes(:comments).where("comments.title = 'foo'").references(:comments)



If you don't rely on implicit join references you can disable the feature entirely by setting `config.active_record.disable_implicit_join_references = true`. (called from score_for_scoring_models at /home/travis/build/Liaison-Intl/WebAdMIT/app/models/scoring/scorer.rb:50)

DEPRECATION WARNING: It looks like you are eager loading table(s) (one of: designations, programs, user_identity_programs) that are referenced in a string SQL snippet. For example:



    Post.includes(:comments).where("comments.title = 'foo'")



Currently, Active Record recognizes the table in the string, and knows to JOIN the comments table to the query, rather than loading comments in a separate query. However, doing this without writing a full-blown SQL parser is inherently flawed. Since we don't want to write an SQL parser, we are removing this functionality. From now on, you must explicitly tell Active Record when you are referencing a table from a string:



    Post.includes(:comments).where("comments.title = 'foo'").references(:comments)



If you don't rely on implicit join references you can disable the feature entirely by setting `config.active_record.disable_implicit_join_references = true`. (called from designations_received? at /home/travis/build/Liaison-Intl/WebAdMIT/app/models/applicant.rb:941)

[32m.[0mDEPRECATION WARNING: It looks like you are eager loading table(s) (one of: scoring_models, scoring_model_assignments, programs) that are referenced in a string SQL snippet. For example:



    Post.includes(:comments).where("comments.title = 'foo'")



Currently, Active Record recognizes the table in the string, and knows to JOIN the comments table to the query, rather than loading comments in a separate query. However, doing this without writing a full-blown SQL parser is inherently flawed. Since we don't want to write an SQL parser, we are removing this functionality. From now on, you must explicitly tell Active Record when you are referencing a table from a string:



    Post.includes(:comments).where("comments.title = 'foo'").references(:comments)



If you don't rely on implicit join references you can disable the feature entirely by setting `config.active_record.disable_implicit_join_references = true`. (called from score_for_scoring_models at /home/travis/build/Liaison-Intl/WebAdMIT/app/models/scoring/scorer.rb:50)

DEPRECATION WARNING: It looks like you are eager loading table(s) (one of: designations, programs, user_identity_programs) that are referenced in a string SQL snippet. For example:



    Post.includes(:comments).where("comments.title = 'foo'")



Currently, Active Record recognizes the table in the string, and knows to JOIN the comments table to the query, rather than loading comments in a separate query. However, doing this without writing a full-blown SQL parser is inherently flawed. Since we don't want to write an SQL parser, we are removing this functionality. From now on, you must explicitly tell Active Record when you are referencing a table from a string:



    Post.includes(:comments).where("comments.title = 'foo'").references(:comments)



If you don't rely on implicit join references you can disable the feature entirely by setting `config.active_record.disable_implicit_join_references = true`. (called from designations_received? at /home/travis/build/Liaison-Intl/WebAdMIT/app/models/applicant.rb:941)

[32m.[0mDEPRECATION WARNING: It looks like you are eager loading table(s) (one of: scoring_models, scoring_model_assignments, programs) that are referenced in a string SQL snippet. For example:



    Post.includes(:comments).where("comments.title = 'foo'")



Currently, Active Record recognizes the table in the string, and knows to JOIN the comments table to the query, rather than loading comments in a separate query. However, doing this without writing a full-blown SQL parser is inherently flawed. Since we don't want to write an SQL parser, we are removing this functionality. From now on, you must explicitly tell Active Record when you are referencing a table from a string:



    Post.includes(:comments).where("comments.title = 'foo'").references(:comments)



If you don't rely on implicit join references you can disable the feature entirely by setting `config.active_record.disable_implicit_join_references = true`. (called from score_for_scoring_models at /home/travis/build/Liaison-Intl/WebAdMIT/app/models/scoring/scorer.rb:50)

DEPRECATION WARNING: It looks like you are eager loading table(s) (one of: designations, programs, user_identity_programs) that are referenced in a string SQL snippet. For example:



    Post.includes(:comments).where("comments.title = 'foo'")



Currently, Active Record recognizes the table in the string, and knows to JOIN the comments table to the query, rather than loading comments in a separate query. However, doing this without writing a full-blown SQL parser is inherently flawed. Since we don't want to write an SQL parser, we are removing this functionality. From now on, you must explicitly tell Active Record when you are referencing a table from a string:



    Post.includes(:comments).where("comments.title = 'foo'").references(:comments)



If you don't rely on implicit join references you can disable the feature entirely by setting `config.active_record.disable_implicit_join_references = true`. (called from designations_received? at /home/travis/build/Liaison-Intl/WebAdMIT/app/models/applicant.rb:941)

[32m.[0mDEPRECATION WARNING: It looks like you are eager loading table(s) (one of: scoring_models, scoring_model_assignments, programs) that are referenced in a string SQL snippet. For example:



    Post.includes(:comments).where("comments.title = 'foo'")



Currently, Active Record recognizes the table in the string, and knows to JOIN the comments table to the query, rather than loading comments in a separate query. However, doing this without writing a full-blown SQL parser is inherently flawed. Since we don't want to write an SQL parser, we are removing this functionality. From now on, you must explicitly tell Active Record when you are referencing a table from a string:



    Post.includes(:comments).where("comments.title = 'foo'").references(:comments)



If you don't rely on implicit join references you can disable the feature entirely by setting `config.active_record.disable_implicit_join_references = true`. (called from score_for_scoring_models at /home/travis/build/Liaison-Intl/WebAdMIT/app/models/scoring/scorer.rb:50)

DEPRECATION WARNING: It looks like you are eager loading table(s) (one of: designations, programs, user_identity_programs) that are referenced in a string SQL snippet. For example:



    Post.includes(:comments).where("comments.title = 'foo'")



Currently, Active Record recognizes the table in the string, and knows to JOIN the comments table to the query, rather than loading comments in a separate query. However, doing this without writing a full-blown SQL parser is inherently flawed. Since we don't want to write an SQL parser, we are removing this functionality. From now on, you must explicitly tell Active Record when you are referencing a table from a string:



    Post.includes(:comments).where("comments.title = 'foo'").references(:comments)



If you don't rely on implicit join references you can disable the feature entirely by setting `config.active_record.disable_implicit_join_references = true`. (called from designations_received? at /home/travis/build/Liaison-Intl/WebAdMIT/app/models/applicant.rb:941)

[32m.[0mDEPRECATION WARNING: It looks like you are eager loading table(s) (one of: scoring_models, scoring_model_assignments, programs) that are referenced in a string SQL snippet. For example:



    Post.includes(:comments).where("comments.title = 'foo'")



Currently, Active Record recognizes the table in the string, and knows to JOIN the comments table to the query, rather than loading comments in a separate query. However, doing this without writing a full-blown SQL parser is inherently flawed. Since we don't want to write an SQL parser, we are removing this functionality. From now on, you must explicitly tell Active Record when you are referencing a table from a string:



    Post.includes(:comments).where("comments.title = 'foo'").references(:comments)



If you don't rely on implicit join references you can disable the feature entirely by setting `config.active_record.disable_implicit_join_references = true`. (called from score_for_scoring_models at /home/travis/build/Liaison-Intl/WebAdMIT/app/models/scoring/scorer.rb:50)

DEPRECATION WARNING: It looks like you are eager loading table(s) (one of: designations, programs, user_identity_programs) that are referenced in a string SQL snippet. For example:



    Post.includes(:comments).where("comments.title = 'foo'")



Currently, Active Record recognizes the table in the string, and knows to JOIN the comments table to the query, rather than loading comments in a separate query. However, doing this without writing a full-blown SQL parser is inherently flawed. Since we don't want to write an SQL parser, we are removing this functionality. From now on, you must explicitly tell Active Record when you are referencing a table from a string:



    Post.includes(:comments).where("comments.title = 'foo'").references(:comments)



If you don't rely on implicit join references you can disable the feature entirely by setting `config.active_record.disable_implicit_join_references = true`. (called from designations_received? at /home/travis/build/Liaison-Intl/WebAdMIT/app/models/applicant.rb:941)

[32m.[0mDEPRECATION WARNING: It looks like you are eager loading table(s) (one of: scoring_models, scoring_model_assignments, programs) that are referenced in a string SQL snippet. For example:



    Post.includes(:comments).where("comments.title = 'foo'")



Currently, Active Record recognizes the table in the string, and knows to JOIN the comments table to the query, rather than loading comments in a separate query. However, doing this without writing a full-blown SQL parser is inherently flawed. Since we don't want to write an SQL parser, we are removing this functionality. From now on, you must explicitly tell Active Record when you are referencing a table from a string:



    Post.includes(:comments).where("comments.title = 'foo'").references(:comments)



If you don't rely on implicit join references you can disable the feature entirely by setting `config.active_record.disable_implicit_join_references = true`. (called from score_for_scoring_models at /home/travis/build/Liaison-Intl/WebAdMIT/app/models/scoring/scorer.rb:50)

DEPRECATION WARNING: It looks like you are eager loading table(s) (one of: designations, programs, user_identity_programs) that are referenced in a string SQL snippet. For example:



    Post.includes(:comments).where("comments.title = 'foo'")



Currently, Active Record recognizes the table in the string, and knows to JOIN the comments table to the query, rather than loading comments in a separate query. However, doing this without writing a full-blown SQL parser is inherently flawed. Since we don't want to write an SQL parser, we are removing this functionality. From now on, you must explicitly tell Active Record when you are referencing a table from a string:



    Post.includes(:comments).where("comments.title = 'foo'").references(:comments)



If you don't rely on implicit join references you can disable the feature entirely by setting `config.active_record.disable_implicit_join_references = true`. (called from designations_received? at /home/travis/build/Liaison-Intl/WebAdMIT/app/models/applicant.rb:941)

[32m.[0mDEPRECATION WARNING: It looks like you are eager loading table(s) (one of: scoring_models, scoring_model_assignments, programs) that are referenced in a string SQL snippet. For example:



    Post.includes(:comments).where("comments.title = 'foo'")



Currently, Active Record recognizes the table in the string, and knows to JOIN the comments table to the query, rather than loading comments in a separate query. However, doing this without writing a full-blown SQL parser is inherently flawed. Since we don't want to write an SQL parser, we are removing this functionality. From now on, you must explicitly tell Active Record when you are referencing a table from a string:



    Post.includes(:comments).where("comments.title = 'foo'").references(:comments)



If you don't rely on implicit join references you can disable the feature entirely by setting `config.active_record.disable_implicit_join_references = true`. (called from score_for_scoring_models at /home/travis/build/Liaison-Intl/WebAdMIT/app/models/scoring/scorer.rb:50)

DEPRECATION WARNING: It looks like you are eager loading table(s) (one of: designations, programs, user_identity_programs) that are referenced in a string SQL snippet. For example:



    Post.includes(:comments).where("comments.title = 'foo'")



Currently, Active Record recognizes the table in the string, and knows to JOIN the comments table to the query, rather than loading comments in a separate query. However, doing this without writing a full-blown SQL parser is inherently flawed. Since we don't want to write an SQL parser, we are removing this functionality. From now on, you must explicitly tell Active Record when you are referencing a table from a string:



    Post.includes(:comments).where("comments.title = 'foo'").references(:comments)



If you don't rely on implicit join references you can disable the feature entirely by setting `config.active_record.disable_implicit_join_references = true`. (called from designations_received? at /home/travis/build/Liaison-Intl/WebAdMIT/app/models/applicant.rb:941)

[32m.[0mDEPRECATION WARNING: It looks like you are eager loading table(s) (one of: scoring_models, scoring_model_assignments, programs) that are referenced in a string SQL snippet. For example:



    Post.includes(:comments).where("comments.title = 'foo'")



Currently, Active Record recognizes the table in the string, and knows to JOIN the comments table to the query, rather than loading comments in a separate query. However, doing this without writing a full-blown SQL parser is inherently flawed. Since we don't want to write an SQL parser, we are removing this functionality. From now on, you must explicitly tell Active Record when you are referencing a table from a string:



    Post.includes(:comments).where("comments.title = 'foo'").references(:comments)



If you don't rely on implicit join references you can disable the feature entirely by setting `config.active_record.disable_implicit_join_references = true`. (called from score_for_scoring_models at /home/travis/build/Liaison-Intl/WebAdMIT/app/models/scoring/scorer.rb:50)

DEPRECATION WARNING: It looks like you are eager loading table(s) (one of: designations, programs, user_identity_programs) that are referenced in a string SQL snippet. For example:



    Post.includes(:comments).where("comments.title = 'foo'")



Currently, Active Record recognizes the table in the string, and knows to JOIN the comments table to the query, rather than loading comments in a separate query. However, doing this without writing a full-blown SQL parser is inherently flawed. Since we don't want to write an SQL parser, we are removing this functionality. From now on, you must explicitly tell Active Record when you are referencing a table from a string:



    Post.includes(:comments).where("comments.title = 'foo'").references(:comments)



If you don't rely on implicit join references you can disable the feature entirely by setting `config.active_record.disable_implicit_join_references = true`. (called from designations_received? at /home/travis/build/Liaison-Intl/WebAdMIT/app/models/applicant.rb:941)

[32m.[0mDEPRECATION WARNING: It looks like you are eager loading table(s) (one of: scoring_models, scoring_model_assignments, programs) that are referenced in a string SQL snippet. For example:



    Post.includes(:comments).where("comments.title = 'foo'")



Currently, Active Record recognizes the table in the string, and knows to JOIN the comments table to the query, rather than loading comments in a separate query. However, doing this without writing a full-blown SQL parser is inherently flawed. Since we don't want to write an SQL parser, we are removing this functionality. From now on, you must explicitly tell Active Record when you are referencing a table from a string:



    Post.includes(:comments).where("comments.title = 'foo'").references(:comments)



If you don't rely on implicit join references you can disable the feature entirely by setting `config.active_record.disable_implicit_join_references = true`. (called from score_for_scoring_models at /home/travis/build/Liaison-Intl/WebAdMIT/app/models/scoring/scorer.rb:50)

DEPRECATION WARNING: It looks like you are eager loading table(s) (one of: designations, programs, user_identity_programs) that are referenced in a string SQL snippet. For example:



    Post.includes(:comments).where("comments.title = 'foo'")



Currently, Active Record recognizes the table in the string, and knows to JOIN the comments table to the query, rather than loading comments in a separate query. However, doing this without writing a full-blown SQL parser is inherently flawed. Since we don't want to write an SQL parser, we are removing this functionality. From now on, you must explicitly tell Active Record when you are referencing a table from a string:



    Post.includes(:comments).where("comments.title = 'foo'").references(:comments)



If you don't rely on implicit join references you can disable the feature entirely by setting `config.active_record.disable_implicit_join_references = true`. (called from designations_received? at /home/travis/build/Liaison-Intl/WebAdMIT/app/models/applicant.rb:941)

[32m.[0mDEPRECATION WARNING: It looks like you are eager loading table(s) (one of: scoring_models, scoring_model_assignments, programs) that are referenced in a string SQL snippet. For example:



    Post.includes(:comments).where("comments.title = 'foo'")



Currently, Active Record recognizes the table in the string, and knows to JOIN the comments table to the query, rather than loading comments in a separate query. However, doing this without writing a full-blown SQL parser is inherently flawed. Since we don't want to write an SQL parser, we are removing this functionality. From now on, you must explicitly tell Active Record when you are referencing a table from a string:



    Post.includes(:comments).where("comments.title = 'foo'").references(:comments)



If you don't rely on implicit join references you can disable the feature entirely by setting `config.active_record.disable_implicit_join_references = true`. (called from score_for_scoring_models at /home/travis/build/Liaison-Intl/WebAdMIT/app/models/scoring/scorer.rb:50)

DEPRECATION WARNING: It looks like you are eager loading table(s) (one of: designations, programs, user_identity_programs) that are referenced in a string SQL snippet. For example:



    Post.includes(:comments).where("comments.title = 'foo'")



Currently, Active Record recognizes the table in the string, and knows to JOIN the comments table to the query, rather than loading comments in a separate query. However, doing this without writing a full-blown SQL parser is inherently flawed. Since we don't want to write an SQL parser, we are removing this functionality. From now on, you must explicitly tell Active Record when you are referencing a table from a string:



    Post.includes(:comments).where("comments.title = 'foo'").references(:comments)



If you don't rely on implicit join references you can disable the feature entirely by setting `config.active_record.disable_implicit_join_references = true`. (called from designations_received? at /home/travis/build/Liaison-Intl/WebAdMIT/app/models/applicant.rb:941)

[32m.[0mDEPRECATION WARNING: It looks like you are eager loading table(s) (one of: scoring_models, scoring_model_assignments, programs) that are referenced in a string SQL snippet. For example:



    Post.includes(:comments).where("comments.title = 'foo'")



Currently, Active Record recognizes the table in the string, and knows to JOIN the comments table to the query, rather than loading comments in a separate query. However, doing this without writing a full-blown SQL parser is inherently flawed. Since we don't want to write an SQL parser, we are removing this functionality. From now on, you must explicitly tell Active Record when you are referencing a table from a string:



    Post.includes(:comments).where("comments.title = 'foo'").references(:comments)



If you don't rely on implicit join references you can disable the feature entirely by setting `config.active_record.disable_implicit_join_references = true`. (called from score_for_scoring_models at /home/travis/build/Liaison-Intl/WebAdMIT/app/models/scoring/scorer.rb:50)

DEPRECATION WARNING: It looks like you are eager loading table(s) (one of: designations, programs, user_identity_programs) that are referenced in a string SQL snippet. For example:



    Post.includes(:comments).where("comments.title = 'foo'")



Currently, Active Record recognizes the table in the string, and knows to JOIN the comments table to the query, rather than loading comments in a separate query. However, doing this without writing a full-blown SQL parser is inherently flawed. Since we don't want to write an SQL parser, we are removing this functionality. From now on, you must explicitly tell Active Record when you are referencing a table from a string:



    Post.includes(:comments).where("comments.title = 'foo'").references(:comments)



If you don't rely on implicit join references you can disable the feature entirely by setting `config.active_record.disable_implicit_join_references = true`. (called from designations_received? at /home/travis/build/Liaison-Intl/WebAdMIT/app/models/applicant.rb:941)

[32m.[0mDEPRECATION WARNING: It looks like you are eager loading table(s) (one of: scoring_models, scoring_model_assignments, programs) that are referenced in a string SQL snippet. For example:



    Post.includes(:comments).where("comments.title = 'foo'")



Currently, Active Record recognizes the table in the string, and knows to JOIN the comments table to the query, rather than loading comments in a separate query. However, doing this without writing a full-blown SQL parser is inherently flawed. Since we don't want to write an SQL parser, we are removing this functionality. From now on, you must explicitly tell Active Record when you are referencing a table from a string:



    Post.includes(:comments).where("comments.title = 'foo'").references(:comments)



If you don't rely on implicit join references you can disable the feature entirely by setting `config.active_record.disable_implicit_join_references = true`. (called from score_for_scoring_models at /home/travis/build/Liaison-Intl/WebAdMIT/app/models/scoring/scorer.rb:50)

DEPRECATION WARNING: It looks like you are eager loading table(s) (one of: designations, programs, user_identity_programs) that are referenced in a string SQL snippet. For example:



    Post.includes(:comments).where("comments.title = 'foo'")



Currently, Active Record recognizes the table in the string, and knows to JOIN the comments table to the query, rather than loading comments in a separate query. However, doing this without writing a full-blown SQL parser is inherently flawed. Since we don't want to write an SQL parser, we are removing this functionality. From now on, you must explicitly tell Active Record when you are referencing a table from a string:



    Post.includes(:comments).where("comments.title = 'foo'").references(:comments)



If you don't rely on implicit join references you can disable the feature entirely by setting `config.active_record.disable_implicit_join_references = true`. (called from designations_received? at /home/travis/build/Liaison-Intl/WebAdMIT/app/models/applicant.rb:941)

[32m.[0mDEPRECATION WARNING: It looks like you are eager loading table(s) (one of: scoring_models, scoring_model_assignments, programs) that are referenced in a string SQL snippet. For example:



    Post.includes(:comments).where("comments.title = 'foo'")



Currently, Active Record recognizes the table in the string, and knows to JOIN the comments table to the query, rather than loading comments in a separate query. However, doing this without writing a full-blown SQL parser is inherently flawed. Since we don't want to write an SQL parser, we are removing this functionality. From now on, you must explicitly tell Active Record when you are referencing a table from a string:



    Post.includes(:comments).where("comments.title = 'foo'").references(:comments)



If you don't rely on implicit join references you can disable the feature entirely by setting `config.active_record.disable_implicit_join_references = true`. (called from score_for_scoring_models at /home/travis/build/Liaison-Intl/WebAdMIT/app/models/scoring/scorer.rb:50)

DEPRECATION WARNING: It looks like you are eager loading table(s) (one of: designations, programs, user_identity_programs) that are referenced in a string SQL snippet. For example:



    Post.includes(:comments).where("comments.title = 'foo'")



Currently, Active Record recognizes the table in the string, and knows to JOIN the comments table to the query, rather than loading comments in a separate query. However, doing this without writing a full-blown SQL parser is inherently flawed. Since we don't want to write an SQL parser, we are removing this functionality. From now on, you must explicitly tell Active Record when you are referencing a table from a string:



    Post.includes(:comments).where("comments.title = 'foo'").references(:comments)



If you don't rely on implicit join references you can disable the feature entirely by setting `config.active_record.disable_implicit_join_references = true`. (called from designations_received? at /home/travis/build/Liaison-Intl/WebAdMIT/app/models/applicant.rb:941)

[32m.[0mDEPRECATION WARNING: It looks like you are eager loading table(s) (one of: scoring_models, scoring_model_assignments, programs) that are referenced in a string SQL snippet. For example:



    Post.includes(:comments).where("comments.title = 'foo'")



Currently, Active Record recognizes the table in the string, and knows to JOIN the comments table to the query, rather than loading comments in a separate query. However, doing this without writing a full-blown SQL parser is inherently flawed. Since we don't want to write an SQL parser, we are removing this functionality. From now on, you must explicitly tell Active Record when you are referencing a table from a string:



    Post.includes(:comments).where("comments.title = 'foo'").references(:comments)



If you don't rely on implicit join references you can disable the feature entirely by setting `config.active_record.disable_implicit_join_references = true`. (called from score_for_scoring_models at /home/travis/build/Liaison-Intl/WebAdMIT/app/models/scoring/scorer.rb:50)

DEPRECATION WARNING: It looks like you are eager loading table(s) (one of: designations, programs, user_identity_programs) that are referenced in a string SQL snippet. For example:



    Post.includes(:comments).where("comments.title = 'foo'")



Currently, Active Record recognizes the table in the string, and knows to JOIN the comments table to the query, rather than loading comments in a separate query. However, doing this without writing a full-blown SQL parser is inherently flawed. Since we don't want to write an SQL parser, we are removing this functionality. From now on, you must explicitly tell Active Record when you are referencing a table from a string:



    Post.includes(:comments).where("comments.title = 'foo'").references(:comments)



If you don't rely on implicit join references you can disable the feature entirely by setting `config.active_record.disable_implicit_join_references = true`. (called from designations_received? at /home/travis/build/Liaison-Intl/WebAdMIT/app/models/applicant.rb:941)

[32m.[0mDEPRECATION WARNING: It looks like you are eager loading table(s) (one of: scoring_models, scoring_model_assignments, programs) that are referenced in a string SQL snippet. For example:



    Post.includes(:comments).where("comments.title = 'foo'")



Currently, Active Record recognizes the table in the string, and knows to JOIN the comments table to the query, rather than loading comments in a separate query. However, doing this without writing a full-blown SQL parser is inherently flawed. Since we don't want to write an SQL parser, we are removing this functionality. From now on, you must explicitly tell Active Record when you are referencing a table from a string:



    Post.includes(:comments).where("comments.title = 'foo'").references(:comments)



If you don't rely on implicit join references you can disable the feature entirely by setting `config.active_record.disable_implicit_join_references = true`. (called from score_for_scoring_models at /home/travis/build/Liaison-Intl/WebAdMIT/app/models/scoring/scorer.rb:50)

DEPRECATION WARNING: It looks like you are eager loading table(s) (one of: designations, programs, user_identity_programs) that are referenced in a string SQL snippet. For example:



    Post.includes(:comments).where("comments.title = 'foo'")



Currently, Active Record recognizes the table in the string, and knows to JOIN the comments table to the query, rather than loading comments in a separate query. However, doing this without writing a full-blown SQL parser is inherently flawed. Since we don't want to write an SQL parser, we are removing this functionality. From now on, you must explicitly tell Active Record when you are referencing a table from a string:



    Post.includes(:comments).where("comments.title = 'foo'").references(:comments)



If you don't rely on implicit join references you can disable the feature entirely by setting `config.active_record.disable_implicit_join_references = true`. (called from designations_received? at /home/travis/build/Liaison-Intl/WebAdMIT/app/models/applicant.rb:941)

[32m.[0mDEPRECATION WARNING: It looks like you are eager loading table(s) (one of: scoring_models, scoring_model_assignments, programs) that are referenced in a string SQL snippet. For example:



    Post.includes(:comments).where("comments.title = 'foo'")



Currently, Active Record recognizes the table in the string, and knows to JOIN the comments table to the query, rather than loading comments in a separate query. However, doing this without writing a full-blown SQL parser is inherently flawed. Since we don't want to write an SQL parser, we are removing this functionality. From now on, you must explicitly tell Active Record when you are referencing a table from a string:



    Post.includes(:comments).where("comments.title = 'foo'").references(:comments)



If you don't rely on implicit join references you can disable the feature entirely by setting `config.active_record.disable_implicit_join_references = true`. (called from score_for_scoring_models at /home/travis/build/Liaison-Intl/WebAdMIT/app/models/scoring/scorer.rb:50)

DEPRECATION WARNING: It looks like you are eager loading table(s) (one of: designations, programs, user_identity_programs) that are referenced in a string SQL snippet. For example:



    Post.includes(:comments).where("comments.title = 'foo'")



Currently, Active Record recognizes the table in the string, and knows to JOIN the comments table to the query, rather than loading comments in a separate query. However, doing this without writing a full-blown SQL parser is inherently flawed. Since we don't want to write an SQL parser, we are removing this functionality. From now on, you must explicitly tell Active Record when you are referencing a table from a string:



    Post.includes(:comments).where("comments.title = 'foo'").references(:comments)



If you don't rely on implicit join references you can disable the feature entirely by setting `config.active_record.disable_implicit_join_references = true`. (called from designations_received? at /home/travis/build/Liaison-Intl/WebAdMIT/app/models/applicant.rb:941)

[32m.[0mDEPRECATION WARNING: It looks like you are eager loading table(s) (one of: scoring_models, scoring_model_assignments, programs) that are referenced in a string SQL snippet. For example:



    Post.includes(:comments).where("comments.title = 'foo'")



Currently, Active Record recognizes the table in the string, and knows to JOIN the comments table to the query, rather than loading comments in a separate query. However, doing this without writing a full-blown SQL parser is inherently flawed. Since we don't want to write an SQL parser, we are removing this functionality. From now on, you must explicitly tell Active Record when you are referencing a table from a string:



    Post.includes(:comments).where("comments.title = 'foo'").references(:comments)



If you don't rely on implicit join references you can disable the feature entirely by setting `config.active_record.disable_implicit_join_references = true`. (called from score_for_scoring_models at /home/travis/build/Liaison-Intl/WebAdMIT/app/models/scoring/scorer.rb:50)

DEPRECATION WARNING: It looks like you are eager loading table(s) (one of: designations, programs, user_identity_programs) that are referenced in a string SQL snippet. For example:



    Post.includes(:comments).where("comments.title = 'foo'")



Currently, Active Record recognizes the table in the string, and knows to JOIN the comments table to the query, rather than loading comments in a separate query. However, doing this without writing a full-blown SQL parser is inherently flawed. Since we don't want to write an SQL parser, we are removing this functionality. From now on, you must explicitly tell Active Record when you are referencing a table from a string:



    Post.includes(:comments).where("comments.title = 'foo'").references(:comments)



If you don't rely on implicit join references you can disable the feature entirely by setting `config.active_record.disable_implicit_join_references = true`. (called from designations_received? at /home/travis/build/Liaison-Intl/WebAdMIT/app/models/applicant.rb:941)

[32m.[0mDEPRECATION WARNING: It looks like you are eager loading table(s) (one of: scoring_models, scoring_model_assignments, programs) that are referenced in a string SQL snippet. For example:



    Post.includes(:comments).where("comments.title = 'foo'")



Currently, Active Record recognizes the table in the string, and knows to JOIN the comments table to the query, rather than loading comments in a separate query. However, doing this without writing a full-blown SQL parser is inherently flawed. Since we don't want to write an SQL parser, we are removing this functionality. From now on, you must explicitly tell Active Record when you are referencing a table from a string:



    Post.includes(:comments).where("comments.title = 'foo'").references(:comments)



If you don't rely on implicit join references you can disable the feature entirely by setting `config.active_record.disable_implicit_join_references = true`. (called from score_for_scoring_models at /home/travis/build/Liaison-Intl/WebAdMIT/app/models/scoring/scorer.rb:50)

DEPRECATION WARNING: It looks like you are eager loading table(s) (one of: designations, programs, user_identity_programs) that are referenced in a string SQL snippet. For example:



    Post.includes(:comments).where("comments.title = 'foo'")



Currently, Active Record recognizes the table in the string, and knows to JOIN the comments table to the query, rather than loading comments in a separate query. However, doing this without writing a full-blown SQL parser is inherently flawed. Since we don't want to write an SQL parser, we are removing this functionality. From now on, you must explicitly tell Active Record when you are referencing a table from a string:



    Post.includes(:comments).where("comments.title = 'foo'").references(:comments)



If you don't rely on implicit join references you can disable the feature entirely by setting `config.active_record.disable_implicit_join_references = true`. (called from designations_received? at /home/travis/build/Liaison-Intl/WebAdMIT/app/models/applicant.rb:941)

[32m.[0mDEPRECATION WARNING: It looks like you are eager loading table(s) (one of: scoring_models, scoring_model_assignments, programs) that are referenced in a string SQL snippet. For example:



    Post.includes(:comments).where("comments.title = 'foo'")



Currently, Active Record recognizes the table in the string, and knows to JOIN the comments table to the query, rather than loading comments in a separate query. However, doing this without writing a full-blown SQL parser is inherently flawed. Since we don't want to write an SQL parser, we are removing this functionality. From now on, you must explicitly tell Active Record when you are referencing a table from a string:



    Post.includes(:comments).where("comments.title = 'foo'").references(:comments)



If you don't rely on implicit join references you can disable the feature entirely by setting `config.active_record.disable_implicit_join_references = true`. (called from score_for_scoring_models at /home/travis/build/Liaison-Intl/WebAdMIT/app/models/scoring/scorer.rb:50)

DEPRECATION WARNING: It looks like you are eager loading table(s) (one of: designations, programs, user_identity_programs) that are referenced in a string SQL snippet. For example:



    Post.includes(:comments).where("comments.title = 'foo'")



Currently, Active Record recognizes the table in the string, and knows to JOIN the comments table to the query, rather than loading comments in a separate query. However, doing this without writing a full-blown SQL parser is inherently flawed. Since we don't want to write an SQL parser, we are removing this functionality. From now on, you must explicitly tell Active Record when you are referencing a table from a string:



    Post.includes(:comments).where("comments.title = 'foo'").references(:comments)



If you don't rely on implicit join references you can disable the feature entirely by setting `config.active_record.disable_implicit_join_references = true`. (called from designations_received? at /home/travis/build/Liaison-Intl/WebAdMIT/app/models/applicant.rb:941)

[32m.[0mDEPRECATION WARNING: It looks like you are eager loading table(s) (one of: scoring_models, scoring_model_assignments, programs) that are referenced in a string SQL snippet. For example:



    Post.includes(:comments).where("comments.title = 'foo'")



Currently, Active Record recognizes the table in the string, and knows to JOIN the comments table to the query, rather than loading comments in a separate query. However, doing this without writing a full-blown SQL parser is inherently flawed. Since we don't want to write an SQL parser, we are removing this functionality. From now on, you must explicitly tell Active Record when you are referencing a table from a string:



    Post.includes(:comments).where("comments.title = 'foo'").references(:comments)



If you don't rely on implicit join references you can disable the feature entirely by setting `config.active_record.disable_implicit_join_references = true`. (called from score_for_scoring_models at /home/travis/build/Liaison-Intl/WebAdMIT/app/models/scoring/scorer.rb:50)

DEPRECATION WARNING: It looks like you are eager loading table(s) (one of: designations, programs, user_identity_programs) that are referenced in a string SQL snippet. For example:



    Post.includes(:comments).where("comments.title = 'foo'")



Currently, Active Record recognizes the table in the string, and knows to JOIN the comments table to the query, rather than loading comments in a separate query. However, doing this without writing a full-blown SQL parser is inherently flawed. Since we don't want to write an SQL parser, we are removing this functionality. From now on, you must explicitly tell Active Record when you are referencing a table from a string:



    Post.includes(:comments).where("comments.title = 'foo'").references(:comments)



If you don't rely on implicit join references you can disable the feature entirely by setting `config.active_record.disable_implicit_join_references = true`. (called from designations_received? at /home/travis/build/Liaison-Intl/WebAdMIT/app/models/applicant.rb:941)

[32m.[0mDEPRECATION WARNING: It looks like you are eager loading table(s) (one of: scoring_models, scoring_model_assignments, programs) that are referenced in a string SQL snippet. For example:



    Post.includes(:comments).where("comments.title = 'foo'")



Currently, Active Record recognizes the table in the string, and knows to JOIN the comments table to the query, rather than loading comments in a separate query. However, doing this without writing a full-blown SQL parser is inherently flawed. Since we don't want to write an SQL parser, we are removing this functionality. From now on, you must explicitly tell Active Record when you are referencing a table from a string:



    Post.includes(:comments).where("comments.title = 'foo'").references(:comments)



If you don't rely on implicit join references you can disable the feature entirely by setting `config.active_record.disable_implicit_join_references = true`. (called from score_for_scoring_models at /home/travis/build/Liaison-Intl/WebAdMIT/app/models/scoring/scorer.rb:50)

DEPRECATION WARNING: It looks like you are eager loading table(s) (one of: designations, programs, user_identity_programs) that are referenced in a string SQL snippet. For example:



    Post.includes(:comments).where("comments.title = 'foo'")



Currently, Active Record recognizes the table in the string, and knows to JOIN the comments table to the query, rather than loading comments in a separate query. However, doing this without writing a full-blown SQL parser is inherently flawed. Since we don't want to write an SQL parser, we are removing this functionality. From now on, you must explicitly tell Active Record when you are referencing a table from a string:



    Post.includes(:comments).where("comments.title = 'foo'").references(:comments)



If you don't rely on implicit join references you can disable the feature entirely by setting `config.active_record.disable_implicit_join_references = true`. (called from designations_received? at /home/travis/build/Liaison-Intl/WebAdMIT/app/models/applicant.rb:941)

[32m.[0mDEPRECATION WARNING: It looks like you are eager loading table(s) (one of: scoring_models, scoring_model_assignments, programs) that are referenced in a string SQL snippet. For example:



    Post.includes(:comments).where("comments.title = 'foo'")



Currently, Active Record recognizes the table in the string, and knows to JOIN the comments table to the query, rather than loading comments in a separate query. However, doing this without writing a full-blown SQL parser is inherently flawed. Since we don't want to write an SQL parser, we are removing this functionality. From now on, you must explicitly tell Active Record when you are referencing a table from a string:



    Post.includes(:comments).where("comments.title = 'foo'").references(:comments)



If you don't rely on implicit join references you can disable the feature entirely by setting `config.active_record.disable_implicit_join_references = true`. (called from score_for_scoring_models at /home/travis/build/Liaison-Intl/WebAdMIT/app/models/scoring/scorer.rb:50)

DEPRECATION WARNING: It looks like you are eager loading table(s) (one of: designations, programs, user_identity_programs) that are referenced in a string SQL snippet. For example:



    Post.includes(:comments).where("comments.title = 'foo'")



Currently, Active Record recognizes the table in the string, and knows to JOIN the comments table to the query, rather than loading comments in a separate query. However, doing this without writing a full-blown SQL parser is inherently flawed. Since we don't want to write an SQL parser, we are removing this functionality. From now on, you must explicitly tell Active Record when you are referencing a table from a string:



    Post.includes(:comments).where("comments.title = 'foo'").references(:comments)



If you don't rely on implicit join references you can disable the feature entirely by setting `config.active_record.disable_implicit_join_references = true`. (called from designations_received? at /home/travis/build/Liaison-Intl/WebAdMIT/app/models/applicant.rb:941)

[32m.[0mDEPRECATION WARNING: It looks like you are eager loading table(s) (one of: scoring_models, scoring_model_assignments, programs) that are referenced in a string SQL snippet. For example:



    Post.includes(:comments).where("comments.title = 'foo'")



Currently, Active Record recognizes the table in the string, and knows to JOIN the comments table to the query, rather than loading comments in a separate query. However, doing this without writing a full-blown SQL parser is inherently flawed. Since we don't want to write an SQL parser, we are removing this functionality. From now on, you must explicitly tell Active Record when you are referencing a table from a string:



    Post.includes(:comments).where("comments.title = 'foo'").references(:comments)



If you don't rely on implicit join references you can disable the feature entirely by setting `config.active_record.disable_implicit_join_references = true`. (called from score_for_scoring_models at /home/travis/build/Liaison-Intl/WebAdMIT/app/models/scoring/scorer.rb:50)

DEPRECATION WARNING: It looks like you are eager loading table(s) (one of: designations, programs, user_identity_programs) that are referenced in a string SQL snippet. For example:



    Post.includes(:comments).where("comments.title = 'foo'")



Currently, Active Record recognizes the table in the string, and knows to JOIN the comments table to the query, rather than loading comments in a separate query. However, doing this without writing a full-blown SQL parser is inherently flawed. Since we don't want to write an SQL parser, we are removing this functionality. From now on, you must explicitly tell Active Record when you are referencing a table from a string:



    Post.includes(:comments).where("comments.title = 'foo'").references(:comments)



If you don't rely on implicit join references you can disable the feature entirely by setting `config.active_record.disable_implicit_join_references = true`. (called from designations_received? at /home/travis/build/Liaison-Intl/WebAdMIT/app/models/applicant.rb:941)

[32m.[0mDEPRECATION WARNING: It looks like you are eager loading table(s) (one of: scoring_models, scoring_model_assignments, programs) that are referenced in a string SQL snippet. For example:



    Post.includes(:comments).where("comments.title = 'foo'")



Currently, Active Record recognizes the table in the string, and knows to JOIN the comments table to the query, rather than loading comments in a separate query. However, doing this without writing a full-blown SQL parser is inherently flawed. Since we don't want to write an SQL parser, we are removing this functionality. From now on, you must explicitly tell Active Record when you are referencing a table from a string:



    Post.includes(:comments).where("comments.title = 'foo'").references(:comments)



If you don't rely on implicit join references you can disable the feature entirely by setting `config.active_record.disable_implicit_join_references = true`. (called from score_for_scoring_models at /home/travis/build/Liaison-Intl/WebAdMIT/app/models/scoring/scorer.rb:50)

DEPRECATION WARNING: It looks like you are eager loading table(s) (one of: designations, programs, user_identity_programs) that are referenced in a string SQL snippet. For example:



    Post.includes(:comments).where("comments.title = 'foo'")



Currently, Active Record recognizes the table in the string, and knows to JOIN the comments table to the query, rather than loading comments in a separate query. However, doing this without writing a full-blown SQL parser is inherently flawed. Since we don't want to write an SQL parser, we are removing this functionality. From now on, you must explicitly tell Active Record when you are referencing a table from a string:



    Post.includes(:comments).where("comments.title = 'foo'").references(:comments)



If you don't rely on implicit join references you can disable the feature entirely by setting `config.active_record.disable_implicit_join_references = true`. (called from designations_received? at /home/travis/build/Liaison-Intl/WebAdMIT/app/models/applicant.rb:941)

[32m.[0mDEPRECATION WARNING: It looks like you are eager loading table(s) (one of: scoring_models, scoring_model_assignments, programs) that are referenced in a string SQL snippet. For example:



    Post.includes(:comments).where("comments.title = 'foo'")



Currently, Active Record recognizes the table in the string, and knows to JOIN the comments table to the query, rather than loading comments in a separate query. However, doing this without writing a full-blown SQL parser is inherently flawed. Since we don't want to write an SQL parser, we are removing this functionality. From now on, you must explicitly tell Active Record when you are referencing a table from a string:



    Post.includes(:comments).where("comments.title = 'foo'").references(:comments)



If you don't rely on implicit join references you can disable the feature entirely by setting `config.active_record.disable_implicit_join_references = true`. (called from score_for_scoring_models at /home/travis/build/Liaison-Intl/WebAdMIT/app/models/scoring/scorer.rb:50)

DEPRECATION WARNING: It looks like you are eager loading table(s) (one of: designations, programs, user_identity_programs) that are referenced in a string SQL snippet. For example:



    Post.includes(:comments).where("comments.title = 'foo'")



Currently, Active Record recognizes the table in the string, and knows to JOIN the comments table to the query, rather than loading comments in a separate query. However, doing this without writing a full-blown SQL parser is inherently flawed. Since we don't want to write an SQL parser, we are removing this functionality. From now on, you must explicitly tell Active Record when you are referencing a table from a string:



    Post.includes(:comments).where("comments.title = 'foo'").references(:comments)



If you don't rely on implicit join references you can disable the feature entirely by setting `config.active_record.disable_implicit_join_references = true`. (called from designations_received? at /home/travis/build/Liaison-Intl/WebAdMIT/app/models/applicant.rb:941)

[32m.[0mDEPRECATION WARNING: It looks like you are eager loading table(s) (one of: scoring_models, scoring_model_assignments, programs) that are referenced in a string SQL snippet. For example:



    Post.includes(:comments).where("comments.title = 'foo'")



Currently, Active Record recognizes the table in the string, and knows to JOIN the comments table to the query, rather than loading comments in a separate query. However, doing this without writing a full-blown SQL parser is inherently flawed. Since we don't want to write an SQL parser, we are removing this functionality. From now on, you must explicitly tell Active Record when you are referencing a table from a string:



    Post.includes(:comments).where("comments.title = 'foo'").references(:comments)



If you don't rely on implicit join references you can disable the feature entirely by setting `config.active_record.disable_implicit_join_references = true`. (called from score_for_scoring_models at /home/travis/build/Liaison-Intl/WebAdMIT/app/models/scoring/scorer.rb:50)

DEPRECATION WARNING: It looks like you are eager loading table(s) (one of: designations, programs, user_identity_programs) that are referenced in a string SQL snippet. For example:



    Post.includes(:comments).where("comments.title = 'foo'")



Currently, Active Record recognizes the table in the string, and knows to JOIN the comments table to the query, rather than loading comments in a separate query. However, doing this without writing a full-blown SQL parser is inherently flawed. Since we don't want to write an SQL parser, we are removing this functionality. From now on, you must explicitly tell Active Record when you are referencing a table from a string:



    Post.includes(:comments).where("comments.title = 'foo'").references(:comments)



If you don't rely on implicit join references you can disable the feature entirely by setting `config.active_record.disable_implicit_join_references = true`. (called from designations_received? at /home/travis/build/Liaison-Intl/WebAdMIT/app/models/applicant.rb:941)

[32m.[0mDEPRECATION WARNING: It looks like you are eager loading table(s) (one of: scoring_models, scoring_model_assignments, programs) that are referenced in a string SQL snippet. For example:



    Post.includes(:comments).where("comments.title = 'foo'")



Currently, Active Record recognizes the table in the string, and knows to JOIN the comments table to the query, rather than loading comments in a separate query. However, doing this without writing a full-blown SQL parser is inherently flawed. Since we don't want to write an SQL parser, we are removing this functionality. From now on, you must explicitly tell Active Record when you are referencing a table from a string:



    Post.includes(:comments).where("comments.title = 'foo'").references(:comments)



If you don't rely on implicit join references you can disable the feature entirely by setting `config.active_record.disable_implicit_join_references = true`. (called from score_for_scoring_models at /home/travis/build/Liaison-Intl/WebAdMIT/app/models/scoring/scorer.rb:50)

DEPRECATION WARNING: It looks like you are eager loading table(s) (one of: designations, programs, user_identity_programs) that are referenced in a string SQL snippet. For example:



    Post.includes(:comments).where("comments.title = 'foo'")



Currently, Active Record recognizes the table in the string, and knows to JOIN the comments table to the query, rather than loading comments in a separate query. However, doing this without writing a full-blown SQL parser is inherently flawed. Since we don't want to write an SQL parser, we are removing this functionality. From now on, you must explicitly tell Active Record when you are referencing a table from a string:



    Post.includes(:comments).where("comments.title = 'foo'").references(:comments)



If you don't rely on implicit join references you can disable the feature entirely by setting `config.active_record.disable_implicit_join_references = true`. (called from designations_received? at /home/travis/build/Liaison-Intl/WebAdMIT/app/models/applicant.rb:941)

[32m.[0mDEPRECATION WARNING: It looks like you are eager loading table(s) (one of: scoring_models, scoring_model_assignments, programs) that are referenced in a string SQL snippet. For example:



    Post.includes(:comments).where("comments.title = 'foo'")



Currently, Active Record recognizes the table in the string, and knows to JOIN the comments table to the query, rather than loading comments in a separate query. However, doing this without writing a full-blown SQL parser is inherently flawed. Since we don't want to write an SQL parser, we are removing this functionality. From now on, you must explicitly tell Active Record when you are referencing a table from a string:



    Post.includes(:comments).where("comments.title = 'foo'").references(:comments)



If you don't rely on implicit join references you can disable the feature entirely by setting `config.active_record.disable_implicit_join_references = true`. (called from score_for_scoring_models at /home/travis/build/Liaison-Intl/WebAdMIT/app/models/scoring/scorer.rb:50)

DEPRECATION WARNING: It looks like you are eager loading table(s) (one of: designations, programs, user_identity_programs) that are referenced in a string SQL snippet. For example:



    Post.includes(:comments).where("comments.title = 'foo'")



Currently, Active Record recognizes the table in the string, and knows to JOIN the comments table to the query, rather than loading comments in a separate query. However, doing this without writing a full-blown SQL parser is inherently flawed. Since we don't want to write an SQL parser, we are removing this functionality. From now on, you must explicitly tell Active Record when you are referencing a table from a string:



    Post.includes(:comments).where("comments.title = 'foo'").references(:comments)



If you don't rely on implicit join references you can disable the feature entirely by setting `config.active_record.disable_implicit_join_references = true`. (called from designations_received? at /home/travis/build/Liaison-Intl/WebAdMIT/app/models/applicant.rb:941)

[32m.[0mDEPRECATION WARNING: It looks like you are eager loading table(s) (one of: scoring_models, scoring_model_assignments, programs) that are referenced in a string SQL snippet. For example:



    Post.includes(:comments).where("comments.title = 'foo'")



Currently, Active Record recognizes the table in the string, and knows to JOIN the comments table to the query, rather than loading comments in a separate query. However, doing this without writing a full-blown SQL parser is inherently flawed. Since we don't want to write an SQL parser, we are removing this functionality. From now on, you must explicitly tell Active Record when you are referencing a table from a string:



    Post.includes(:comments).where("comments.title = 'foo'").references(:comments)



If you don't rely on implicit join references you can disable the feature entirely by setting `config.active_record.disable_implicit_join_references = true`. (called from score_for_scoring_models at /home/travis/build/Liaison-Intl/WebAdMIT/app/models/scoring/scorer.rb:50)

DEPRECATION WARNING: It looks like you are eager loading table(s) (one of: designations, programs, user_identity_programs) that are referenced in a string SQL snippet. For example:



    Post.includes(:comments).where("comments.title = 'foo'")



Currently, Active Record recognizes the table in the string, and knows to JOIN the comments table to the query, rather than loading comments in a separate query. However, doing this without writing a full-blown SQL parser is inherently flawed. Since we don't want to write an SQL parser, we are removing this functionality. From now on, you must explicitly tell Active Record when you are referencing a table from a string:



    Post.includes(:comments).where("comments.title = 'foo'").references(:comments)



If you don't rely on implicit join references you can disable the feature entirely by setting `config.active_record.disable_implicit_join_references = true`. (called from designations_received? at /home/travis/build/Liaison-Intl/WebAdMIT/app/models/applicant.rb:941)

[32m.[0mDEPRECATION WARNING: It looks like you are eager loading table(s) (one of: scoring_models, scoring_model_assignments, programs) that are referenced in a string SQL snippet. For example:



    Post.includes(:comments).where("comments.title = 'foo'")



Currently, Active Record recognizes the table in the string, and knows to JOIN the comments table to the query, rather than loading comments in a separate query. However, doing this without writing a full-blown SQL parser is inherently flawed. Since we don't want to write an SQL parser, we are removing this functionality. From now on, you must explicitly tell Active Record when you are referencing a table from a string:



    Post.includes(:comments).where("comments.title = 'foo'").references(:comments)



If you don't rely on implicit join references you can disable the feature entirely by setting `config.active_record.disable_implicit_join_references = true`. (called from score_for_scoring_models at /home/travis/build/Liaison-Intl/WebAdMIT/app/models/scoring/scorer.rb:50)

DEPRECATION WARNING: It looks like you are eager loading table(s) (one of: designations, programs, user_identity_programs) that are referenced in a string SQL snippet. For example:



    Post.includes(:comments).where("comments.title = 'foo'")



Currently, Active Record recognizes the table in the string, and knows to JOIN the comments table to the query, rather than loading comments in a separate query. However, doing this without writing a full-blown SQL parser is inherently flawed. Since we don't want to write an SQL parser, we are removing this functionality. From now on, you must explicitly tell Active Record when you are referencing a table from a string:



    Post.includes(:comments).where("comments.title = 'foo'").references(:comments)



If you don't rely on implicit join references you can disable the feature entirely by setting `config.active_record.disable_implicit_join_references = true`. (called from designations_received? at /home/travis/build/Liaison-Intl/WebAdMIT/app/models/applicant.rb:941)

[32m.[0mDEPRECATION WARNING: It looks like you are eager loading table(s) (one of: scoring_models, scoring_model_assignments, programs) that are referenced in a string SQL snippet. For example:



    Post.includes(:comments).where("comments.title = 'foo'")



Currently, Active Record recognizes the table in the string, and knows to JOIN the comments table to the query, rather than loading comments in a separate query. However, doing this without writing a full-blown SQL parser is inherently flawed. Since we don't want to write an SQL parser, we are removing this functionality. From now on, you must explicitly tell Active Record when you are referencing a table from a string:



    Post.includes(:comments).where("comments.title = 'foo'").references(:comments)



If you don't rely on implicit join references you can disable the feature entirely by setting `config.active_record.disable_implicit_join_references = true`. (called from score_for_scoring_models at /home/travis/build/Liaison-Intl/WebAdMIT/app/models/scoring/scorer.rb:50)

DEPRECATION WARNING: It looks like you are eager loading table(s) (one of: designations, programs, user_identity_programs) that are referenced in a string SQL snippet. For example:



    Post.includes(:comments).where("comments.title = 'foo'")



Currently, Active Record recognizes the table in the string, and knows to JOIN the comments table to the query, rather than loading comments in a separate query. However, doing this without writing a full-blown SQL parser is inherently flawed. Since we don't want to write an SQL parser, we are removing this functionality. From now on, you must explicitly tell Active Record when you are referencing a table from a string:



    Post.includes(:comments).where("comments.title = 'foo'").references(:comments)



If you don't rely on implicit join references you can disable the feature entirely by setting `config.active_record.disable_implicit_join_references = true`. (called from designations_received? at /home/travis/build/Liaison-Intl/WebAdMIT/app/models/applicant.rb:941)

[32m.[0mDEPRECATION WARNING: It looks like you are eager loading table(s) (one of: scoring_models, scoring_model_assignments, programs) that are referenced in a string SQL snippet. For example:



    Post.includes(:comments).where("comments.title = 'foo'")



Currently, Active Record recognizes the table in the string, and knows to JOIN the comments table to the query, rather than loading comments in a separate query. However, doing this without writing a full-blown SQL parser is inherently flawed. Since we don't want to write an SQL parser, we are removing this functionality. From now on, you must explicitly tell Active Record when you are referencing a table from a string:



    Post.includes(:comments).where("comments.title = 'foo'").references(:comments)



If you don't rely on implicit join references you can disable the feature entirely by setting `config.active_record.disable_implicit_join_references = true`. (called from score_for_scoring_models at /home/travis/build/Liaison-Intl/WebAdMIT/app/models/scoring/scorer.rb:50)

DEPRECATION WARNING: It looks like you are eager loading table(s) (one of: designations, programs, user_identity_programs) that are referenced in a string SQL snippet. For example:



    Post.includes(:comments).where("comments.title = 'foo'")



Currently, Active Record recognizes the table in the string, and knows to JOIN the comments table to the query, rather than loading comments in a separate query. However, doing this without writing a full-blown SQL parser is inherently flawed. Since we don't want to write an SQL parser, we are removing this functionality. From now on, you must explicitly tell Active Record when you are referencing a table from a string:



    Post.includes(:comments).where("comments.title = 'foo'").references(:comments)



If you don't rely on implicit join references you can disable the feature entirely by setting `config.active_record.disable_implicit_join_references = true`. (called from designations_received? at /home/travis/build/Liaison-Intl/WebAdMIT/app/models/applicant.rb:941)

[32m.[0mDEPRECATION WARNING: It looks like you are eager loading table(s) (one of: scoring_models, scoring_model_assignments, programs) that are referenced in a string SQL snippet. For example:



    Post.includes(:comments).where("comments.title = 'foo'")



Currently, Active Record recognizes the table in the string, and knows to JOIN the comments table to the query, rather than loading comments in a separate query. However, doing this without writing a full-blown SQL parser is inherently flawed. Since we don't want to write an SQL parser, we are removing this functionality. From now on, you must explicitly tell Active Record when you are referencing a table from a string:



    Post.includes(:comments).where("comments.title = 'foo'").references(:comments)



If you don't rely on implicit join references you can disable the feature entirely by setting `config.active_record.disable_implicit_join_references = true`. (called from score_for_scoring_models at /home/travis/build/Liaison-Intl/WebAdMIT/app/models/scoring/scorer.rb:50)

DEPRECATION WARNING: It looks like you are eager loading table(s) (one of: designations, programs, user_identity_programs) that are referenced in a string SQL snippet. For example:



    Post.includes(:comments).where("comments.title = 'foo'")



Currently, Active Record recognizes the table in the string, and knows to JOIN the comments table to the query, rather than loading comments in a separate query. However, doing this without writing a full-blown SQL parser is inherently flawed. Since we don't want to write an SQL parser, we are removing this functionality. From now on, you must explicitly tell Active Record when you are referencing a table from a string:



    Post.includes(:comments).where("comments.title = 'foo'").references(:comments)



If you don't rely on implicit join references you can disable the feature entirely by setting `config.active_record.disable_implicit_join_references = true`. (called from designations_received? at /home/travis/build/Liaison-Intl/WebAdMIT/app/models/applicant.rb:941)

[32m.[0mDEPRECATION WARNING: It looks like you are eager loading table(s) (one of: scoring_models, scoring_model_assignments, programs) that are referenced in a string SQL snippet. For example:



    Post.includes(:comments).where("comments.title = 'foo'")



Currently, Active Record recognizes the table in the string, and knows to JOIN the comments table to the query, rather than loading comments in a separate query. However, doing this without writing a full-blown SQL parser is inherently flawed. Since we don't want to write an SQL parser, we are removing this functionality. From now on, you must explicitly tell Active Record when you are referencing a table from a string:



    Post.includes(:comments).where("comments.title = 'foo'").references(:comments)



If you don't rely on implicit join references you can disable the feature entirely by setting `config.active_record.disable_implicit_join_references = true`. (called from score_for_scoring_models at /home/travis/build/Liaison-Intl/WebAdMIT/app/models/scoring/scorer.rb:50)

DEPRECATION WARNING: It looks like you are eager loading table(s) (one of: designations, programs, user_identity_programs) that are referenced in a string SQL snippet. For example:



    Post.includes(:comments).where("comments.title = 'foo'")



Currently, Active Record recognizes the table in the string, and knows to JOIN the comments table to the query, rather than loading comments in a separate query. However, doing this without writing a full-blown SQL parser is inherently flawed. Since we don't want to write an SQL parser, we are removing this functionality. From now on, you must explicitly tell Active Record when you are referencing a table from a string:



    Post.includes(:comments).where("comments.title = 'foo'").references(:comments)



If you don't rely on implicit join references you can disable the feature entirely by setting `config.active_record.disable_implicit_join_references = true`. (called from designations_received? at /home/travis/build/Liaison-Intl/WebAdMIT/app/models/applicant.rb:941)

[32m.[0mDEPRECATION WARNING: It looks like you are eager loading table(s) (one of: scoring_models, scoring_model_assignments, programs) that are referenced in a string SQL snippet. For example:



    Post.includes(:comments).where("comments.title = 'foo'")



Currently, Active Record recognizes the table in the string, and knows to JOIN the comments table to the query, rather than loading comments in a separate query. However, doing this without writing a full-blown SQL parser is inherently flawed. Since we don't want to write an SQL parser, we are removing this functionality. From now on, you must explicitly tell Active Record when you are referencing a table from a string:



    Post.includes(:comments).where("comments.title = 'foo'").references(:comments)



If you don't rely on implicit join references you can disable the feature entirely by setting `config.active_record.disable_implicit_join_references = true`. (called from score_for_scoring_models at /home/travis/build/Liaison-Intl/WebAdMIT/app/models/scoring/scorer.rb:50)

DEPRECATION WARNING: It looks like you are eager loading table(s) (one of: designations, programs, user_identity_programs) that are referenced in a string SQL snippet. For example:



    Post.includes(:comments).where("comments.title = 'foo'")



Currently, Active Record recognizes the table in the string, and knows to JOIN the comments table to the query, rather than loading comments in a separate query. However, doing this without writing a full-blown SQL parser is inherently flawed. Since we don't want to write an SQL parser, we are removing this functionality. From now on, you must explicitly tell Active Record when you are referencing a table from a string:



    Post.includes(:comments).where("comments.title = 'foo'").references(:comments)



If you don't rely on implicit join references you can disable the feature entirely by setting `config.active_record.disable_implicit_join_references = true`. (called from designations_received? at /home/travis/build/Liaison-Intl/WebAdMIT/app/models/applicant.rb:941)

[32m.[0mDEPRECATION WARNING: It looks like you are eager loading table(s) (one of: scoring_models, scoring_model_assignments, programs) that are referenced in a string SQL snippet. For example:



    Post.includes(:comments).where("comments.title = 'foo'")



Currently, Active Record recognizes the table in the string, and knows to JOIN the comments table to the query, rather than loading comments in a separate query. However, doing this without writing a full-blown SQL parser is inherently flawed. Since we don't want to write an SQL parser, we are removing this functionality. From now on, you must explicitly tell Active Record when you are referencing a table from a string:



    Post.includes(:comments).where("comments.title = 'foo'").references(:comments)



If you don't rely on implicit join references you can disable the feature entirely by setting `config.active_record.disable_implicit_join_references = true`. (called from score_for_scoring_models at /home/travis/build/Liaison-Intl/WebAdMIT/app/models/scoring/scorer.rb:50)

DEPRECATION WARNING: It looks like you are eager loading table(s) (one of: designations, programs, user_identity_programs) that are referenced in a string SQL snippet. For example:



    Post.includes(:comments).where("comments.title = 'foo'")



Currently, Active Record recognizes the table in the string, and knows to JOIN the comments table to the query, rather than loading comments in a separate query. However, doing this without writing a full-blown SQL parser is inherently flawed. Since we don't want to write an SQL parser, we are removing this functionality. From now on, you must explicitly tell Active Record when you are referencing a table from a string:



    Post.includes(:comments).where("comments.title = 'foo'").references(:comments)



If you don't rely on implicit join references you can disable the feature entirely by setting `config.active_record.disable_implicit_join_references = true`. (called from designations_received? at /home/travis/build/Liaison-Intl/WebAdMIT/app/models/applicant.rb:941)

[32m.[0mDEPRECATION WARNING: It looks like you are eager loading table(s) (one of: scoring_models, scoring_model_assignments, programs) that are referenced in a string SQL snippet. For example:



    Post.includes(:comments).where("comments.title = 'foo'")



Currently, Active Record recognizes the table in the string, and knows to JOIN the comments table to the query, rather than loading comments in a separate query. However, doing this without writing a full-blown SQL parser is inherently flawed. Since we don't want to write an SQL parser, we are removing this functionality. From now on, you must explicitly tell Active Record when you are referencing a table from a string:



    Post.includes(:comments).where("comments.title = 'foo'").references(:comments)



If you don't rely on implicit join references you can disable the feature entirely by setting `config.active_record.disable_implicit_join_references = true`. (called from score_for_scoring_models at /home/travis/build/Liaison-Intl/WebAdMIT/app/models/scoring/scorer.rb:50)

DEPRECATION WARNING: It looks like you are eager loading table(s) (one of: designations, programs, user_identity_programs) that are referenced in a string SQL snippet. For example:



    Post.includes(:comments).where("comments.title = 'foo'")



Currently, Active Record recognizes the table in the string, and knows to JOIN the comments table to the query, rather than loading comments in a separate query. However, doing this without writing a full-blown SQL parser is inherently flawed. Since we don't want to write an SQL parser, we are removing this functionality. From now on, you must explicitly tell Active Record when you are referencing a table from a string:



    Post.includes(:comments).where("comments.title = 'foo'").references(:comments)



If you don't rely on implicit join references you can disable the feature entirely by setting `config.active_record.disable_implicit_join_references = true`. (called from designations_received? at /home/travis/build/Liaison-Intl/WebAdMIT/app/models/applicant.rb:941)

[32m.[0mDEPRECATION WARNING: It looks like you are eager loading table(s) (one of: scoring_models, scoring_model_assignments, programs) that are referenced in a string SQL snippet. For example:



    Post.includes(:comments).where("comments.title = 'foo'")



Currently, Active Record recognizes the table in the string, and knows to JOIN the comments table to the query, rather than loading comments in a separate query. However, doing this without writing a full-blown SQL parser is inherently flawed. Since we don't want to write an SQL parser, we are removing this functionality. From now on, you must explicitly tell Active Record when you are referencing a table from a string:



    Post.includes(:comments).where("comments.title = 'foo'").references(:comments)



If you don't rely on implicit join references you can disable the feature entirely by setting `config.active_record.disable_implicit_join_references = true`. (called from score_for_scoring_models at /home/travis/build/Liaison-Intl/WebAdMIT/app/models/scoring/scorer.rb:50)

DEPRECATION WARNING: It looks like you are eager loading table(s) (one of: designations, programs, user_identity_programs) that are referenced in a string SQL snippet. For example:



    Post.includes(:comments).where("comments.title = 'foo'")



Currently, Active Record recognizes the table in the string, and knows to JOIN the comments table to the query, rather than loading comments in a separate query. However, doing this without writing a full-blown SQL parser is inherently flawed. Since we don't want to write an SQL parser, we are removing this functionality. From now on, you must explicitly tell Active Record when you are referencing a table from a string:



    Post.includes(:comments).where("comments.title = 'foo'").references(:comments)



If you don't rely on implicit join references you can disable the feature entirely by setting `config.active_record.disable_implicit_join_references = true`. (called from designations_received? at /home/travis/build/Liaison-Intl/WebAdMIT/app/models/applicant.rb:941)

[32m.[0mDEPRECATION WARNING: It looks like you are eager loading table(s) (one of: scoring_models, scoring_model_assignments, programs) that are referenced in a string SQL snippet. For example:



    Post.includes(:comments).where("comments.title = 'foo'")



Currently, Active Record recognizes the table in the string, and knows to JOIN the comments table to the query, rather than loading comments in a separate query. However, doing this without writing a full-blown SQL parser is inherently flawed. Since we don't want to write an SQL parser, we are removing this functionality. From now on, you must explicitly tell Active Record when you are referencing a table from a string:



    Post.includes(:comments).where("comments.title = 'foo'").references(:comments)



If you don't rely on implicit join references you can disable the feature entirely by setting `config.active_record.disable_implicit_join_references = true`. (called from score_for_scoring_models at /home/travis/build/Liaison-Intl/WebAdMIT/app/models/scoring/scorer.rb:50)

DEPRECATION WARNING: It looks like you are eager loading table(s) (one of: designations, programs, user_identity_programs) that are referenced in a string SQL snippet. For example:



    Post.includes(:comments).where("comments.title = 'foo'")



Currently, Active Record recognizes the table in the string, and knows to JOIN the comments table to the query, rather than loading comments in a separate query. However, doing this without writing a full-blown SQL parser is inherently flawed. Since we don't want to write an SQL parser, we are removing this functionality. From now on, you must explicitly tell Active Record when you are referencing a table from a string:



    Post.includes(:comments).where("comments.title = 'foo'").references(:comments)



If you don't rely on implicit join references you can disable the feature entirely by setting `config.active_record.disable_implicit_join_references = true`. (called from designations_received? at /home/travis/build/Liaison-Intl/WebAdMIT/app/models/applicant.rb:941)

[32m.[0mDEPRECATION WARNING: It looks like you are eager loading table(s) (one of: scoring_models, scoring_model_assignments, programs) that are referenced in a string SQL snippet. For example:



    Post.includes(:comments).where("comments.title = 'foo'")



Currently, Active Record recognizes the table in the string, and knows to JOIN the comments table to the query, rather than loading comments in a separate query. However, doing this without writing a full-blown SQL parser is inherently flawed. Since we don't want to write an SQL parser, we are removing this functionality. From now on, you must explicitly tell Active Record when you are referencing a table from a string:



    Post.includes(:comments).where("comments.title = 'foo'").references(:comments)



If you don't rely on implicit join references you can disable the feature entirely by setting `config.active_record.disable_implicit_join_references = true`. (called from score_for_scoring_models at /home/travis/build/Liaison-Intl/WebAdMIT/app/models/scoring/scorer.rb:50)

DEPRECATION WARNING: It looks like you are eager loading table(s) (one of: designations, programs, user_identity_programs) that are referenced in a string SQL snippet. For example:



    Post.includes(:comments).where("comments.title = 'foo'")



Currently, Active Record recognizes the table in the string, and knows to JOIN the comments table to the query, rather than loading comments in a separate query. However, doing this without writing a full-blown SQL parser is inherently flawed. Since we don't want to write an SQL parser, we are removing this functionality. From now on, you must explicitly tell Active Record when you are referencing a table from a string:



    Post.includes(:comments).where("comments.title = 'foo'").references(:comments)



If you don't rely on implicit join references you can disable the feature entirely by setting `config.active_record.disable_implicit_join_references = true`. (called from designations_received? at /home/travis/build/Liaison-Intl/WebAdMIT/app/models/applicant.rb:941)

[32m.[0mDEPRECATION WARNING: It looks like you are eager loading table(s) (one of: scoring_models, scoring_model_assignments, programs) that are referenced in a string SQL snippet. For example:



    Post.includes(:comments).where("comments.title = 'foo'")



Currently, Active Record recognizes the table in the string, and knows to JOIN the comments table to the query, rather than loading comments in a separate query. However, doing this without writing a full-blown SQL parser is inherently flawed. Since we don't want to write an SQL parser, we are removing this functionality. From now on, you must explicitly tell Active Record when you are referencing a table from a string:



    Post.includes(:comments).where("comments.title = 'foo'").references(:comments)



If you don't rely on implicit join references you can disable the feature entirely by setting `config.active_record.disable_implicit_join_references = true`. (called from score_for_scoring_models at /home/travis/build/Liaison-Intl/WebAdMIT/app/models/scoring/scorer.rb:50)

DEPRECATION WARNING: It looks like you are eager loading table(s) (one of: designations, programs, user_identity_programs) that are referenced in a string SQL snippet. For example:



    Post.includes(:comments).where("comments.title = 'foo'")



Currently, Active Record recognizes the table in the string, and knows to JOIN the comments table to the query, rather than loading comments in a separate query. However, doing this without writing a full-blown SQL parser is inherently flawed. Since we don't want to write an SQL parser, we are removing this functionality. From now on, you must explicitly tell Active Record when you are referencing a table from a string:



    Post.includes(:comments).where("comments.title = 'foo'").references(:comments)



If you don't rely on implicit join references you can disable the feature entirely by setting `config.active_record.disable_implicit_join_references = true`. (called from designations_received? at /home/travis/build/Liaison-Intl/WebAdMIT/app/models/applicant.rb:941)

DEPRECATION WARNING: It looks like you are eager loading table(s) (one of: applicant_ethnicities, ethnicities) that are referenced in a string SQL snippet. For example:



    Post.includes(:comments).where("comments.title = 'foo'")



Currently, Active Record recognizes the table in the string, and knows to JOIN the comments table to the query, rather than loading comments in a separate query. However, doing this without writing a full-blown SQL parser is inherently flawed. Since we don't want to write an SQL parser, we are removing this functionality. From now on, you must explicitly tell Active Record when you are referencing a table from a string:



    Post.includes(:comments).where("comments.title = 'foo'").references(:comments)



If you don't rely on implicit join references you can disable the feature entirely by setting `config.active_record.disable_implicit_join_references = true`. (called from initialize at /home/travis/build/Liaison-Intl/WebAdMIT/app/presenters/race_ethnicity_presenter.rb:5)

[32m.[0mDEPRECATION WARNING: It looks like you are eager loading table(s) (one of: scoring_models, scoring_model_assignments, programs) that are referenced in a string SQL snippet. For example:



    Post.includes(:comments).where("comments.title = 'foo'")



Currently, Active Record recognizes the table in the string, and knows to JOIN the comments table to the query, rather than loading comments in a separate query. However, doing this without writing a full-blown SQL parser is inherently flawed. Since we don't want to write an SQL parser, we are removing this functionality. From now on, you must explicitly tell Active Record when you are referencing a table from a string:



    Post.includes(:comments).where("comments.title = 'foo'").references(:comments)



If you don't rely on implicit join references you can disable the feature entirely by setting `config.active_record.disable_implicit_join_references = true`. (called from score_for_scoring_models at /home/travis/build/Liaison-Intl/WebAdMIT/app/models/scoring/scorer.rb:50)

DEPRECATION WARNING: It looks like you are eager loading table(s) (one of: designations, programs, user_identity_programs) that are referenced in a string SQL snippet. For example:



    Post.includes(:comments).where("comments.title = 'foo'")



Currently, Active Record recognizes the table in the string, and knows to JOIN the comments table to the query, rather than loading comments in a separate query. However, doing this without writing a full-blown SQL parser is inherently flawed. Since we don't want to write an SQL parser, we are removing this functionality. From now on, you must explicitly tell Active Record when you are referencing a table from a string:



    Post.includes(:comments).where("comments.title = 'foo'").references(:comments)



If you don't rely on implicit join references you can disable the feature entirely by setting `config.active_record.disable_implicit_join_references = true`. (called from designations_received? at /home/travis/build/Liaison-Intl/WebAdMIT/app/models/applicant.rb:941)

[32m.[0mDEPRECATION WARNING: It looks like you are eager loading table(s) (one of: scoring_models, scoring_model_assignments, programs) that are referenced in a string SQL snippet. For example:



    Post.includes(:comments).where("comments.title = 'foo'")



Currently, Active Record recognizes the table in the string, and knows to JOIN the comments table to the query, rather than loading comments in a separate query. However, doing this without writing a full-blown SQL parser is inherently flawed. Since we don't want to write an SQL parser, we are removing this functionality. From now on, you must explicitly tell Active Record when you are referencing a table from a string:



    Post.includes(:comments).where("comments.title = 'foo'").references(:comments)



If you don't rely on implicit join references you can disable the feature entirely by setting `config.active_record.disable_implicit_join_references = true`. (called from score_for_scoring_models at /home/travis/build/Liaison-Intl/WebAdMIT/app/models/scoring/scorer.rb:50)

DEPRECATION WARNING: It looks like you are eager loading table(s) (one of: designations, programs, user_identity_programs) that are referenced in a string SQL snippet. For example:



    Post.includes(:comments).where("comments.title = 'foo'")



Currently, Active Record recognizes the table in the string, and knows to JOIN the comments table to the query, rather than loading comments in a separate query. However, doing this without writing a full-blown SQL parser is inherently flawed. Since we don't want to write an SQL parser, we are removing this functionality. From now on, you must explicitly tell Active Record when you are referencing a table from a string:



    Post.includes(:comments).where("comments.title = 'foo'").references(:comments)



If you don't rely on implicit join references you can disable the feature entirely by setting `config.active_record.disable_implicit_join_references = true`. (called from designations_received? at /home/travis/build/Liaison-Intl/WebAdMIT/app/models/applicant.rb:941)

[32m.[0mDEPRECATION WARNING: It looks like you are eager loading table(s) (one of: scoring_models, scoring_model_assignments, programs) that are referenced in a string SQL snippet. For example:



    Post.includes(:comments).where("comments.title = 'foo'")



Currently, Active Record recognizes the table in the string, and knows to JOIN the comments table to the query, rather than loading comments in a separate query. However, doing this without writing a full-blown SQL parser is inherently flawed. Since we don't want to write an SQL parser, we are removing this functionality. From now on, you must explicitly tell Active Record when you are referencing a table from a string:



    Post.includes(:comments).where("comments.title = 'foo'").references(:comments)



If you don't rely on implicit join references you can disable the feature entirely by setting `config.active_record.disable_implicit_join_references = true`. (called from score_for_scoring_models at /home/travis/build/Liaison-Intl/WebAdMIT/app/models/scoring/scorer.rb:50)

DEPRECATION WARNING: It looks like you are eager loading table(s) (one of: designations, programs, user_identity_programs) that are referenced in a string SQL snippet. For example:



    Post.includes(:comments).where("comments.title = 'foo'")



Currently, Active Record recognizes the table in the string, and knows to JOIN the comments table to the query, rather than loading comments in a separate query. However, doing this without writing a full-blown SQL parser is inherently flawed. Since we don't want to write an SQL parser, we are removing this functionality. From now on, you must explicitly tell Active Record when you are referencing a table from a string:



    Post.includes(:comments).where("comments.title = 'foo'").references(:comments)



If you don't rely on implicit join references you can disable the feature entirely by setting `config.active_record.disable_implicit_join_references = true`. (called from designations_received? at /home/travis/build/Liaison-Intl/WebAdMIT/app/models/applicant.rb:941)

[32m.[0mDEPRECATION WARNING: It looks like you are eager loading table(s) (one of: scoring_models, scoring_model_assignments, programs) that are referenced in a string SQL snippet. For example:



    Post.includes(:comments).where("comments.title = 'foo'")



Currently, Active Record recognizes the table in the string, and knows to JOIN the comments table to the query, rather than loading comments in a separate query. However, doing this without writing a full-blown SQL parser is inherently flawed. Since we don't want to write an SQL parser, we are removing this functionality. From now on, you must explicitly tell Active Record when you are referencing a table from a string:



    Post.includes(:comments).where("comments.title = 'foo'").references(:comments)



If you don't rely on implicit join references you can disable the feature entirely by setting `config.active_record.disable_implicit_join_references = true`. (called from score_for_scoring_models at /home/travis/build/Liaison-Intl/WebAdMIT/app/models/scoring/scorer.rb:50)

DEPRECATION WARNING: It looks like you are eager loading table(s) (one of: designations, programs, user_identity_programs) that are referenced in a string SQL snippet. For example:



    Post.includes(:comments).where("comments.title = 'foo'")



Currently, Active Record recognizes the table in the string, and knows to JOIN the comments table to the query, rather than loading comments in a separate query. However, doing this without writing a full-blown SQL parser is inherently flawed. Since we don't want to write an SQL parser, we are removing this functionality. From now on, you must explicitly tell Active Record when you are referencing a table from a string:



    Post.includes(:comments).where("comments.title = 'foo'").references(:comments)



If you don't rely on implicit join references you can disable the feature entirely by setting `config.active_record.disable_implicit_join_references = true`. (called from designations_received? at /home/travis/build/Liaison-Intl/WebAdMIT/app/models/applicant.rb:941)

[32m.[0mDEPRECATION WARNING: It looks like you are eager loading table(s) (one of: scoring_models, scoring_model_assignments, programs) that are referenced in a string SQL snippet. For example:



    Post.includes(:comments).where("comments.title = 'foo'")



Currently, Active Record recognizes the table in the string, and knows to JOIN the comments table to the query, rather than loading comments in a separate query. However, doing this without writing a full-blown SQL parser is inherently flawed. Since we don't want to write an SQL parser, we are removing this functionality. From now on, you must explicitly tell Active Record when you are referencing a table from a string:



    Post.includes(:comments).where("comments.title = 'foo'").references(:comments)



If you don't rely on implicit join references you can disable the feature entirely by setting `config.active_record.disable_implicit_join_references = true`. (called from score_for_scoring_models at /home/travis/build/Liaison-Intl/WebAdMIT/app/models/scoring/scorer.rb:50)

DEPRECATION WARNING: It looks like you are eager loading table(s) (one of: designations, programs, user_identity_programs) that are referenced in a string SQL snippet. For example:



    Post.includes(:comments).where("comments.title = 'foo'")



Currently, Active Record recognizes the table in the string, and knows to JOIN the comments table to the query, rather than loading comments in a separate query. However, doing this without writing a full-blown SQL parser is inherently flawed. Since we don't want to write an SQL parser, we are removing this functionality. From now on, you must explicitly tell Active Record when you are referencing a table from a string:



    Post.includes(:comments).where("comments.title = 'foo'").references(:comments)



If you don't rely on implicit join references you can disable the feature entirely by setting `config.active_record.disable_implicit_join_references = true`. (called from designations_received? at /home/travis/build/Liaison-Intl/WebAdMIT/app/models/applicant.rb:941)

[32m.[0mDEPRECATION WARNING: It looks like you are eager loading table(s) (one of: scoring_models, scoring_model_assignments, programs) that are referenced in a string SQL snippet. For example:



    Post.includes(:comments).where("comments.title = 'foo'")



Currently, Active Record recognizes the table in the string, and knows to JOIN the comments table to the query, rather than loading comments in a separate query. However, doing this without writing a full-blown SQL parser is inherently flawed. Since we don't want to write an SQL parser, we are removing this functionality. From now on, you must explicitly tell Active Record when you are referencing a table from a string:



    Post.includes(:comments).where("comments.title = 'foo'").references(:comments)



If you don't rely on implicit join references you can disable the feature entirely by setting `config.active_record.disable_implicit_join_references = true`. (called from score_for_scoring_models at /home/travis/build/Liaison-Intl/WebAdMIT/app/models/scoring/scorer.rb:50)

DEPRECATION WARNING: It looks like you are eager loading table(s) (one of: designations, programs, user_identity_programs) that are referenced in a string SQL snippet. For example:



    Post.includes(:comments).where("comments.title = 'foo'")



Currently, Active Record recognizes the table in the string, and knows to JOIN the comments table to the query, rather than loading comments in a separate query. However, doing this without writing a full-blown SQL parser is inherently flawed. Since we don't want to write an SQL parser, we are removing this functionality. From now on, you must explicitly tell Active Record when you are referencing a table from a string:



    Post.includes(:comments).where("comments.title = 'foo'").references(:comments)



If you don't rely on implicit join references you can disable the feature entirely by setting `config.active_record.disable_implicit_join_references = true`. (called from designations_received? at /home/travis/build/Liaison-Intl/WebAdMIT/app/models/applicant.rb:941)

[32m.[0mDEPRECATION WARNING: It looks like you are eager loading table(s) (one of: scoring_models, scoring_model_assignments, programs) that are referenced in a string SQL snippet. For example:



    Post.includes(:comments).where("comments.title = 'foo'")



Currently, Active Record recognizes the table in the string, and knows to JOIN the comments table to the query, rather than loading comments in a separate query. However, doing this without writing a full-blown SQL parser is inherently flawed. Since we don't want to write an SQL parser, we are removing this functionality. From now on, you must explicitly tell Active Record when you are referencing a table from a string:



    Post.includes(:comments).where("comments.title = 'foo'").references(:comments)



If you don't rely on implicit join references you can disable the feature entirely by setting `config.active_record.disable_implicit_join_references = true`. (called from score_for_scoring_models at /home/travis/build/Liaison-Intl/WebAdMIT/app/models/scoring/scorer.rb:50)

DEPRECATION WARNING: It looks like you are eager loading table(s) (one of: designations, programs, user_identity_programs) that are referenced in a string SQL snippet. For example:



    Post.includes(:comments).where("comments.title = 'foo'")



Currently, Active Record recognizes the table in the string, and knows to JOIN the comments table to the query, rather than loading comments in a separate query. However, doing this without writing a full-blown SQL parser is inherently flawed. Since we don't want to write an SQL parser, we are removing this functionality. From now on, you must explicitly tell Active Record when you are referencing a table from a string:



    Post.includes(:comments).where("comments.title = 'foo'").references(:comments)



If you don't rely on implicit join references you can disable the feature entirely by setting `config.active_record.disable_implicit_join_references = true`. (called from designations_received? at /home/travis/build/Liaison-Intl/WebAdMIT/app/models/applicant.rb:941)

[32m.[0mDEPRECATION WARNING: It looks like you are eager loading table(s) (one of: scoring_models, scoring_model_assignments, programs) that are referenced in a string SQL snippet. For example:



    Post.includes(:comments).where("comments.title = 'foo'")



Currently, Active Record recognizes the table in the string, and knows to JOIN the comments table to the query, rather than loading comments in a separate query. However, doing this without writing a full-blown SQL parser is inherently flawed. Since we don't want to write an SQL parser, we are removing this functionality. From now on, you must explicitly tell Active Record when you are referencing a table from a string:



    Post.includes(:comments).where("comments.title = 'foo'").references(:comments)



If you don't rely on implicit join references you can disable the feature entirely by setting `config.active_record.disable_implicit_join_references = true`. (called from score_for_scoring_models at /home/travis/build/Liaison-Intl/WebAdMIT/app/models/scoring/scorer.rb:50)

DEPRECATION WARNING: It looks like you are eager loading table(s) (one of: scoring_models, scoring_model_assignments, programs) that are referenced in a string SQL snippet. For example:



    Post.includes(:comments).where("comments.title = 'foo'")



Currently, Active Record recognizes the table in the string, and knows to JOIN the comments table to the query, rather than loading comments in a separate query. However, doing this without writing a full-blown SQL parser is inherently flawed. Since we don't want to write an SQL parser, we are removing this functionality. From now on, you must explicitly tell Active Record when you are referencing a table from a string:



    Post.includes(:comments).where("comments.title = 'foo'").references(:comments)



If you don't rely on implicit join references you can disable the feature entirely by setting `config.active_record.disable_implicit_join_references = true`. (called from score_for_scoring_models at /home/travis/build/Liaison-Intl/WebAdMIT/app/models/scoring/scorer.rb:50)

DEPRECATION WARNING: It looks like you are eager loading table(s) (one of: designations, programs, user_identity_programs) that are referenced in a string SQL snippet. For example:



    Post.includes(:comments).where("comments.title = 'foo'")



Currently, Active Record recognizes the table in the string, and knows to JOIN the comments table to the query, rather than loading comments in a separate query. However, doing this without writing a full-blown SQL parser is inherently flawed. Since we don't want to write an SQL parser, we are removing this functionality. From now on, you must explicitly tell Active Record when you are referencing a table from a string:



    Post.includes(:comments).where("comments.title = 'foo'").references(:comments)



If you don't rely on implicit join references you can disable the feature entirely by setting `config.active_record.disable_implicit_join_references = true`. (called from designations_received? at /home/travis/build/Liaison-Intl/WebAdMIT/app/models/applicant.rb:941)

[32m.[0mDEPRECATION WARNING: It looks like you are eager loading table(s) (one of: scoring_models, scoring_model_assignments, programs) that are referenced in a string SQL snippet. For example:



    Post.includes(:comments).where("comments.title = 'foo'")



Currently, Active Record recognizes the table in the string, and knows to JOIN the comments table to the query, rather than loading comments in a separate query. However, doing this without writing a full-blown SQL parser is inherently flawed. Since we don't want to write an SQL parser, we are removing this functionality. From now on, you must explicitly tell Active Record when you are referencing a table from a string:



    Post.includes(:comments).where("comments.title = 'foo'").references(:comments)



If you don't rely on implicit join references you can disable the feature entirely by setting `config.active_record.disable_implicit_join_references = true`. (called from score_for_scoring_models at /home/travis/build/Liaison-Intl/WebAdMIT/app/models/scoring/scorer.rb:50)

DEPRECATION WARNING: It looks like you are eager loading table(s) (one of: scoring_models, scoring_model_assignments, programs) that are referenced in a string SQL snippet. For example:



    Post.includes(:comments).where("comments.title = 'foo'")



Currently, Active Record recognizes the table in the string, and knows to JOIN the comments table to the query, rather than loading comments in a separate query. However, doing this without writing a full-blown SQL parser is inherently flawed. Since we don't want to write an SQL parser, we are removing this functionality. From now on, you must explicitly tell Active Record when you are referencing a table from a string:



    Post.includes(:comments).where("comments.title = 'foo'").references(:comments)



If you don't rely on implicit join references you can disable the feature entirely by setting `config.active_record.disable_implicit_join_references = true`. (called from score_for_scoring_models at /home/travis/build/Liaison-Intl/WebAdMIT/app/models/scoring/scorer.rb:50)

DEPRECATION WARNING: It looks like you are eager loading table(s) (one of: designations, programs, user_identity_programs) that are referenced in a string SQL snippet. For example:



    Post.includes(:comments).where("comments.title = 'foo'")



Currently, Active Record recognizes the table in the string, and knows to JOIN the comments table to the query, rather than loading comments in a separate query. However, doing this without writing a full-blown SQL parser is inherently flawed. Since we don't want to write an SQL parser, we are removing this functionality. From now on, you must explicitly tell Active Record when you are referencing a table from a string:



    Post.includes(:comments).where("comments.title = 'foo'").references(:comments)



If you don't rely on implicit join references you can disable the feature entirely by setting `config.active_record.disable_implicit_join_references = true`. (called from designations_received? at /home/travis/build/Liaison-Intl/WebAdMIT/app/models/applicant.rb:941)

[32m.[0mDEPRECATION WARNING: It looks like you are eager loading table(s) (one of: scoring_models, scoring_model_assignments, programs) that are referenced in a string SQL snippet. For example:



    Post.includes(:comments).where("comments.title = 'foo'")



Currently, Active Record recognizes the table in the string, and knows to JOIN the comments table to the query, rather than loading comments in a separate query. However, doing this without writing a full-blown SQL parser is inherently flawed. Since we don't want to write an SQL parser, we are removing this functionality. From now on, you must explicitly tell Active Record when you are referencing a table from a string:



    Post.includes(:comments).where("comments.title = 'foo'").references(:comments)



If you don't rely on implicit join references you can disable the feature entirely by setting `config.active_record.disable_implicit_join_references = true`. (called from score_for_scoring_models at /home/travis/build/Liaison-Intl/WebAdMIT/app/models/scoring/scorer.rb:50)

DEPRECATION WARNING: It looks like you are eager loading table(s) (one of: scoring_models, scoring_model_assignments, programs) that are referenced in a string SQL snippet. For example:



    Post.includes(:comments).where("comments.title = 'foo'")



Currently, Active Record recognizes the table in the string, and knows to JOIN the comments table to the query, rather than loading comments in a separate query. However, doing this without writing a full-blown SQL parser is inherently flawed. Since we don't want to write an SQL parser, we are removing this functionality. From now on, you must explicitly tell Active Record when you are referencing a table from a string:



    Post.includes(:comments).where("comments.title = 'foo'").references(:comments)



If you don't rely on implicit join references you can disable the feature entirely by setting `config.active_record.disable_implicit_join_references = true`. (called from score_for_scoring_models at /home/travis/build/Liaison-Intl/WebAdMIT/app/models/scoring/scorer.rb:50)

DEPRECATION WARNING: It looks like you are eager loading table(s) (one of: designations, programs, user_identity_programs) that are referenced in a string SQL snippet. For example:



    Post.includes(:comments).where("comments.title = 'foo'")



Currently, Active Record recognizes the table in the string, and knows to JOIN the comments table to the query, rather than loading comments in a separate query. However, doing this without writing a full-blown SQL parser is inherently flawed. Since we don't want to write an SQL parser, we are removing this functionality. From now on, you must explicitly tell Active Record when you are referencing a table from a string:



    Post.includes(:comments).where("comments.title = 'foo'").references(:comments)



If you don't rely on implicit join references you can disable the feature entirely by setting `config.active_record.disable_implicit_join_references = true`. (called from designations_received? at /home/travis/build/Liaison-Intl/WebAdMIT/app/models/applicant.rb:941)

[32m.[0mDEPRECATION WARNING: It looks like you are eager loading table(s) (one of: scoring_models, scoring_model_assignments, programs) that are referenced in a string SQL snippet. For example:



    Post.includes(:comments).where("comments.title = 'foo'")



Currently, Active Record recognizes the table in the string, and knows to JOIN the comments table to the query, rather than loading comments in a separate query. However, doing this without writing a full-blown SQL parser is inherently flawed. Since we don't want to write an SQL parser, we are removing this functionality. From now on, you must explicitly tell Active Record when you are referencing a table from a string:



    Post.includes(:comments).where("comments.title = 'foo'").references(:comments)



If you don't rely on implicit join references you can disable the feature entirely by setting `config.active_record.disable_implicit_join_references = true`. (called from score_for_scoring_models at /home/travis/build/Liaison-Intl/WebAdMIT/app/models/scoring/scorer.rb:50)

DEPRECATION WARNING: It looks like you are eager loading table(s) (one of: designations, programs, user_identity_programs) that are referenced in a string SQL snippet. For example:



    Post.includes(:comments).where("comments.title = 'foo'")



Currently, Active Record recognizes the table in the string, and knows to JOIN the comments table to the query, rather than loading comments in a separate query. However, doing this without writing a full-blown SQL parser is inherently flawed. Since we don't want to write an SQL parser, we are removing this functionality. From now on, you must explicitly tell Active Record when you are referencing a table from a string:



    Post.includes(:comments).where("comments.title = 'foo'").references(:comments)



If you don't rely on implicit join references you can disable the feature entirely by setting `config.active_record.disable_implicit_join_references = true`. (called from designations_received? at /home/travis/build/Liaison-Intl/WebAdMIT/app/models/applicant.rb:941)

[32m.[0mDEPRECATION WARNING: It looks like you are eager loading table(s) (one of: scoring_models, scoring_model_assignments, programs) that are referenced in a string SQL snippet. For example:



    Post.includes(:comments).where("comments.title = 'foo'")



Currently, Active Record recognizes the table in the string, and knows to JOIN the comments table to the query, rather than loading comments in a separate query. However, doing this without writing a full-blown SQL parser is inherently flawed. Since we don't want to write an SQL parser, we are removing this functionality. From now on, you must explicitly tell Active Record when you are referencing a table from a string:



    Post.includes(:comments).where("comments.title = 'foo'").references(:comments)



If you don't rely on implicit join references you can disable the feature entirely by setting `config.active_record.disable_implicit_join_references = true`. (called from score_for_scoring_models at /home/travis/build/Liaison-Intl/WebAdMIT/app/models/scoring/scorer.rb:50)

DEPRECATION WARNING: It looks like you are eager loading table(s) (one of: scoring_models, scoring_model_assignments, programs) that are referenced in a string SQL snippet. For example:



    Post.includes(:comments).where("comments.title = 'foo'")



Currently, Active Record recognizes the table in the string, and knows to JOIN the comments table to the query, rather than loading comments in a separate query. However, doing this without writing a full-blown SQL parser is inherently flawed. Since we don't want to write an SQL parser, we are removing this functionality. From now on, you must explicitly tell Active Record when you are referencing a table from a string:



    Post.includes(:comments).where("comments.title = 'foo'").references(:comments)



If you don't rely on implicit join references you can disable the feature entirely by setting `config.active_record.disable_implicit_join_references = true`. (called from score_for_scoring_models at /home/travis/build/Liaison-Intl/WebAdMIT/app/models/scoring/scorer.rb:50)

DEPRECATION WARNING: It looks like you are eager loading table(s) (one of: designations, programs, user_identity_programs) that are referenced in a string SQL snippet. For example:



    Post.includes(:comments).where("comments.title = 'foo'")



Currently, Active Record recognizes the table in the string, and knows to JOIN the comments table to the query, rather than loading comments in a separate query. However, doing this without writing a full-blown SQL parser is inherently flawed. Since we don't want to write an SQL parser, we are removing this functionality. From now on, you must explicitly tell Active Record when you are referencing a table from a string:



    Post.includes(:comments).where("comments.title = 'foo'").references(:comments)



If you don't rely on implicit join references you can disable the feature entirely by setting `config.active_record.disable_implicit_join_references = true`. (called from designations_received? at /home/travis/build/Liaison-Intl/WebAdMIT/app/models/applicant.rb:941)

[32m.[0mDEPRECATION WARNING: It looks like you are eager loading table(s) (one of: scoring_models, scoring_model_assignments, programs) that are referenced in a string SQL snippet. For example:



    Post.includes(:comments).where("comments.title = 'foo'")



Currently, Active Record recognizes the table in the string, and knows to JOIN the comments table to the query, rather than loading comments in a separate query. However, doing this without writing a full-blown SQL parser is inherently flawed. Since we don't want to write an SQL parser, we are removing this functionality. From now on, you must explicitly tell Active Record when you are referencing a table from a string:



    Post.includes(:comments).where("comments.title = 'foo'").references(:comments)



If you don't rely on implicit join references you can disable the feature entirely by setting `config.active_record.disable_implicit_join_references = true`. (called from score_for_scoring_models at /home/travis/build/Liaison-Intl/WebAdMIT/app/models/scoring/scorer.rb:50)

DEPRECATION WARNING: It looks like you are eager loading table(s) (one of: designations, programs, user_identity_programs) that are referenced in a string SQL snippet. For example:



    Post.includes(:comments).where("comments.title = 'foo'")



Currently, Active Record recognizes the table in the string, and knows to JOIN the comments table to the query, rather than loading comments in a separate query. However, doing this without writing a full-blown SQL parser is inherently flawed. Since we don't want to write an SQL parser, we are removing this functionality. From now on, you must explicitly tell Active Record when you are referencing a table from a string:



    Post.includes(:comments).where("comments.title = 'foo'").references(:comments)



If you don't rely on implicit join references you can disable the feature entirely by setting `config.active_record.disable_implicit_join_references = true`. (called from designations_received? at /home/travis/build/Liaison-Intl/WebAdMIT/app/models/applicant.rb:941)

[32m.[0mDEPRECATION WARNING: It looks like you are eager loading table(s) (one of: scoring_models, scoring_model_assignments, programs) that are referenced in a string SQL snippet. For example:



    Post.includes(:comments).where("comments.title = 'foo'")



Currently, Active Record recognizes the table in the string, and knows to JOIN the comments table to the query, rather than loading comments in a separate query. However, doing this without writing a full-blown SQL parser is inherently flawed. Since we don't want to write an SQL parser, we are removing this functionality. From now on, you must explicitly tell Active Record when you are referencing a table from a string:



    Post.includes(:comments).where("comments.title = 'foo'").references(:comments)



If you don't rely on implicit join references you can disable the feature entirely by setting `config.active_record.disable_implicit_join_references = true`. (called from score_for_scoring_models at /home/travis/build/Liaison-Intl/WebAdMIT/app/models/scoring/scorer.rb:50)

DEPRECATION WARNING: It looks like you are eager loading table(s) (one of: scoring_models, scoring_model_assignments, programs) that are referenced in a string SQL snippet. For example:



    Post.includes(:comments).where("comments.title = 'foo'")



Currently, Active Record recognizes the table in the string, and knows to JOIN the comments table to the query, rather than loading comments in a separate query. However, doing this without writing a full-blown SQL parser is inherently flawed. Since we don't want to write an SQL parser, we are removing this functionality. From now on, you must explicitly tell Active Record when you are referencing a table from a string:



    Post.includes(:comments).where("comments.title = 'foo'").references(:comments)



If you don't rely on implicit join references you can disable the feature entirely by setting `config.active_record.disable_implicit_join_references = true`. (called from score_for_scoring_models at /home/travis/build/Liaison-Intl/WebAdMIT/app/models/scoring/scorer.rb:50)

DEPRECATION WARNING: It looks like you are eager loading table(s) (one of: designations, programs, user_identity_programs) that are referenced in a string SQL snippet. For example:



    Post.includes(:comments).where("comments.title = 'foo'")



Currently, Active Record recognizes the table in the string, and knows to JOIN the comments table to the query, rather than loading comments in a separate query. However, doing this without writing a full-blown SQL parser is inherently flawed. Since we don't want to write an SQL parser, we are removing this functionality. From now on, you must explicitly tell Active Record when you are referencing a table from a string:



    Post.includes(:comments).where("comments.title = 'foo'").references(:comments)



If you don't rely on implicit join references you can disable the feature entirely by setting `config.active_record.disable_implicit_join_references = true`. (called from designations_received? at /home/travis/build/Liaison-Intl/WebAdMIT/app/models/applicant.rb:941)

[32m.[0mDEPRECATION WARNING: It looks like you are eager loading table(s) (one of: scoring_models, scoring_model_assignments, programs) that are referenced in a string SQL snippet. For example:



    Post.includes(:comments).where("comments.title = 'foo'")



Currently, Active Record recognizes the table in the string, and knows to JOIN the comments table to the query, rather than loading comments in a separate query. However, doing this without writing a full-blown SQL parser is inherently flawed. Since we don't want to write an SQL parser, we are removing this functionality. From now on, you must explicitly tell Active Record when you are referencing a table from a string:



    Post.includes(:comments).where("comments.title = 'foo'").references(:comments)



If you don't rely on implicit join references you can disable the feature entirely by setting `config.active_record.disable_implicit_join_references = true`. (called from score_for_scoring_models at /home/travis/build/Liaison-Intl/WebAdMIT/app/models/scoring/scorer.rb:50)

DEPRECATION WARNING: It looks like you are eager loading table(s) (one of: scoring_models, scoring_model_assignments, programs) that are referenced in a string SQL snippet. For example:



    Post.includes(:comments).where("comments.title = 'foo'")



Currently, Active Record recognizes the table in the string, and knows to JOIN the comments table to the query, rather than loading comments in a separate query. However, doing this without writing a full-blown SQL parser is inherently flawed. Since we don't want to write an SQL parser, we are removing this functionality. From now on, you must explicitly tell Active Record when you are referencing a table from a string:



    Post.includes(:comments).where("comments.title = 'foo'").references(:comments)



If you don't rely on implicit join references you can disable the feature entirely by setting `config.active_record.disable_implicit_join_references = true`. (called from score_for_scoring_models at /home/travis/build/Liaison-Intl/WebAdMIT/app/models/scoring/scorer.rb:50)

DEPRECATION WARNING: It looks like you are eager loading table(s) (one of: designations, programs, user_identity_programs) that are referenced in a string SQL snippet. For example:



    Post.includes(:comments).where("comments.title = 'foo'")



Currently, Active Record recognizes the table in the string, and knows to JOIN the comments table to the query, rather than loading comments in a separate query. However, doing this without writing a full-blown SQL parser is inherently flawed. Since we don't want to write an SQL parser, we are removing this functionality. From now on, you must explicitly tell Active Record when you are referencing a table from a string:



    Post.includes(:comments).where("comments.title = 'foo'").references(:comments)



If you don't rely on implicit join references you can disable the feature entirely by setting `config.active_record.disable_implicit_join_references = true`. (called from designations_received? at /home/travis/build/Liaison-Intl/WebAdMIT/app/models/applicant.rb:941)

[32m.[0mDEPRECATION WARNING: It looks like you are eager loading table(s) (one of: scoring_models, scoring_model_assignments, programs) that are referenced in a string SQL snippet. For example:



    Post.includes(:comments).where("comments.title = 'foo'")



Currently, Active Record recognizes the table in the string, and knows to JOIN the comments table to the query, rather than loading comments in a separate query. However, doing this without writing a full-blown SQL parser is inherently flawed. Since we don't want to write an SQL parser, we are removing this functionality. From now on, you must explicitly tell Active Record when you are referencing a table from a string:



    Post.includes(:comments).where("comments.title = 'foo'").references(:comments)



If you don't rely on implicit join references you can disable the feature entirely by setting `config.active_record.disable_implicit_join_references = true`. (called from score_for_scoring_models at /home/travis/build/Liaison-Intl/WebAdMIT/app/models/scoring/scorer.rb:50)

DEPRECATION WARNING: It looks like you are eager loading table(s) (one of: scoring_models, scoring_model_assignments, programs) that are referenced in a string SQL snippet. For example:



    Post.includes(:comments).where("comments.title = 'foo'")



Currently, Active Record recognizes the table in the string, and knows to JOIN the comments table to the query, rather than loading comments in a separate query. However, doing this without writing a full-blown SQL parser is inherently flawed. Since we don't want to write an SQL parser, we are removing this functionality. From now on, you must explicitly tell Active Record when you are referencing a table from a string:



    Post.includes(:comments).where("comments.title = 'foo'").references(:comments)



If you don't rely on implicit join references you can disable the feature entirely by setting `config.active_record.disable_implicit_join_references = true`. (called from score_for_scoring_models at /home/travis/build/Liaison-Intl/WebAdMIT/app/models/scoring/scorer.rb:50)

DEPRECATION WARNING: It looks like you are eager loading table(s) (one of: designations, programs, user_identity_programs) that are referenced in a string SQL snippet. For example:



    Post.includes(:comments).where("comments.title = 'foo'")



Currently, Active Record recognizes the table in the string, and knows to JOIN the comments table to the query, rather than loading comments in a separate query. However, doing this without writing a full-blown SQL parser is inherently flawed. Since we don't want to write an SQL parser, we are removing this functionality. From now on, you must explicitly tell Active Record when you are referencing a table from a string:



    Post.includes(:comments).where("comments.title = 'foo'").references(:comments)



If you don't rely on implicit join references you can disable the feature entirely by setting `config.active_record.disable_implicit_join_references = true`. (called from designations_received? at /home/travis/build/Liaison-Intl/WebAdMIT/app/models/applicant.rb:941)

[32m.[0mDEPRECATION WARNING: It looks like you are eager loading table(s) (one of: scoring_models, scoring_model_assignments, programs) that are referenced in a string SQL snippet. For example:



    Post.includes(:comments).where("comments.title = 'foo'")



Currently, Active Record recognizes the table in the string, and knows to JOIN the comments table to the query, rather than loading comments in a separate query. However, doing this without writing a full-blown SQL parser is inherently flawed. Since we don't want to write an SQL parser, we are removing this functionality. From now on, you must explicitly tell Active Record when you are referencing a table from a string:



    Post.includes(:comments).where("comments.title = 'foo'").references(:comments)



If you don't rely on implicit join references you can disable the feature entirely by setting `config.active_record.disable_implicit_join_references = true`. (called from score_for_scoring_models at /home/travis/build/Liaison-Intl/WebAdMIT/app/models/scoring/scorer.rb:50)

DEPRECATION WARNING: It looks like you are eager loading table(s) (one of: scoring_models, scoring_model_assignments, programs) that are referenced in a string SQL snippet. For example:



    Post.includes(:comments).where("comments.title = 'foo'")



Currently, Active Record recognizes the table in the string, and knows to JOIN the comments table to the query, rather than loading comments in a separate query. However, doing this without writing a full-blown SQL parser is inherently flawed. Since we don't want to write an SQL parser, we are removing this functionality. From now on, you must explicitly tell Active Record when you are referencing a table from a string:



    Post.includes(:comments).where("comments.title = 'foo'").references(:comments)



If you don't rely on implicit join references you can disable the feature entirely by setting `config.active_record.disable_implicit_join_references = true`. (called from score_for_scoring_models at /home/travis/build/Liaison-Intl/WebAdMIT/app/models/scoring/scorer.rb:50)

DEPRECATION WARNING: It looks like you are eager loading table(s) (one of: designations, programs, user_identity_programs) that are referenced in a string SQL snippet. For example:



    Post.includes(:comments).where("comments.title = 'foo'")



Currently, Active Record recognizes the table in the string, and knows to JOIN the comments table to the query, rather than loading comments in a separate query. However, doing this without writing a full-blown SQL parser is inherently flawed. Since we don't want to write an SQL parser, we are removing this functionality. From now on, you must explicitly tell Active Record when you are referencing a table from a string:



    Post.includes(:comments).where("comments.title = 'foo'").references(:comments)



If you don't rely on implicit join references you can disable the feature entirely by setting `config.active_record.disable_implicit_join_references = true`. (called from designations_received? at /home/travis/build/Liaison-Intl/WebAdMIT/app/models/applicant.rb:941)

[32m.[0mDEPRECATION WARNING: It looks like you are eager loading table(s) (one of: scoring_models, scoring_model_assignments, programs) that are referenced in a string SQL snippet. For example:



    Post.includes(:comments).where("comments.title = 'foo'")



Currently, Active Record recognizes the table in the string, and knows to JOIN the comments table to the query, rather than loading comments in a separate query. However, doing this without writing a full-blown SQL parser is inherently flawed. Since we don't want to write an SQL parser, we are removing this functionality. From now on, you must explicitly tell Active Record when you are referencing a table from a string:



    Post.includes(:comments).where("comments.title = 'foo'").references(:comments)



If you don't rely on implicit join references you can disable the feature entirely by setting `config.active_record.disable_implicit_join_references = true`. (called from score_for_scoring_models at /home/travis/build/Liaison-Intl/WebAdMIT/app/models/scoring/scorer.rb:50)

DEPRECATION WARNING: It looks like you are eager loading table(s) (one of: scoring_models, scoring_model_assignments, programs) that are referenced in a string SQL snippet. For example:



    Post.includes(:comments).where("comments.title = 'foo'")



Currently, Active Record recognizes the table in the string, and knows to JOIN the comments table to the query, rather than loading comments in a separate query. However, doing this without writing a full-blown SQL parser is inherently flawed. Since we don't want to write an SQL parser, we are removing this functionality. From now on, you must explicitly tell Active Record when you are referencing a table from a string:



    Post.includes(:comments).where("comments.title = 'foo'").references(:comments)



If you don't rely on implicit join references you can disable the feature entirely by setting `config.active_record.disable_implicit_join_references = true`. (called from score_for_scoring_models at /home/travis/build/Liaison-Intl/WebAdMIT/app/models/scoring/scorer.rb:50)

DEPRECATION WARNING: It looks like you are eager loading table(s) (one of: designations, programs, user_identity_programs) that are referenced in a string SQL snippet. For example:



    Post.includes(:comments).where("comments.title = 'foo'")



Currently, Active Record recognizes the table in the string, and knows to JOIN the comments table to the query, rather than loading comments in a separate query. However, doing this without writing a full-blown SQL parser is inherently flawed. Since we don't want to write an SQL parser, we are removing this functionality. From now on, you must explicitly tell Active Record when you are referencing a table from a string:



    Post.includes(:comments).where("comments.title = 'foo'").references(:comments)



If you don't rely on implicit join references you can disable the feature entirely by setting `config.active_record.disable_implicit_join_references = true`. (called from designations_received? at /home/travis/build/Liaison-Intl/WebAdMIT/app/models/applicant.rb:941)

[32m.[0mDEPRECATION WARNING: It looks like you are eager loading table(s) (one of: scoring_models, scoring_model_assignments, programs) that are referenced in a string SQL snippet. For example:



    Post.includes(:comments).where("comments.title = 'foo'")



Currently, Active Record recognizes the table in the string, and knows to JOIN the comments table to the query, rather than loading comments in a separate query. However, doing this without writing a full-blown SQL parser is inherently flawed. Since we don't want to write an SQL parser, we are removing this functionality. From now on, you must explicitly tell Active Record when you are referencing a table from a string:



    Post.includes(:comments).where("comments.title = 'foo'").references(:comments)



If you don't rely on implicit join references you can disable the feature entirely by setting `config.active_record.disable_implicit_join_references = true`. (called from score_for_scoring_models at /home/travis/build/Liaison-Intl/WebAdMIT/app/models/scoring/scorer.rb:50)

DEPRECATION WARNING: It looks like you are eager loading table(s) (one of: scoring_models, scoring_model_assignments, programs) that are referenced in a string SQL snippet. For example:



    Post.includes(:comments).where("comments.title = 'foo'")



Currently, Active Record recognizes the table in the string, and knows to JOIN the comments table to the query, rather than loading comments in a separate query. However, doing this without writing a full-blown SQL parser is inherently flawed. Since we don't want to write an SQL parser, we are removing this functionality. From now on, you must explicitly tell Active Record when you are referencing a table from a string:



    Post.includes(:comments).where("comments.title = 'foo'").references(:comments)



If you don't rely on implicit join references you can disable the feature entirely by setting `config.active_record.disable_implicit_join_references = true`. (called from score_for_scoring_models at /home/travis/build/Liaison-Intl/WebAdMIT/app/models/scoring/scorer.rb:50)

DEPRECATION WARNING: It looks like you are eager loading table(s) (one of: designations, programs, user_identity_programs) that are referenced in a string SQL snippet. For example:



    Post.includes(:comments).where("comments.title = 'foo'")



Currently, Active Record recognizes the table in the string, and knows to JOIN the comments table to the query, rather than loading comments in a separate query. However, doing this without writing a full-blown SQL parser is inherently flawed. Since we don't want to write an SQL parser, we are removing this functionality. From now on, you must explicitly tell Active Record when you are referencing a table from a string:



    Post.includes(:comments).where("comments.title = 'foo'").references(:comments)



If you don't rely on implicit join references you can disable the feature entirely by setting `config.active_record.disable_implicit_join_references = true`. (called from designations_received? at /home/travis/build/Liaison-Intl/WebAdMIT/app/models/applicant.rb:941)

[32m.[0m[32m.[0m[32m.[0mDEPRECATION WARNING: It looks like you are eager loading table(s) (one of: scoring_models, scoring_model_assignments, programs) that are referenced in a string SQL snippet. For example:



    Post.includes(:comments).where("comments.title = 'foo'")



Currently, Active Record recognizes the table in the string, and knows to JOIN the comments table to the query, rather than loading comments in a separate query. However, doing this without writing a full-blown SQL parser is inherently flawed. Since we don't want to write an SQL parser, we are removing this functionality. From now on, you must explicitly tell Active Record when you are referencing a table from a string:



    Post.includes(:comments).where("comments.title = 'foo'").references(:comments)



If you don't rely on implicit join references you can disable the feature entirely by setting `config.active_record.disable_implicit_join_references = true`. (called from score_for_scoring_models at /home/travis/build/Liaison-Intl/WebAdMIT/app/models/scoring/scorer.rb:50)

DEPRECATION WARNING: It looks like you are eager loading table(s) (one of: scoring_models, scoring_model_assignments, programs) that are referenced in a string SQL snippet. For example:



    Post.includes(:comments).where("comments.title = 'foo'")



Currently, Active Record recognizes the table in the string, and knows to JOIN the comments table to the query, rather than loading comments in a separate query. However, doing this without writing a full-blown SQL parser is inherently flawed. Since we don't want to write an SQL parser, we are removing this functionality. From now on, you must explicitly tell Active Record when you are referencing a table from a string:



    Post.includes(:comments).where("comments.title = 'foo'").references(:comments)



If you don't rely on implicit join references you can disable the feature entirely by setting `config.active_record.disable_implicit_join_references = true`. (called from score_for_scoring_models at /home/travis/build/Liaison-Intl/WebAdMIT/app/models/scoring/scorer.rb:50)

DEPRECATION WARNING: It looks like you are eager loading table(s) (one of: scoring_models, scoring_model_assignments, programs) that are referenced in a string SQL snippet. For example:



    Post.includes(:comments).where("comments.title = 'foo'")



Currently, Active Record recognizes the table in the string, and knows to JOIN the comments table to the query, rather than loading comments in a separate query. However, doing this without writing a full-blown SQL parser is inherently flawed. Since we don't want to write an SQL parser, we are removing this functionality. From now on, you must explicitly tell Active Record when you are referencing a table from a string:



    Post.includes(:comments).where("comments.title = 'foo'").references(:comments)



If you don't rely on implicit join references you can disable the feature entirely by setting `config.active_record.disable_implicit_join_references = true`. (called from score_for_scoring_models at /home/travis/build/Liaison-Intl/WebAdMIT/app/models/scoring/scorer.rb:50)

DEPRECATION WARNING: Relation#all is deprecated. If you want to eager-load a relation, you can call #load (e.g. `Post.where(published: true).load`). If you want to get an array of records from a relation, you can call #to_a (e.g. `Post.where(published: true).to_a`). (called from _app_views_lists_show_html_haml___2214543903039240092_516440520 at /home/travis/build/Liaison-Intl/WebAdMIT/app/views/lists/show.html.haml:9)

DEPRECATION WARNING: It looks like you are eager loading table(s) (one of: scoring_models, scoring_model_assignments, programs) that are referenced in a string SQL snippet. For example:



    Post.includes(:comments).where("comments.title = 'foo'")



Currently, Active Record recognizes the table in the string, and knows to JOIN the comments table to the query, rather than loading comments in a separate query. However, doing this without writing a full-blown SQL parser is inherently flawed. Since we don't want to write an SQL parser, we are removing this functionality. From now on, you must explicitly tell Active Record when you are referencing a table from a string:



    Post.includes(:comments).where("comments.title = 'foo'").references(:comments)



If you don't rely on implicit join references you can disable the feature entirely by setting `config.active_record.disable_implicit_join_references = true`. (called from score_for_scoring_models at /home/travis/build/Liaison-Intl/WebAdMIT/app/models/scoring/scorer.rb:50)

DEPRECATION WARNING: It looks like you are eager loading table(s) (one of: scoring_models, scoring_model_assignments, programs) that are referenced in a string SQL snippet. For example:



    Post.includes(:comments).where("comments.title = 'foo'")



Currently, Active Record recognizes the table in the string, and knows to JOIN the comments table to the query, rather than loading comments in a separate query. However, doing this without writing a full-blown SQL parser is inherently flawed. Since we don't want to write an SQL parser, we are removing this functionality. From now on, you must explicitly tell Active Record when you are referencing a table from a string:



    Post.includes(:comments).where("comments.title = 'foo'").references(:comments)



If you don't rely on implicit join references you can disable the feature entirely by setting `config.active_record.disable_implicit_join_references = true`. (called from score_for_scoring_models at /home/travis/build/Liaison-Intl/WebAdMIT/app/models/scoring/scorer.rb:50)

[32m.[0mDEPRECATION WARNING: It looks like you are eager loading table(s) (one of: scoring_models, scoring_model_assignments, programs) that are referenced in a string SQL snippet. For example:



    Post.includes(:comments).where("comments.title = 'foo'")



Currently, Active Record recognizes the table in the string, and knows to JOIN the comments table to the query, rather than loading comments in a separate query. However, doing this without writing a full-blown SQL parser is inherently flawed. Since we don't want to write an SQL parser, we are removing this functionality. From now on, you must explicitly tell Active Record when you are referencing a table from a string:



    Post.includes(:comments).where("comments.title = 'foo'").references(:comments)



If you don't rely on implicit join references you can disable the feature entirely by setting `config.active_record.disable_implicit_join_references = true`. (called from score_for_scoring_models at /home/travis/build/Liaison-Intl/WebAdMIT/app/models/scoring/scorer.rb:50)

[32m.[0mDEPRECATION WARNING: It looks like you are eager loading table(s) (one of: scoring_models, scoring_model_assignments, programs) that are referenced in a string SQL snippet. For example:



    Post.includes(:comments).where("comments.title = 'foo'")



Currently, Active Record recognizes the table in the string, and knows to JOIN the comments table to the query, rather than loading comments in a separate query. However, doing this without writing a full-blown SQL parser is inherently flawed. Since we don't want to write an SQL parser, we are removing this functionality. From now on, you must explicitly tell Active Record when you are referencing a table from a string:



    Post.includes(:comments).where("comments.title = 'foo'").references(:comments)



If you don't rely on implicit join references you can disable the feature entirely by setting `config.active_record.disable_implicit_join_references = true`. (called from score_for_scoring_models at /home/travis/build/Liaison-Intl/WebAdMIT/app/models/scoring/scorer.rb:50)

[32m.[0mDEPRECATION WARNING: It looks like you are eager loading table(s) (one of: scoring_models, scoring_model_assignments, programs) that are referenced in a string SQL snippet. For example:



    Post.includes(:comments).where("comments.title = 'foo'")



Currently, Active Record recognizes the table in the string, and knows to JOIN the comments table to the query, rather than loading comments in a separate query. However, doing this without writing a full-blown SQL parser is inherently flawed. Since we don't want to write an SQL parser, we are removing this functionality. From now on, you must explicitly tell Active Record when you are referencing a table from a string:



    Post.includes(:comments).where("comments.title = 'foo'").references(:comments)



If you don't rely on implicit join references you can disable the feature entirely by setting `config.active_record.disable_implicit_join_references = true`. (called from score_for_scoring_models at /home/travis/build/Liaison-Intl/WebAdMIT/app/models/scoring/scorer.rb:50)

[32m.[0mDEPRECATION WARNING: It looks like you are eager loading table(s) (one of: scoring_models, scoring_model_assignments, programs) that are referenced in a string SQL snippet. For example:



    Post.includes(:comments).where("comments.title = 'foo'")



Currently, Active Record recognizes the table in the string, and knows to JOIN the comments table to the query, rather than loading comments in a separate query. However, doing this without writing a full-blown SQL parser is inherently flawed. Since we don't want to write an SQL parser, we are removing this functionality. From now on, you must explicitly tell Active Record when you are referencing a table from a string:



    Post.includes(:comments).where("comments.title = 'foo'").references(:comments)



If you don't rely on implicit join references you can disable the feature entirely by setting `config.active_record.disable_implicit_join_references = true`. (called from score_for_scoring_models at /home/travis/build/Liaison-Intl/WebAdMIT/app/models/scoring/scorer.rb:50)

[32m.[0mDEPRECATION WARNING: It looks like you are eager loading table(s) (one of: scoring_models, scoring_model_assignments, programs) that are referenced in a string SQL snippet. For example:



    Post.includes(:comments).where("comments.title = 'foo'")



Currently, Active Record recognizes the table in the string, and knows to JOIN the comments table to the query, rather than loading comments in a separate query. However, doing this without writing a full-blown SQL parser is inherently flawed. Since we don't want to write an SQL parser, we are removing this functionality. From now on, you must explicitly tell Active Record when you are referencing a table from a string:



    Post.includes(:comments).where("comments.title = 'foo'").references(:comments)



If you don't rely on implicit join references you can disable the feature entirely by setting `config.active_record.disable_implicit_join_references = true`. (called from score_for_scoring_models at /home/travis/build/Liaison-Intl/WebAdMIT/app/models/scoring/scorer.rb:50)

[32m.[0mDEPRECATION WARNING: It looks like you are eager loading table(s) (one of: scoring_models, scoring_model_assignments, programs) that are referenced in a string SQL snippet. For example:



    Post.includes(:comments).where("comments.title = 'foo'")



Currently, Active Record recognizes the table in the string, and knows to JOIN the comments table to the query, rather than loading comments in a separate query. However, doing this without writing a full-blown SQL parser is inherently flawed. Since we don't want to write an SQL parser, we are removing this functionality. From now on, you must explicitly tell Active Record when you are referencing a table from a string:



    Post.includes(:comments).where("comments.title = 'foo'").references(:comments)



If you don't rely on implicit join references you can disable the feature entirely by setting `config.active_record.disable_implicit_join_references = true`. (called from score_for_scoring_models at /home/travis/build/Liaison-Intl/WebAdMIT/app/models/scoring/scorer.rb:50)

[32m.[0mDEPRECATION WARNING: It looks like you are eager loading table(s) (one of: scoring_models, scoring_model_assignments, programs) that are referenced in a string SQL snippet. For example:



    Post.includes(:comments).where("comments.title = 'foo'")



Currently, Active Record recognizes the table in the string, and knows to JOIN the comments table to the query, rather than loading comments in a separate query. However, doing this without writing a full-blown SQL parser is inherently flawed. Since we don't want to write an SQL parser, we are removing this functionality. From now on, you must explicitly tell Active Record when you are referencing a table from a string:



    Post.includes(:comments).where("comments.title = 'foo'").references(:comments)



If you don't rely on implicit join references you can disable the feature entirely by setting `config.active_record.disable_implicit_join_references = true`. (called from score_for_scoring_models at /home/travis/build/Liaison-Intl/WebAdMIT/app/models/scoring/scorer.rb:50)

[32m.[0mDEPRECATION WARNING: It looks like you are eager loading table(s) (one of: scoring_models, scoring_model_assignments, programs) that are referenced in a string SQL snippet. For example:



    Post.includes(:comments).where("comments.title = 'foo'")



Currently, Active Record recognizes the table in the string, and knows to JOIN the comments table to the query, rather than loading comments in a separate query. However, doing this without writing a full-blown SQL parser is inherently flawed. Since we don't want to write an SQL parser, we are removing this functionality. From now on, you must explicitly tell Active Record when you are referencing a table from a string:



    Post.includes(:comments).where("comments.title = 'foo'").references(:comments)



If you don't rely on implicit join references you can disable the feature entirely by setting `config.active_record.disable_implicit_join_references = true`. (called from score_for_scoring_models at /home/travis/build/Liaison-Intl/WebAdMIT/app/models/scoring/scorer.rb:50)

DEPRECATION WARNING: It looks like you are eager loading table(s) (one of: scoring_models, scoring_model_assignments, programs) that are referenced in a string SQL snippet. For example:



    Post.includes(:comments).where("comments.title = 'foo'")



Currently, Active Record recognizes the table in the string, and knows to JOIN the comments table to the query, rather than loading comments in a separate query. However, doing this without writing a full-blown SQL parser is inherently flawed. Since we don't want to write an SQL parser, we are removing this functionality. From now on, you must explicitly tell Active Record when you are referencing a table from a string:



    Post.includes(:comments).where("comments.title = 'foo'").references(:comments)



If you don't rely on implicit join references you can disable the feature entirely by setting `config.active_record.disable_implicit_join_references = true`. (called from score_for_scoring_models at /home/travis/build/Liaison-Intl/WebAdMIT/app/models/scoring/scorer.rb:50)

DEPRECATION WARNING: It looks like you are eager loading table(s) (one of: designations, programs, user_identity_programs) that are referenced in a string SQL snippet. For example:



    Post.includes(:comments).where("comments.title = 'foo'")



Currently, Active Record recognizes the table in the string, and knows to JOIN the comments table to the query, rather than loading comments in a separate query. However, doing this without writing a full-blown SQL parser is inherently flawed. Since we don't want to write an SQL parser, we are removing this functionality. From now on, you must explicitly tell Active Record when you are referencing a table from a string:



    Post.includes(:comments).where("comments.title = 'foo'").references(:comments)



If you don't rely on implicit join references you can disable the feature entirely by setting `config.active_record.disable_implicit_join_references = true`. (called from designations_received? at /home/travis/build/Liaison-Intl/WebAdMIT/app/models/applicant.rb:941)

DEPRECATION WARNING: It looks like you are eager loading table(s) (one of: designations, programs, user_identity_programs) that are referenced in a string SQL snippet. For example:



    Post.includes(:comments).where("comments.title = 'foo'")



Currently, Active Record recognizes the table in the string, and knows to JOIN the comments table to the query, rather than loading comments in a separate query. However, doing this without writing a full-blown SQL parser is inherently flawed. Since we don't want to write an SQL parser, we are removing this functionality. From now on, you must explicitly tell Active Record when you are referencing a table from a string:



    Post.includes(:comments).where("comments.title = 'foo'").references(:comments)



If you don't rely on implicit join references you can disable the feature entirely by setting `config.active_record.disable_implicit_join_references = true`. (called from designations_received? at /home/travis/build/Liaison-Intl/WebAdMIT/app/models/applicant.rb:941)

DEPRECATION WARNING: It looks like you are eager loading table(s) (one of: designations, programs, user_identity_programs) that are referenced in a string SQL snippet. For example:



    Post.includes(:comments).where("comments.title = 'foo'")



Currently, Active Record recognizes the table in the string, and knows to JOIN the comments table to the query, rather than loading comments in a separate query. However, doing this without writing a full-blown SQL parser is inherently flawed. Since we don't want to write an SQL parser, we are removing this functionality. From now on, you must explicitly tell Active Record when you are referencing a table from a string:



    Post.includes(:comments).where("comments.title = 'foo'").references(:comments)



If you don't rely on implicit join references you can disable the feature entirely by setting `config.active_record.disable_implicit_join_references = true`. (called from designations_received? at /home/travis/build/Liaison-Intl/WebAdMIT/app/models/applicant.rb:941)

DEPRECATION WARNING: It looks like you are eager loading table(s) (one of: designations, programs, user_identity_programs) that are referenced in a string SQL snippet. For example:



    Post.includes(:comments).where("comments.title = 'foo'")



Currently, Active Record recognizes the table in the string, and knows to JOIN the comments table to the query, rather than loading comments in a separate query. However, doing this without writing a full-blown SQL parser is inherently flawed. Since we don't want to write an SQL parser, we are removing this functionality. From now on, you must explicitly tell Active Record when you are referencing a table from a string:



    Post.includes(:comments).where("comments.title = 'foo'").references(:comments)



If you don't rely on implicit join references you can disable the feature entirely by setting `config.active_record.disable_implicit_join_references = true`. (called from designations_received? at /home/travis/build/Liaison-Intl/WebAdMIT/app/models/applicant.rb:941)

[32m.[0mDEPRECATION WARNING: It looks like you are eager loading table(s) (one of: scoring_models, scoring_model_assignments, programs) that are referenced in a string SQL snippet. For example:



    Post.includes(:comments).where("comments.title = 'foo'")



Currently, Active Record recognizes the table in the string, and knows to JOIN the comments table to the query, rather than loading comments in a separate query. However, doing this without writing a full-blown SQL parser is inherently flawed. Since we don't want to write an SQL parser, we are removing this functionality. From now on, you must explicitly tell Active Record when you are referencing a table from a string:



    Post.includes(:comments).where("comments.title = 'foo'").references(:comments)



If you don't rely on implicit join references you can disable the feature entirely by setting `config.active_record.disable_implicit_join_references = true`. (called from score_for_scoring_models at /home/travis/build/Liaison-Intl/WebAdMIT/app/models/scoring/scorer.rb:50)

DEPRECATION WARNING: It looks like you are eager loading table(s) (one of: scoring_models, scoring_model_assignments, programs) that are referenced in a string SQL snippet. For example:



    Post.includes(:comments).where("comments.title = 'foo'")



Currently, Active Record recognizes the table in the string, and knows to JOIN the comments table to the query, rather than loading comments in a separate query. However, doing this without writing a full-blown SQL parser is inherently flawed. Since we don't want to write an SQL parser, we are removing this functionality. From now on, you must explicitly tell Active Record when you are referencing a table from a string:



    Post.includes(:comments).where("comments.title = 'foo'").references(:comments)



If you don't rely on implicit join references you can disable the feature entirely by setting `config.active_record.disable_implicit_join_references = true`. (called from score_for_scoring_models at /home/travis/build/Liaison-Intl/WebAdMIT/app/models/scoring/scorer.rb:50)

DEPRECATION WARNING: It looks like you are eager loading table(s) (one of: designations, programs, user_identity_programs) that are referenced in a string SQL snippet. For example:



    Post.includes(:comments).where("comments.title = 'foo'")



Currently, Active Record recognizes the table in the string, and knows to JOIN the comments table to the query, rather than loading comments in a separate query. However, doing this without writing a full-blown SQL parser is inherently flawed. Since we don't want to write an SQL parser, we are removing this functionality. From now on, you must explicitly tell Active Record when you are referencing a table from a string:



    Post.includes(:comments).where("comments.title = 'foo'").references(:comments)



If you don't rely on implicit join references you can disable the feature entirely by setting `config.active_record.disable_implicit_join_references = true`. (called from designations_received? at /home/travis/build/Liaison-Intl/WebAdMIT/app/models/applicant.rb:941)

DEPRECATION WARNING: It looks like you are eager loading table(s) (one of: designations, programs, user_identity_programs) that are referenced in a string SQL snippet. For example:



    Post.includes(:comments).where("comments.title = 'foo'")



Currently, Active Record recognizes the table in the string, and knows to JOIN the comments table to the query, rather than loading comments in a separate query. However, doing this without writing a full-blown SQL parser is inherently flawed. Since we don't want to write an SQL parser, we are removing this functionality. From now on, you must explicitly tell Active Record when you are referencing a table from a string:



    Post.includes(:comments).where("comments.title = 'foo'").references(:comments)



If you don't rely on implicit join references you can disable the feature entirely by setting `config.active_record.disable_implicit_join_references = true`. (called from designations_received? at /home/travis/build/Liaison-Intl/WebAdMIT/app/models/applicant.rb:941)

[32m.[0mDEPRECATION WARNING: It looks like you are eager loading table(s) (one of: scoring_models, scoring_model_assignments, programs) that are referenced in a string SQL snippet. For example:



    Post.includes(:comments).where("comments.title = 'foo'")



Currently, Active Record recognizes the table in the string, and knows to JOIN the comments table to the query, rather than loading comments in a separate query. However, doing this without writing a full-blown SQL parser is inherently flawed. Since we don't want to write an SQL parser, we are removing this functionality. From now on, you must explicitly tell Active Record when you are referencing a table from a string:



    Post.includes(:comments).where("comments.title = 'foo'").references(:comments)



If you don't rely on implicit join references you can disable the feature entirely by setting `config.active_record.disable_implicit_join_references = true`. (called from score_for_scoring_models at /home/travis/build/Liaison-Intl/WebAdMIT/app/models/scoring/scorer.rb:50)

DEPRECATION WARNING: It looks like you are eager loading table(s) (one of: scoring_models, scoring_model_assignments, programs) that are referenced in a string SQL snippet. For example:



    Post.includes(:comments).where("comments.title = 'foo'")



Currently, Active Record recognizes the table in the string, and knows to JOIN the comments table to the query, rather than loading comments in a separate query. However, doing this without writing a full-blown SQL parser is inherently flawed. Since we don't want to write an SQL parser, we are removing this functionality. From now on, you must explicitly tell Active Record when you are referencing a table from a string:



    Post.includes(:comments).where("comments.title = 'foo'").references(:comments)



If you don't rely on implicit join references you can disable the feature entirely by setting `config.active_record.disable_implicit_join_references = true`. (called from score_for_scoring_models at /home/travis/build/Liaison-Intl/WebAdMIT/app/models/scoring/scorer.rb:50)

DEPRECATION WARNING: It looks like you are eager loading table(s) (one of: designations, programs, user_identity_programs) that are referenced in a string SQL snippet. For example:



    Post.includes(:comments).where("comments.title = 'foo'")



Currently, Active Record recognizes the table in the string, and knows to JOIN the comments table to the query, rather than loading comments in a separate query. However, doing this without writing a full-blown SQL parser is inherently flawed. Since we don't want to write an SQL parser, we are removing this functionality. From now on, you must explicitly tell Active Record when you are referencing a table from a string:



    Post.includes(:comments).where("comments.title = 'foo'").references(:comments)



If you don't rely on implicit join references you can disable the feature entirely by setting `config.active_record.disable_implicit_join_references = true`. (called from designations_received? at /home/travis/build/Liaison-Intl/WebAdMIT/app/models/applicant.rb:941)

DEPRECATION WARNING: It looks like you are eager loading table(s) (one of: designations, programs, user_identity_programs) that are referenced in a string SQL snippet. For example:



    Post.includes(:comments).where("comments.title = 'foo'")



Currently, Active Record recognizes the table in the string, and knows to JOIN the comments table to the query, rather than loading comments in a separate query. However, doing this without writing a full-blown SQL parser is inherently flawed. Since we don't want to write an SQL parser, we are removing this functionality. From now on, you must explicitly tell Active Record when you are referencing a table from a string:



    Post.includes(:comments).where("comments.title = 'foo'").references(:comments)



If you don't rely on implicit join references you can disable the feature entirely by setting `config.active_record.disable_implicit_join_references = true`. (called from designations_received? at /home/travis/build/Liaison-Intl/WebAdMIT/app/models/applicant.rb:941)

[32m.[0mDEPRECATION WARNING: It looks like you are eager loading table(s) (one of: scoring_models, scoring_model_assignments, programs) that are referenced in a string SQL snippet. For example:



    Post.includes(:comments).where("comments.title = 'foo'")



Currently, Active Record recognizes the table in the string, and knows to JOIN the comments table to the query, rather than loading comments in a separate query. However, doing this without writing a full-blown SQL parser is inherently flawed. Since we don't want to write an SQL parser, we are removing this functionality. From now on, you must explicitly tell Active Record when you are referencing a table from a string:



    Post.includes(:comments).where("comments.title = 'foo'").references(:comments)



If you don't rely on implicit join references you can disable the feature entirely by setting `config.active_record.disable_implicit_join_references = true`. (called from score_for_scoring_models at /home/travis/build/Liaison-Intl/WebAdMIT/app/models/scoring/scorer.rb:50)

DEPRECATION WARNING: It looks like you are eager loading table(s) (one of: scoring_models, scoring_model_assignments, programs) that are referenced in a string SQL snippet. For example:



    Post.includes(:comments).where("comments.title = 'foo'")



Currently, Active Record recognizes the table in the string, and knows to JOIN the comments table to the query, rather than loading comments in a separate query. However, doing this without writing a full-blown SQL parser is inherently flawed. Since we don't want to write an SQL parser, we are removing this functionality. From now on, you must explicitly tell Active Record when you are referencing a table from a string:



    Post.includes(:comments).where("comments.title = 'foo'").references(:comments)



If you don't rely on implicit join references you can disable the feature entirely by setting `config.active_record.disable_implicit_join_references = true`. (called from score_for_scoring_models at /home/travis/build/Liaison-Intl/WebAdMIT/app/models/scoring/scorer.rb:50)

DEPRECATION WARNING: It looks like you are eager loading table(s) (one of: designations, programs, user_identity_programs) that are referenced in a string SQL snippet. For example:



    Post.includes(:comments).where("comments.title = 'foo'")



Currently, Active Record recognizes the table in the string, and knows to JOIN the comments table to the query, rather than loading comments in a separate query. However, doing this without writing a full-blown SQL parser is inherently flawed. Since we don't want to write an SQL parser, we are removing this functionality. From now on, you must explicitly tell Active Record when you are referencing a table from a string:



    Post.includes(:comments).where("comments.title = 'foo'").references(:comments)



If you don't rely on implicit join references you can disable the feature entirely by setting `config.active_record.disable_implicit_join_references = true`. (called from designations_received? at /home/travis/build/Liaison-Intl/WebAdMIT/app/models/applicant.rb:941)

DEPRECATION WARNING: It looks like you are eager loading table(s) (one of: designations, programs, user_identity_programs) that are referenced in a string SQL snippet. For example:



    Post.includes(:comments).where("comments.title = 'foo'")



Currently, Active Record recognizes the table in the string, and knows to JOIN the comments table to the query, rather than loading comments in a separate query. However, doing this without writing a full-blown SQL parser is inherently flawed. Since we don't want to write an SQL parser, we are removing this functionality. From now on, you must explicitly tell Active Record when you are referencing a table from a string:



    Post.includes(:comments).where("comments.title = 'foo'").references(:comments)



If you don't rely on implicit join references you can disable the feature entirely by setting `config.active_record.disable_implicit_join_references = true`. (called from designations_received? at /home/travis/build/Liaison-Intl/WebAdMIT/app/models/applicant.rb:941)

DEPRECATION WARNING: It looks like you are eager loading table(s) (one of: designations, programs, user_identity_programs) that are referenced in a string SQL snippet. For example:



    Post.includes(:comments).where("comments.title = 'foo'")



Currently, Active Record recognizes the table in the string, and knows to JOIN the comments table to the query, rather than loading comments in a separate query. However, doing this without writing a full-blown SQL parser is inherently flawed. Since we don't want to write an SQL parser, we are removing this functionality. From now on, you must explicitly tell Active Record when you are referencing a table from a string:



    Post.includes(:comments).where("comments.title = 'foo'").references(:comments)



If you don't rely on implicit join references you can disable the feature entirely by setting `config.active_record.disable_implicit_join_references = true`. (called from designations_received? at /home/travis/build/Liaison-Intl/WebAdMIT/app/models/applicant.rb:941)

DEPRECATION WARNING: It looks like you are eager loading table(s) (one of: designations, programs, user_identity_programs) that are referenced in a string SQL snippet. For example:



    Post.includes(:comments).where("comments.title = 'foo'")



Currently, Active Record recognizes the table in the string, and knows to JOIN the comments table to the query, rather than loading comments in a separate query. However, doing this without writing a full-blown SQL parser is inherently flawed. Since we don't want to write an SQL parser, we are removing this functionality. From now on, you must explicitly tell Active Record when you are referencing a table from a string:



    Post.includes(:comments).where("comments.title = 'foo'").references(:comments)



If you don't rely on implicit join references you can disable the feature entirely by setting `config.active_record.disable_implicit_join_references = true`. (called from designations_received? at /home/travis/build/Liaison-Intl/WebAdMIT/app/models/applicant.rb:941)

[32m.[0mDEPRECATION WARNING: It looks like you are eager loading table(s) (one of: scoring_models, scoring_model_assignments, programs) that are referenced in a string SQL snippet. For example:



    Post.includes(:comments).where("comments.title = 'foo'")



Currently, Active Record recognizes the table in the string, and knows to JOIN the comments table to the query, rather than loading comments in a separate query. However, doing this without writing a full-blown SQL parser is inherently flawed. Since we don't want to write an SQL parser, we are removing this functionality. From now on, you must explicitly tell Active Record when you are referencing a table from a string:



    Post.includes(:comments).where("comments.title = 'foo'").references(:comments)



If you don't rely on implicit join references you can disable the feature entirely by setting `config.active_record.disable_implicit_join_references = true`. (called from score_for_scoring_models at /home/travis/build/Liaison-Intl/WebAdMIT/app/models/scoring/scorer.rb:50)

DEPRECATION WARNING: It looks like you are eager loading table(s) (one of: scoring_models, scoring_model_assignments, programs) that are referenced in a string SQL snippet. For example:



    Post.includes(:comments).where("comments.title = 'foo'")



Currently, Active Record recognizes the table in the string, and knows to JOIN the comments table to the query, rather than loading comments in a separate query. However, doing this without writing a full-blown SQL parser is inherently flawed. Since we don't want to write an SQL parser, we are removing this functionality. From now on, you must explicitly tell Active Record when you are referencing a table from a string:



    Post.includes(:comments).where("comments.title = 'foo'").references(:comments)



If you don't rely on implicit join references you can disable the feature entirely by setting `config.active_record.disable_implicit_join_references = true`. (called from score_for_scoring_models at /home/travis/build/Liaison-Intl/WebAdMIT/app/models/scoring/scorer.rb:50)

DEPRECATION WARNING: It looks like you are eager loading table(s) (one of: designations, programs, user_identity_programs) that are referenced in a string SQL snippet. For example:



    Post.includes(:comments).where("comments.title = 'foo'")



Currently, Active Record recognizes the table in the string, and knows to JOIN the comments table to the query, rather than loading comments in a separate query. However, doing this without writing a full-blown SQL parser is inherently flawed. Since we don't want to write an SQL parser, we are removing this functionality. From now on, you must explicitly tell Active Record when you are referencing a table from a string:



    Post.includes(:comments).where("comments.title = 'foo'").references(:comments)



If you don't rely on implicit join references you can disable the feature entirely by setting `config.active_record.disable_implicit_join_references = true`. (called from designations_received? at /home/travis/build/Liaison-Intl/WebAdMIT/app/models/applicant.rb:941)

DEPRECATION WARNING: It looks like you are eager loading table(s) (one of: designations, programs, user_identity_programs) that are referenced in a string SQL snippet. For example:



    Post.includes(:comments).where("comments.title = 'foo'")



Currently, Active Record recognizes the table in the string, and knows to JOIN the comments table to the query, rather than loading comments in a separate query. However, doing this without writing a full-blown SQL parser is inherently flawed. Since we don't want to write an SQL parser, we are removing this functionality. From now on, you must explicitly tell Active Record when you are referencing a table from a string:



    Post.includes(:comments).where("comments.title = 'foo'").references(:comments)



If you don't rely on implicit join references you can disable the feature entirely by setting `config.active_record.disable_implicit_join_references = true`. (called from designations_received? at /home/travis/build/Liaison-Intl/WebAdMIT/app/models/applicant.rb:941)

DEPRECATION WARNING: It looks like you are eager loading table(s) (one of: designations, programs, user_identity_programs) that are referenced in a string SQL snippet. For example:



    Post.includes(:comments).where("comments.title = 'foo'")



Currently, Active Record recognizes the table in the string, and knows to JOIN the comments table to the query, rather than loading comments in a separate query. However, doing this without writing a full-blown SQL parser is inherently flawed. Since we don't want to write an SQL parser, we are removing this functionality. From now on, you must explicitly tell Active Record when you are referencing a table from a string:



    Post.includes(:comments).where("comments.title = 'foo'").references(:comments)



If you don't rely on implicit join references you can disable the feature entirely by setting `config.active_record.disable_implicit_join_references = true`. (called from designations_received? at /home/travis/build/Liaison-Intl/WebAdMIT/app/models/applicant.rb:941)

DEPRECATION WARNING: It looks like you are eager loading table(s) (one of: designations, programs, user_identity_programs) that are referenced in a string SQL snippet. For example:



    Post.includes(:comments).where("comments.title = 'foo'")



Currently, Active Record recognizes the table in the string, and knows to JOIN the comments table to the query, rather than loading comments in a separate query. However, doing this without writing a full-blown SQL parser is inherently flawed. Since we don't want to write an SQL parser, we are removing this functionality. From now on, you must explicitly tell Active Record when you are referencing a table from a string:



    Post.includes(:comments).where("comments.title = 'foo'").references(:comments)



If you don't rely on implicit join references you can disable the feature entirely by setting `config.active_record.disable_implicit_join_references = true`. (called from designations_received? at /home/travis/build/Liaison-Intl/WebAdMIT/app/models/applicant.rb:941)

DEPRECATION WARNING: It looks like you are eager loading table(s) (one of: designations, programs, user_identity_programs) that are referenced in a string SQL snippet. For example:



    Post.includes(:comments).where("comments.title = 'foo'")



Currently, Active Record recognizes the table in the string, and knows to JOIN the comments table to the query, rather than loading comments in a separate query. However, doing this without writing a full-blown SQL parser is inherently flawed. Since we don't want to write an SQL parser, we are removing this functionality. From now on, you must explicitly tell Active Record when you are referencing a table from a string:



    Post.includes(:comments).where("comments.title = 'foo'").references(:comments)



If you don't rely on implicit join references you can disable the feature entirely by setting `config.active_record.disable_implicit_join_references = true`. (called from designations_received? at /home/travis/build/Liaison-Intl/WebAdMIT/app/models/applicant.rb:941)

[32m.[0mDEPRECATION WARNING: It looks like you are eager loading table(s) (one of: scoring_models, scoring_model_assignments, programs) that are referenced in a string SQL snippet. For example:



    Post.includes(:comments).where("comments.title = 'foo'")



Currently, Active Record recognizes the table in the string, and knows to JOIN the comments table to the query, rather than loading comments in a separate query. However, doing this without writing a full-blown SQL parser is inherently flawed. Since we don't want to write an SQL parser, we are removing this functionality. From now on, you must explicitly tell Active Record when you are referencing a table from a string:



    Post.includes(:comments).where("comments.title = 'foo'").references(:comments)



If you don't rely on implicit join references you can disable the feature entirely by setting `config.active_record.disable_implicit_join_references = true`. (called from score_for_scoring_models at /home/travis/build/Liaison-Intl/WebAdMIT/app/models/scoring/scorer.rb:50)

DEPRECATION WARNING: It looks like you are eager loading table(s) (one of: scoring_models, scoring_model_assignments, programs) that are referenced in a string SQL snippet. For example:



    Post.includes(:comments).where("comments.title = 'foo'")



Currently, Active Record recognizes the table in the string, and knows to JOIN the comments table to the query, rather than loading comments in a separate query. However, doing this without writing a full-blown SQL parser is inherently flawed. Since we don't want to write an SQL parser, we are removing this functionality. From now on, you must explicitly tell Active Record when you are referencing a table from a string:



    Post.includes(:comments).where("comments.title = 'foo'").references(:comments)



If you don't rely on implicit join references you can disable the feature entirely by setting `config.active_record.disable_implicit_join_references = true`. (called from score_for_scoring_models at /home/travis/build/Liaison-Intl/WebAdMIT/app/models/scoring/scorer.rb:50)

DEPRECATION WARNING: It looks like you are eager loading table(s) (one of: designations, programs, user_identity_programs) that are referenced in a string SQL snippet. For example:



    Post.includes(:comments).where("comments.title = 'foo'")



Currently, Active Record recognizes the table in the string, and knows to JOIN the comments table to the query, rather than loading comments in a separate query. However, doing this without writing a full-blown SQL parser is inherently flawed. Since we don't want to write an SQL parser, we are removing this functionality. From now on, you must explicitly tell Active Record when you are referencing a table from a string:



    Post.includes(:comments).where("comments.title = 'foo'").references(:comments)



If you don't rely on implicit join references you can disable the feature entirely by setting `config.active_record.disable_implicit_join_references = true`. (called from designations_received? at /home/travis/build/Liaison-Intl/WebAdMIT/app/models/applicant.rb:941)

DEPRECATION WARNING: It looks like you are eager loading table(s) (one of: designations, programs, user_identity_programs) that are referenced in a string SQL snippet. For example:



    Post.includes(:comments).where("comments.title = 'foo'")



Currently, Active Record recognizes the table in the string, and knows to JOIN the comments table to the query, rather than loading comments in a separate query. However, doing this without writing a full-blown SQL parser is inherently flawed. Since we don't want to write an SQL parser, we are removing this functionality. From now on, you must explicitly tell Active Record when you are referencing a table from a string:



    Post.includes(:comments).where("comments.title = 'foo'").references(:comments)



If you don't rely on implicit join references you can disable the feature entirely by setting `config.active_record.disable_implicit_join_references = true`. (called from designations_received? at /home/travis/build/Liaison-Intl/WebAdMIT/app/models/applicant.rb:941)

DEPRECATION WARNING: It looks like you are eager loading table(s) (one of: designations, programs, user_identity_programs) that are referenced in a string SQL snippet. For example:



    Post.includes(:comments).where("comments.title = 'foo'")



Currently, Active Record recognizes the table in the string, and knows to JOIN the comments table to the query, rather than loading comments in a separate query. However, doing this without writing a full-blown SQL parser is inherently flawed. Since we don't want to write an SQL parser, we are removing this functionality. From now on, you must explicitly tell Active Record when you are referencing a table from a string:



    Post.includes(:comments).where("comments.title = 'foo'").references(:comments)



If you don't rely on implicit join references you can disable the feature entirely by setting `config.active_record.disable_implicit_join_references = true`. (called from designations_received? at /home/travis/build/Liaison-Intl/WebAdMIT/app/models/applicant.rb:941)

DEPRECATION WARNING: It looks like you are eager loading table(s) (one of: designations, programs, user_identity_programs) that are referenced in a string SQL snippet. For example:



    Post.includes(:comments).where("comments.title = 'foo'")



Currently, Active Record recognizes the table in the string, and knows to JOIN the comments table to the query, rather than loading comments in a separate query. However, doing this without writing a full-blown SQL parser is inherently flawed. Since we don't want to write an SQL parser, we are removing this functionality. From now on, you must explicitly tell Active Record when you are referencing a table from a string:



    Post.includes(:comments).where("comments.title = 'foo'").references(:comments)



If you don't rely on implicit join references you can disable the feature entirely by setting `config.active_record.disable_implicit_join_references = true`. (called from designations_received? at /home/travis/build/Liaison-Intl/WebAdMIT/app/models/applicant.rb:941)

DEPRECATION WARNING: It looks like you are eager loading table(s) (one of: designations, programs, user_identity_programs) that are referenced in a string SQL snippet. For example:



    Post.includes(:comments).where("comments.title = 'foo'")



Currently, Active Record recognizes the table in the string, and knows to JOIN the comments table to the query, rather than loading comments in a separate query. However, doing this without writing a full-blown SQL parser is inherently flawed. Since we don't want to write an SQL parser, we are removing this functionality. From now on, you must explicitly tell Active Record when you are referencing a table from a string:



    Post.includes(:comments).where("comments.title = 'foo'").references(:comments)



If you don't rely on implicit join references you can disable the feature entirely by setting `config.active_record.disable_implicit_join_references = true`. (called from designations_received? at /home/travis/build/Liaison-Intl/WebAdMIT/app/models/applicant.rb:941)

[32m.[0mDEPRECATION WARNING: It looks like you are eager loading table(s) (one of: scoring_models, scoring_model_assignments, programs) that are referenced in a string SQL snippet. For example:



    Post.includes(:comments).where("comments.title = 'foo'")



Currently, Active Record recognizes the table in the string, and knows to JOIN the comments table to the query, rather than loading comments in a separate query. However, doing this without writing a full-blown SQL parser is inherently flawed. Since we don't want to write an SQL parser, we are removing this functionality. From now on, you must explicitly tell Active Record when you are referencing a table from a string:



    Post.includes(:comments).where("comments.title = 'foo'").references(:comments)



If you don't rely on implicit join references you can disable the feature entirely by setting `config.active_record.disable_implicit_join_references = true`. (called from score_for_scoring_models at /home/travis/build/Liaison-Intl/WebAdMIT/app/models/scoring/scorer.rb:50)

DEPRECATION WARNING: It looks like you are eager loading table(s) (one of: scoring_models, scoring_model_assignments, programs) that are referenced in a string SQL snippet. For example:



    Post.includes(:comments).where("comments.title = 'foo'")



Currently, Active Record recognizes the table in the string, and knows to JOIN the comments table to the query, rather than loading comments in a separate query. However, doing this without writing a full-blown SQL parser is inherently flawed. Since we don't want to write an SQL parser, we are removing this functionality. From now on, you must explicitly tell Active Record when you are referencing a table from a string:



    Post.includes(:comments).where("comments.title = 'foo'").references(:comments)



If you don't rely on implicit join references you can disable the feature entirely by setting `config.active_record.disable_implicit_join_references = true`. (called from score_for_scoring_models at /home/travis/build/Liaison-Intl/WebAdMIT/app/models/scoring/scorer.rb:50)

DEPRECATION WARNING: It looks like you are eager loading table(s) (one of: designations, programs, user_identity_programs) that are referenced in a string SQL snippet. For example:



    Post.includes(:comments).where("comments.title = 'foo'")



Currently, Active Record recognizes the table in the string, and knows to JOIN the comments table to the query, rather than loading comments in a separate query. However, doing this without writing a full-blown SQL parser is inherently flawed. Since we don't want to write an SQL parser, we are removing this functionality. From now on, you must explicitly tell Active Record when you are referencing a table from a string:



    Post.includes(:comments).where("comments.title = 'foo'").references(:comments)



If you don't rely on implicit join references you can disable the feature entirely by setting `config.active_record.disable_implicit_join_references = true`. (called from designations_received? at /home/travis/build/Liaison-Intl/WebAdMIT/app/models/applicant.rb:941)

DEPRECATION WARNING: It looks like you are eager loading table(s) (one of: designations, programs, user_identity_programs) that are referenced in a string SQL snippet. For example:



    Post.includes(:comments).where("comments.title = 'foo'")



Currently, Active Record recognizes the table in the string, and knows to JOIN the comments table to the query, rather than loading comments in a separate query. However, doing this without writing a full-blown SQL parser is inherently flawed. Since we don't want to write an SQL parser, we are removing this functionality. From now on, you must explicitly tell Active Record when you are referencing a table from a string:



    Post.includes(:comments).where("comments.title = 'foo'").references(:comments)



If you don't rely on implicit join references you can disable the feature entirely by setting `config.active_record.disable_implicit_join_references = true`. (called from designations_received? at /home/travis/build/Liaison-Intl/WebAdMIT/app/models/applicant.rb:941)

DEPRECATION WARNING: It looks like you are eager loading table(s) (one of: designations, programs, user_identity_programs) that are referenced in a string SQL snippet. For example:



    Post.includes(:comments).where("comments.title = 'foo'")



Currently, Active Record recognizes the table in the string, and knows to JOIN the comments table to the query, rather than loading comments in a separate query. However, doing this without writing a full-blown SQL parser is inherently flawed. Since we don't want to write an SQL parser, we are removing this functionality. From now on, you must explicitly tell Active Record when you are referencing a table from a string:



    Post.includes(:comments).where("comments.title = 'foo'").references(:comments)



If you don't rely on implicit join references you can disable the feature entirely by setting `config.active_record.disable_implicit_join_references = true`. (called from designations_received? at /home/travis/build/Liaison-Intl/WebAdMIT/app/models/applicant.rb:941)

DEPRECATION WARNING: It looks like you are eager loading table(s) (one of: designations, programs, user_identity_programs) that are referenced in a string SQL snippet. For example:



    Post.includes(:comments).where("comments.title = 'foo'")



Currently, Active Record recognizes the table in the string, and knows to JOIN the comments table to the query, rather than loading comments in a separate query. However, doing this without writing a full-blown SQL parser is inherently flawed. Since we don't want to write an SQL parser, we are removing this functionality. From now on, you must explicitly tell Active Record when you are referencing a table from a string:



    Post.includes(:comments).where("comments.title = 'foo'").references(:comments)



If you don't rely on implicit join references you can disable the feature entirely by setting `config.active_record.disable_implicit_join_references = true`. (called from designations_received? at /home/travis/build/Liaison-Intl/WebAdMIT/app/models/applicant.rb:941)

[32m.[0mDEPRECATION WARNING: It looks like you are eager loading table(s) (one of: scoring_models, scoring_model_assignments, programs) that are referenced in a string SQL snippet. For example:



    Post.includes(:comments).where("comments.title = 'foo'")



Currently, Active Record recognizes the table in the string, and knows to JOIN the comments table to the query, rather than loading comments in a separate query. However, doing this without writing a full-blown SQL parser is inherently flawed. Since we don't want to write an SQL parser, we are removing this functionality. From now on, you must explicitly tell Active Record when you are referencing a table from a string:



    Post.includes(:comments).where("comments.title = 'foo'").references(:comments)



If you don't rely on implicit join references you can disable the feature entirely by setting `config.active_record.disable_implicit_join_references = true`. (called from score_for_scoring_models at /home/travis/build/Liaison-Intl/WebAdMIT/app/models/scoring/scorer.rb:50)

DEPRECATION WARNING: It looks like you are eager loading table(s) (one of: scoring_models, scoring_model_assignments, programs) that are referenced in a string SQL snippet. For example:



    Post.includes(:comments).where("comments.title = 'foo'")



Currently, Active Record recognizes the table in the string, and knows to JOIN the comments table to the query, rather than loading comments in a separate query. However, doing this without writing a full-blown SQL parser is inherently flawed. Since we don't want to write an SQL parser, we are removing this functionality. From now on, you must explicitly tell Active Record when you are referencing a table from a string:



    Post.includes(:comments).where("comments.title = 'foo'").references(:comments)



If you don't rely on implicit join references you can disable the feature entirely by setting `config.active_record.disable_implicit_join_references = true`. (called from score_for_scoring_models at /home/travis/build/Liaison-Intl/WebAdMIT/app/models/scoring/scorer.rb:50)

DEPRECATION WARNING: It looks like you are eager loading table(s) (one of: scoring_models, scoring_model_assignments, programs) that are referenced in a string SQL snippet. For example:



    Post.includes(:comments).where("comments.title = 'foo'")



Currently, Active Record recognizes the table in the string, and knows to JOIN the comments table to the query, rather than loading comments in a separate query. However, doing this without writing a full-blown SQL parser is inherently flawed. Since we don't want to write an SQL parser, we are removing this functionality. From now on, you must explicitly tell Active Record when you are referencing a table from a string:



    Post.includes(:comments).where("comments.title = 'foo'").references(:comments)



If you don't rely on implicit join references you can disable the feature entirely by setting `config.active_record.disable_implicit_join_references = true`. (called from score_for_scoring_models at /home/travis/build/Liaison-Intl/WebAdMIT/app/models/scoring/scorer.rb:50)

DEPRECATION WARNING: It looks like you are eager loading table(s) (one of: designations, programs, user_identity_programs) that are referenced in a string SQL snippet. For example:



    Post.includes(:comments).where("comments.title = 'foo'")



Currently, Active Record recognizes the table in the string, and knows to JOIN the comments table to the query, rather than loading comments in a separate query. However, doing this without writing a full-blown SQL parser is inherently flawed. Since we don't want to write an SQL parser, we are removing this functionality. From now on, you must explicitly tell Active Record when you are referencing a table from a string:



    Post.includes(:comments).where("comments.title = 'foo'").references(:comments)



If you don't rely on implicit join references you can disable the feature entirely by setting `config.active_record.disable_implicit_join_references = true`. (called from designations_received? at /home/travis/build/Liaison-Intl/WebAdMIT/app/models/applicant.rb:941)

DEPRECATION WARNING: It looks like you are eager loading table(s) (one of: designations, programs, user_identity_programs) that are referenced in a string SQL snippet. For example:



    Post.includes(:comments).where("comments.title = 'foo'")



Currently, Active Record recognizes the table in the string, and knows to JOIN the comments table to the query, rather than loading comments in a separate query. However, doing this without writing a full-blown SQL parser is inherently flawed. Since we don't want to write an SQL parser, we are removing this functionality. From now on, you must explicitly tell Active Record when you are referencing a table from a string:



    Post.includes(:comments).where("comments.title = 'foo'").references(:comments)



If you don't rely on implicit join references you can disable the feature entirely by setting `config.active_record.disable_implicit_join_references = true`. (called from designations_received? at /home/travis/build/Liaison-Intl/WebAdMIT/app/models/applicant.rb:941)

DEPRECATION WARNING: It looks like you are eager loading table(s) (one of: designations, programs, user_identity_programs) that are referenced in a string SQL snippet. For example:



    Post.includes(:comments).where("comments.title = 'foo'")



Currently, Active Record recognizes the table in the string, and knows to JOIN the comments table to the query, rather than loading comments in a separate query. However, doing this without writing a full-blown SQL parser is inherently flawed. Since we don't want to write an SQL parser, we are removing this functionality. From now on, you must explicitly tell Active Record when you are referencing a table from a string:



    Post.includes(:comments).where("comments.title = 'foo'").references(:comments)



If you don't rely on implicit join references you can disable the feature entirely by setting `config.active_record.disable_implicit_join_references = true`. (called from designations_received? at /home/travis/build/Liaison-Intl/WebAdMIT/app/models/applicant.rb:941)

DEPRECATION WARNING: It looks like you are eager loading table(s) (one of: designations, programs, user_identity_programs) that are referenced in a string SQL snippet. For example:



    Post.includes(:comments).where("comments.title = 'foo'")



Currently, Active Record recognizes the table in the string, and knows to JOIN the comments table to the query, rather than loading comments in a separate query. However, doing this without writing a full-blown SQL parser is inherently flawed. Since we don't want to write an SQL parser, we are removing this functionality. From now on, you must explicitly tell Active Record when you are referencing a table from a string:



    Post.includes(:comments).where("comments.title = 'foo'").references(:comments)



If you don't rely on implicit join references you can disable the feature entirely by setting `config.active_record.disable_implicit_join_references = true`. (called from designations_received? at /home/travis/build/Liaison-Intl/WebAdMIT/app/models/applicant.rb:941)

DEPRECATION WARNING: It looks like you are eager loading table(s) (one of: designations, programs, user_identity_programs) that are referenced in a string SQL snippet. For example:



    Post.includes(:comments).where("comments.title = 'foo'")



Currently, Active Record recognizes the table in the string, and knows to JOIN the comments table to the query, rather than loading comments in a separate query. However, doing this without writing a full-blown SQL parser is inherently flawed. Since we don't want to write an SQL parser, we are removing this functionality. From now on, you must explicitly tell Active Record when you are referencing a table from a string:



    Post.includes(:comments).where("comments.title = 'foo'").references(:comments)



If you don't rely on implicit join references you can disable the feature entirely by setting `config.active_record.disable_implicit_join_references = true`. (called from designations_received? at /home/travis/build/Liaison-Intl/WebAdMIT/app/models/applicant.rb:941)

DEPRECATION WARNING: It looks like you are eager loading table(s) (one of: designations, programs, user_identity_programs) that are referenced in a string SQL snippet. For example:



    Post.includes(:comments).where("comments.title = 'foo'")



Currently, Active Record recognizes the table in the string, and knows to JOIN the comments table to the query, rather than loading comments in a separate query. However, doing this without writing a full-blown SQL parser is inherently flawed. Since we don't want to write an SQL parser, we are removing this functionality. From now on, you must explicitly tell Active Record when you are referencing a table from a string:



    Post.includes(:comments).where("comments.title = 'foo'").references(:comments)



If you don't rely on implicit join references you can disable the feature entirely by setting `config.active_record.disable_implicit_join_references = true`. (called from designations_received? at /home/travis/build/Liaison-Intl/WebAdMIT/app/models/applicant.rb:941)

[32m.[0mDEPRECATION WARNING: It looks like you are eager loading table(s) (one of: scoring_models, scoring_model_assignments, programs) that are referenced in a string SQL snippet. For example:



    Post.includes(:comments).where("comments.title = 'foo'")



Currently, Active Record recognizes the table in the string, and knows to JOIN the comments table to the query, rather than loading comments in a separate query. However, doing this without writing a full-blown SQL parser is inherently flawed. Since we don't want to write an SQL parser, we are removing this functionality. From now on, you must explicitly tell Active Record when you are referencing a table from a string:



    Post.includes(:comments).where("comments.title = 'foo'").references(:comments)



If you don't rely on implicit join references you can disable the feature entirely by setting `config.active_record.disable_implicit_join_references = true`. (called from score_for_scoring_models at /home/travis/build/Liaison-Intl/WebAdMIT/app/models/scoring/scorer.rb:50)

DEPRECATION WARNING: It looks like you are eager loading table(s) (one of: scoring_models, scoring_model_assignments, programs) that are referenced in a string SQL snippet. For example:



    Post.includes(:comments).where("comments.title = 'foo'")



Currently, Active Record recognizes the table in the string, and knows to JOIN the comments table to the query, rather than loading comments in a separate query. However, doing this without writing a full-blown SQL parser is inherently flawed. Since we don't want to write an SQL parser, we are removing this functionality. From now on, you must explicitly tell Active Record when you are referencing a table from a string:



    Post.includes(:comments).where("comments.title = 'foo'").references(:comments)



If you don't rely on implicit join references you can disable the feature entirely by setting `config.active_record.disable_implicit_join_references = true`. (called from score_for_scoring_models at /home/travis/build/Liaison-Intl/WebAdMIT/app/models/scoring/scorer.rb:50)

DEPRECATION WARNING: It looks like you are eager loading table(s) (one of: scoring_models, scoring_model_assignments, programs) that are referenced in a string SQL snippet. For example:



    Post.includes(:comments).where("comments.title = 'foo'")



Currently, Active Record recognizes the table in the string, and knows to JOIN the comments table to the query, rather than loading comments in a separate query. However, doing this without writing a full-blown SQL parser is inherently flawed. Since we don't want to write an SQL parser, we are removing this functionality. From now on, you must explicitly tell Active Record when you are referencing a table from a string:



    Post.includes(:comments).where("comments.title = 'foo'").references(:comments)



If you don't rely on implicit join references you can disable the feature entirely by setting `config.active_record.disable_implicit_join_references = true`. (called from score_for_scoring_models at /home/travis/build/Liaison-Intl/WebAdMIT/app/models/scoring/scorer.rb:50)

DEPRECATION WARNING: It looks like you are eager loading table(s) (one of: scoring_models, scoring_model_assignments, programs) that are referenced in a string SQL snippet. For example:



    Post.includes(:comments).where("comments.title = 'foo'")



Currently, Active Record recognizes the table in the string, and knows to JOIN the comments table to the query, rather than loading comments in a separate query. However, doing this without writing a full-blown SQL parser is inherently flawed. Since we don't want to write an SQL parser, we are removing this functionality. From now on, you must explicitly tell Active Record when you are referencing a table from a string:



    Post.includes(:comments).where("comments.title = 'foo'").references(:comments)



If you don't rely on implicit join references you can disable the feature entirely by setting `config.active_record.disable_implicit_join_references = true`. (called from score_for_scoring_models at /home/travis/build/Liaison-Intl/WebAdMIT/app/models/scoring/scorer.rb:50)

DEPRECATION WARNING: It looks like you are eager loading table(s) (one of: designations, programs, user_identity_programs) that are referenced in a string SQL snippet. For example:



    Post.includes(:comments).where("comments.title = 'foo'")



Currently, Active Record recognizes the table in the string, and knows to JOIN the comments table to the query, rather than loading comments in a separate query. However, doing this without writing a full-blown SQL parser is inherently flawed. Since we don't want to write an SQL parser, we are removing this functionality. From now on, you must explicitly tell Active Record when you are referencing a table from a string:



    Post.includes(:comments).where("comments.title = 'foo'").references(:comments)



If you don't rely on implicit join references you can disable the feature entirely by setting `config.active_record.disable_implicit_join_references = true`. (called from designations_received? at /home/travis/build/Liaison-Intl/WebAdMIT/app/models/applicant.rb:941)

DEPRECATION WARNING: It looks like you are eager loading table(s) (one of: designations, programs, user_identity_programs) that are referenced in a string SQL snippet. For example:



    Post.includes(:comments).where("comments.title = 'foo'")



Currently, Active Record recognizes the table in the string, and knows to JOIN the comments table to the query, rather than loading comments in a separate query. However, doing this without writing a full-blown SQL parser is inherently flawed. Since we don't want to write an SQL parser, we are removing this functionality. From now on, you must explicitly tell Active Record when you are referencing a table from a string:



    Post.includes(:comments).where("comments.title = 'foo'").references(:comments)



If you don't rely on implicit join references you can disable the feature entirely by setting `config.active_record.disable_implicit_join_references = true`. (called from designations_received? at /home/travis/build/Liaison-Intl/WebAdMIT/app/models/applicant.rb:941)

DEPRECATION WARNING: It looks like you are eager loading table(s) (one of: designations, programs, user_identity_programs) that are referenced in a string SQL snippet. For example:



    Post.includes(:comments).where("comments.title = 'foo'")



Currently, Active Record recognizes the table in the string, and knows to JOIN the comments table to the query, rather than loading comments in a separate query. However, doing this without writing a full-blown SQL parser is inherently flawed. Since we don't want to write an SQL parser, we are removing this functionality. From now on, you must explicitly tell Active Record when you are referencing a table from a string:



    Post.includes(:comments).where("comments.title = 'foo'").references(:comments)



If you don't rely on implicit join references you can disable the feature entirely by setting `config.active_record.disable_implicit_join_references = true`. (called from designations_received? at /home/travis/build/Liaison-Intl/WebAdMIT/app/models/applicant.rb:941)

DEPRECATION WARNING: It looks like you are eager loading table(s) (one of: designations, programs, user_identity_programs) that are referenced in a string SQL snippet. For example:



    Post.includes(:comments).where("comments.title = 'foo'")



Currently, Active Record recognizes the table in the string, and knows to JOIN the comments table to the query, rather than loading comments in a separate query. However, doing this without writing a full-blown SQL parser is inherently flawed. Since we don't want to write an SQL parser, we are removing this functionality. From now on, you must explicitly tell Active Record when you are referencing a table from a string:



    Post.includes(:comments).where("comments.title = 'foo'").references(:comments)



If you don't rely on implicit join references you can disable the feature entirely by setting `config.active_record.disable_implicit_join_references = true`. (called from designations_received? at /home/travis/build/Liaison-Intl/WebAdMIT/app/models/applicant.rb:941)

DEPRECATION WARNING: It looks like you are eager loading table(s) (one of: designations, programs, user_identity_programs) that are referenced in a string SQL snippet. For example:



    Post.includes(:comments).where("comments.title = 'foo'")



Currently, Active Record recognizes the table in the string, and knows to JOIN the comments table to the query, rather than loading comments in a separate query. However, doing this without writing a full-blown SQL parser is inherently flawed. Since we don't want to write an SQL parser, we are removing this functionality. From now on, you must explicitly tell Active Record when you are referencing a table from a string:



    Post.includes(:comments).where("comments.title = 'foo'").references(:comments)



If you don't rely on implicit join references you can disable the feature entirely by setting `config.active_record.disable_implicit_join_references = true`. (called from designations_received? at /home/travis/build/Liaison-Intl/WebAdMIT/app/models/applicant.rb:941)

DEPRECATION WARNING: It looks like you are eager loading table(s) (one of: designations, programs, user_identity_programs) that are referenced in a string SQL snippet. For example:



    Post.includes(:comments).where("comments.title = 'foo'")



Currently, Active Record recognizes the table in the string, and knows to JOIN the comments table to the query, rather than loading comments in a separate query. However, doing this without writing a full-blown SQL parser is inherently flawed. Since we don't want to write an SQL parser, we are removing this functionality. From now on, you must explicitly tell Active Record when you are referencing a table from a string:



    Post.includes(:comments).where("comments.title = 'foo'").references(:comments)



If you don't rely on implicit join references you can disable the feature entirely by setting `config.active_record.disable_implicit_join_references = true`. (called from designations_received? at /home/travis/build/Liaison-Intl/WebAdMIT/app/models/applicant.rb:941)

DEPRECATION WARNING: It looks like you are eager loading table(s) (one of: designations, programs, user_identity_programs) that are referenced in a string SQL snippet. For example:



    Post.includes(:comments).where("comments.title = 'foo'")



Currently, Active Record recognizes the table in the string, and knows to JOIN the comments table to the query, rather than loading comments in a separate query. However, doing this without writing a full-blown SQL parser is inherently flawed. Since we don't want to write an SQL parser, we are removing this functionality. From now on, you must explicitly tell Active Record when you are referencing a table from a string:



    Post.includes(:comments).where("comments.title = 'foo'").references(:comments)



If you don't rely on implicit join references you can disable the feature entirely by setting `config.active_record.disable_implicit_join_references = true`. (called from designations_received? at /home/travis/build/Liaison-Intl/WebAdMIT/app/models/applicant.rb:941)

DEPRECATION WARNING: It looks like you are eager loading table(s) (one of: designations, programs, user_identity_programs) that are referenced in a string SQL snippet. For example:



    Post.includes(:comments).where("comments.title = 'foo'")



Currently, Active Record recognizes the table in the string, and knows to JOIN the comments table to the query, rather than loading comments in a separate query. However, doing this without writing a full-blown SQL parser is inherently flawed. Since we don't want to write an SQL parser, we are removing this functionality. From now on, you must explicitly tell Active Record when you are referencing a table from a string:



    Post.includes(:comments).where("comments.title = 'foo'").references(:comments)



If you don't rely on implicit join references you can disable the feature entirely by setting `config.active_record.disable_implicit_join_references = true`. (called from designations_received? at /home/travis/build/Liaison-Intl/WebAdMIT/app/models/applicant.rb:941)

[32m.[0mDEPRECATION WARNING: It looks like you are eager loading table(s) (one of: scoring_models, scoring_model_assignments, programs) that are referenced in a string SQL snippet. For example:



    Post.includes(:comments).where("comments.title = 'foo'")



Currently, Active Record recognizes the table in the string, and knows to JOIN the comments table to the query, rather than loading comments in a separate query. However, doing this without writing a full-blown SQL parser is inherently flawed. Since we don't want to write an SQL parser, we are removing this functionality. From now on, you must explicitly tell Active Record when you are referencing a table from a string:



    Post.includes(:comments).where("comments.title = 'foo'").references(:comments)



If you don't rely on implicit join references you can disable the feature entirely by setting `config.active_record.disable_implicit_join_references = true`. (called from score_for_scoring_models at /home/travis/build/Liaison-Intl/WebAdMIT/app/models/scoring/scorer.rb:50)

DEPRECATION WARNING: It looks like you are eager loading table(s) (one of: scoring_models, scoring_model_assignments, programs) that are referenced in a string SQL snippet. For example:



    Post.includes(:comments).where("comments.title = 'foo'")



Currently, Active Record recognizes the table in the string, and knows to JOIN the comments table to the query, rather than loading comments in a separate query. However, doing this without writing a full-blown SQL parser is inherently flawed. Since we don't want to write an SQL parser, we are removing this functionality. From now on, you must explicitly tell Active Record when you are referencing a table from a string:



    Post.includes(:comments).where("comments.title = 'foo'").references(:comments)



If you don't rely on implicit join references you can disable the feature entirely by setting `config.active_record.disable_implicit_join_references = true`. (called from score_for_scoring_models at /home/travis/build/Liaison-Intl/WebAdMIT/app/models/scoring/scorer.rb:50)

DEPRECATION WARNING: It looks like you are eager loading table(s) (one of: designations, programs, user_identity_programs) that are referenced in a string SQL snippet. For example:



    Post.includes(:comments).where("comments.title = 'foo'")



Currently, Active Record recognizes the table in the string, and knows to JOIN the comments table to the query, rather than loading comments in a separate query. However, doing this without writing a full-blown SQL parser is inherently flawed. Since we don't want to write an SQL parser, we are removing this functionality. From now on, you must explicitly tell Active Record when you are referencing a table from a string:



    Post.includes(:comments).where("comments.title = 'foo'").references(:comments)



If you don't rely on implicit join references you can disable the feature entirely by setting `config.active_record.disable_implicit_join_references = true`. (called from designations_received? at /home/travis/build/Liaison-Intl/WebAdMIT/app/models/applicant.rb:941)

DEPRECATION WARNING: It looks like you are eager loading table(s) (one of: designations, programs, user_identity_programs) that are referenced in a string SQL snippet. For example:



    Post.includes(:comments).where("comments.title = 'foo'")



Currently, Active Record recognizes the table in the string, and knows to JOIN the comments table to the query, rather than loading comments in a separate query. However, doing this without writing a full-blown SQL parser is inherently flawed. Since we don't want to write an SQL parser, we are removing this functionality. From now on, you must explicitly tell Active Record when you are referencing a table from a string:



    Post.includes(:comments).where("comments.title = 'foo'").references(:comments)



If you don't rely on implicit join references you can disable the feature entirely by setting `config.active_record.disable_implicit_join_references = true`. (called from designations_received? at /home/travis/build/Liaison-Intl/WebAdMIT/app/models/applicant.rb:941)

DEPRECATION WARNING: It looks like you are eager loading table(s) (one of: designations, programs, user_identity_programs) that are referenced in a string SQL snippet. For example:



    Post.includes(:comments).where("comments.title = 'foo'")



Currently, Active Record recognizes the table in the string, and knows to JOIN the comments table to the query, rather than loading comments in a separate query. However, doing this without writing a full-blown SQL parser is inherently flawed. Since we don't want to write an SQL parser, we are removing this functionality. From now on, you must explicitly tell Active Record when you are referencing a table from a string:



    Post.includes(:comments).where("comments.title = 'foo'").references(:comments)



If you don't rely on implicit join references you can disable the feature entirely by setting `config.active_record.disable_implicit_join_references = true`. (called from designations_received? at /home/travis/build/Liaison-Intl/WebAdMIT/app/models/applicant.rb:941)

DEPRECATION WARNING: It looks like you are eager loading table(s) (one of: designations, programs, user_identity_programs) that are referenced in a string SQL snippet. For example:



    Post.includes(:comments).where("comments.title = 'foo'")



Currently, Active Record recognizes the table in the string, and knows to JOIN the comments table to the query, rather than loading comments in a separate query. However, doing this without writing a full-blown SQL parser is inherently flawed. Since we don't want to write an SQL parser, we are removing this functionality. From now on, you must explicitly tell Active Record when you are referencing a table from a string:



    Post.includes(:comments).where("comments.title = 'foo'").references(:comments)



If you don't rely on implicit join references you can disable the feature entirely by setting `config.active_record.disable_implicit_join_references = true`. (called from designations_received? at /home/travis/build/Liaison-Intl/WebAdMIT/app/models/applicant.rb:941)

[32m.[0mDEPRECATION WARNING: It looks like you are eager loading table(s) (one of: scoring_models, scoring_model_assignments, programs) that are referenced in a string SQL snippet. For example:



    Post.includes(:comments).where("comments.title = 'foo'")



Currently, Active Record recognizes the table in the string, and knows to JOIN the comments table to the query, rather than loading comments in a separate query. However, doing this without writing a full-blown SQL parser is inherently flawed. Since we don't want to write an SQL parser, we are removing this functionality. From now on, you must explicitly tell Active Record when you are referencing a table from a string:



    Post.includes(:comments).where("comments.title = 'foo'").references(:comments)



If you don't rely on implicit join references you can disable the feature entirely by setting `config.active_record.disable_implicit_join_references = true`. (called from score_for_scoring_models at /home/travis/build/Liaison-Intl/WebAdMIT/app/models/scoring/scorer.rb:50)

DEPRECATION WARNING: It looks like you are eager loading table(s) (one of: scoring_models, scoring_model_assignments, programs) that are referenced in a string SQL snippet. For example:



    Post.includes(:comments).where("comments.title = 'foo'")



Currently, Active Record recognizes the table in the string, and knows to JOIN the comments table to the query, rather than loading comments in a separate query. However, doing this without writing a full-blown SQL parser is inherently flawed. Since we don't want to write an SQL parser, we are removing this functionality. From now on, you must explicitly tell Active Record when you are referencing a table from a string:



    Post.includes(:comments).where("comments.title = 'foo'").references(:comments)



If you don't rely on implicit join references you can disable the feature entirely by setting `config.active_record.disable_implicit_join_references = true`. (called from score_for_scoring_models at /home/travis/build/Liaison-Intl/WebAdMIT/app/models/scoring/scorer.rb:50)

DEPRECATION WARNING: It looks like you are eager loading table(s) (one of: designations, programs, user_identity_programs) that are referenced in a string SQL snippet. For example:



    Post.includes(:comments).where("comments.title = 'foo'")



Currently, Active Record recognizes the table in the string, and knows to JOIN the comments table to the query, rather than loading comments in a separate query. However, doing this without writing a full-blown SQL parser is inherently flawed. Since we don't want to write an SQL parser, we are removing this functionality. From now on, you must explicitly tell Active Record when you are referencing a table from a string:



    Post.includes(:comments).where("comments.title = 'foo'").references(:comments)



If you don't rely on implicit join references you can disable the feature entirely by setting `config.active_record.disable_implicit_join_references = true`. (called from designations_received? at /home/travis/build/Liaison-Intl/WebAdMIT/app/models/applicant.rb:941)

DEPRECATION WARNING: It looks like you are eager loading table(s) (one of: designations, programs, user_identity_programs) that are referenced in a string SQL snippet. For example:



    Post.includes(:comments).where("comments.title = 'foo'")



Currently, Active Record recognizes the table in the string, and knows to JOIN the comments table to the query, rather than loading comments in a separate query. However, doing this without writing a full-blown SQL parser is inherently flawed. Since we don't want to write an SQL parser, we are removing this functionality. From now on, you must explicitly tell Active Record when you are referencing a table from a string:



    Post.includes(:comments).where("comments.title = 'foo'").references(:comments)



If you don't rely on implicit join references you can disable the feature entirely by setting `config.active_record.disable_implicit_join_references = true`. (called from designations_received? at /home/travis/build/Liaison-Intl/WebAdMIT/app/models/applicant.rb:941)

DEPRECATION WARNING: It looks like you are eager loading table(s) (one of: designations, programs, user_identity_programs) that are referenced in a string SQL snippet. For example:



    Post.includes(:comments).where("comments.title = 'foo'")



Currently, Active Record recognizes the table in the string, and knows to JOIN the comments table to the query, rather than loading comments in a separate query. However, doing this without writing a full-blown SQL parser is inherently flawed. Since we don't want to write an SQL parser, we are removing this functionality. From now on, you must explicitly tell Active Record when you are referencing a table from a string:



    Post.includes(:comments).where("comments.title = 'foo'").references(:comments)



If you don't rely on implicit join references you can disable the feature entirely by setting `config.active_record.disable_implicit_join_references = true`. (called from designations_received? at /home/travis/build/Liaison-Intl/WebAdMIT/app/models/applicant.rb:941)

DEPRECATION WARNING: It looks like you are eager loading table(s) (one of: designations, programs, user_identity_programs) that are referenced in a string SQL snippet. For example:



    Post.includes(:comments).where("comments.title = 'foo'")



Currently, Active Record recognizes the table in the string, and knows to JOIN the comments table to the query, rather than loading comments in a separate query. However, doing this without writing a full-blown SQL parser is inherently flawed. Since we don't want to write an SQL parser, we are removing this functionality. From now on, you must explicitly tell Active Record when you are referencing a table from a string:



    Post.includes(:comments).where("comments.title = 'foo'").references(:comments)



If you don't rely on implicit join references you can disable the feature entirely by setting `config.active_record.disable_implicit_join_references = true`. (called from designations_received? at /home/travis/build/Liaison-Intl/WebAdMIT/app/models/applicant.rb:941)

[32m.[0m[32m.[0m[32m.[0m[32m.[0m[32m.[0m[32m.[0m[32m.[0m[32m.[0m[32m.[0m[32m.[0mDEPRECATION WARNING: It looks like you are eager loading table(s) (one of: scoring_models, scoring_model_assignments, programs) that are referenced in a string SQL snippet. For example:



    Post.includes(:comments).where("comments.title = 'foo'")



Currently, Active Record recognizes the table in the string, and knows to JOIN the comments table to the query, rather than loading comments in a separate query. However, doing this without writing a full-blown SQL parser is inherently flawed. Since we don't want to write an SQL parser, we are removing this functionality. From now on, you must explicitly tell Active Record when you are referencing a table from a string:



    Post.includes(:comments).where("comments.title = 'foo'").references(:comments)



If you don't rely on implicit join references you can disable the feature entirely by setting `config.active_record.disable_implicit_join_references = true`. (called from score_for_scoring_models at /home/travis/build/Liaison-Intl/WebAdMIT/app/models/scoring/scorer.rb:50)

DEPRECATION WARNING: It looks like you are eager loading table(s) (one of: designations, programs) that are referenced in a string SQL snippet. For example:



    Post.includes(:comments).where("comments.title = 'foo'")



Currently, Active Record recognizes the table in the string, and knows to JOIN the comments table to the query, rather than loading comments in a separate query. However, doing this without writing a full-blown SQL parser is inherently flawed. Since we don't want to write an SQL parser, we are removing this functionality. From now on, you must explicitly tell Active Record when you are referencing a table from a string:



    Post.includes(:comments).where("comments.title = 'foo'").references(:comments)



If you don't rely on implicit join references you can disable the feature entirely by setting `config.active_record.disable_implicit_join_references = true`. (called from designations_received? at /home/travis/build/Liaison-Intl/WebAdMIT/app/models/applicant.rb:941)

DEPRECATION WARNING: Relation#all is deprecated. If you want to eager-load a relation, you can call #load (e.g. `Post.where(published: true).load`). If you want to get an array of records from a relation, you can call #to_a (e.g. `Post.where(published: true).to_a`). (called from _app_views_layouts__advisor_sidebar_haml__4578835400478025503_343596640 at /home/travis/build/Liaison-Intl/WebAdMIT/app/views/layouts/_advisor_sidebar.haml:12)

[32m.[0mDEPRECATION WARNING: It looks like you are eager loading table(s) (one of: scoring_models, scoring_model_assignments, programs) that are referenced in a string SQL snippet. For example:



    Post.includes(:comments).where("comments.title = 'foo'")



Currently, Active Record recognizes the table in the string, and knows to JOIN the comments table to the query, rather than loading comments in a separate query. However, doing this without writing a full-blown SQL parser is inherently flawed. Since we don't want to write an SQL parser, we are removing this functionality. From now on, you must explicitly tell Active Record when you are referencing a table from a string:



    Post.includes(:comments).where("comments.title = 'foo'").references(:comments)



If you don't rely on implicit join references you can disable the feature entirely by setting `config.active_record.disable_implicit_join_references = true`. (called from score_for_scoring_models at /home/travis/build/Liaison-Intl/WebAdMIT/app/models/scoring/scorer.rb:50)

DEPRECATION WARNING: It looks like you are eager loading table(s) (one of: designations, programs) that are referenced in a string SQL snippet. For example:



    Post.includes(:comments).where("comments.title = 'foo'")



Currently, Active Record recognizes the table in the string, and knows to JOIN the comments table to the query, rather than loading comments in a separate query. However, doing this without writing a full-blown SQL parser is inherently flawed. Since we don't want to write an SQL parser, we are removing this functionality. From now on, you must explicitly tell Active Record when you are referencing a table from a string:



    Post.includes(:comments).where("comments.title = 'foo'").references(:comments)



If you don't rely on implicit join references you can disable the feature entirely by setting `config.active_record.disable_implicit_join_references = true`. (called from designations_received? at /home/travis/build/Liaison-Intl/WebAdMIT/app/models/applicant.rb:941)

DEPRECATION WARNING: Relation#all is deprecated. If you want to eager-load a relation, you can call #load (e.g. `Post.where(published: true).load`). If you want to get an array of records from a relation, you can call #to_a (e.g. `Post.where(published: true).to_a`). (called from _app_views_layouts__advisor_sidebar_haml__4578835400478025503_343596640 at /home/travis/build/Liaison-Intl/WebAdMIT/app/views/layouts/_advisor_sidebar.haml:12)

[32m.[0mDEPRECATION WARNING: It looks like you are eager loading table(s) (one of: scoring_models, scoring_model_assignments, programs) that are referenced in a string SQL snippet. For example:



    Post.includes(:comments).where("comments.title = 'foo'")



Currently, Active Record recognizes the table in the string, and knows to JOIN the comments table to the query, rather than loading comments in a separate query. However, doing this without writing a full-blown SQL parser is inherently flawed. Since we don't want to write an SQL parser, we are removing this functionality. From now on, you must explicitly tell Active Record when you are referencing a table from a string:



    Post.includes(:comments).where("comments.title = 'foo'").references(:comments)



If you don't rely on implicit join references you can disable the feature entirely by setting `config.active_record.disable_implicit_join_references = true`. (called from score_for_scoring_models at /home/travis/build/Liaison-Intl/WebAdMIT/app/models/scoring/scorer.rb:50)

DEPRECATION WARNING: It looks like you are eager loading table(s) (one of: scoring_models, scoring_model_assignments, programs) that are referenced in a string SQL snippet. For example:



    Post.includes(:comments).where("comments.title = 'foo'")



Currently, Active Record recognizes the table in the string, and knows to JOIN the comments table to the query, rather than loading comments in a separate query. However, doing this without writing a full-blown SQL parser is inherently flawed. Since we don't want to write an SQL parser, we are removing this functionality. From now on, you must explicitly tell Active Record when you are referencing a table from a string:



    Post.includes(:comments).where("comments.title = 'foo'").references(:comments)



If you don't rely on implicit join references you can disable the feature entirely by setting `config.active_record.disable_implicit_join_references = true`. (called from score_for_scoring_models at /home/travis/build/Liaison-Intl/WebAdMIT/app/models/scoring/scorer.rb:50)

DEPRECATION WARNING: It looks like you are eager loading table(s) (one of: designations, programs) that are referenced in a string SQL snippet. For example:



    Post.includes(:comments).where("comments.title = 'foo'")



Currently, Active Record recognizes the table in the string, and knows to JOIN the comments table to the query, rather than loading comments in a separate query. However, doing this without writing a full-blown SQL parser is inherently flawed. Since we don't want to write an SQL parser, we are removing this functionality. From now on, you must explicitly tell Active Record when you are referencing a table from a string:



    Post.includes(:comments).where("comments.title = 'foo'").references(:comments)



If you don't rely on implicit join references you can disable the feature entirely by setting `config.active_record.disable_implicit_join_references = true`. (called from designations_received? at /home/travis/build/Liaison-Intl/WebAdMIT/app/models/applicant.rb:941)

DEPRECATION WARNING: Relation#all is deprecated. If you want to eager-load a relation, you can call #load (e.g. `Post.where(published: true).load`). If you want to get an array of records from a relation, you can call #to_a (e.g. `Post.where(published: true).to_a`). (called from _app_views_layouts__advisor_sidebar_haml__4578835400478025503_343596640 at /home/travis/build/Liaison-Intl/WebAdMIT/app/views/layouts/_advisor_sidebar.haml:12)

[32m.[0mDEPRECATION WARNING: It looks like you are eager loading table(s) (one of: scoring_models, scoring_model_assignments, programs) that are referenced in a string SQL snippet. For example:



    Post.includes(:comments).where("comments.title = 'foo'")



Currently, Active Record recognizes the table in the string, and knows to JOIN the comments table to the query, rather than loading comments in a separate query. However, doing this without writing a full-blown SQL parser is inherently flawed. Since we don't want to write an SQL parser, we are removing this functionality. From now on, you must explicitly tell Active Record when you are referencing a table from a string:



    Post.includes(:comments).where("comments.title = 'foo'").references(:comments)



If you don't rely on implicit join references you can disable the feature entirely by setting `config.active_record.disable_implicit_join_references = true`. (called from score_for_scoring_models at /home/travis/build/Liaison-Intl/WebAdMIT/app/models/scoring/scorer.rb:50)

DEPRECATION WARNING: It looks like you are eager loading table(s) (one of: designations, programs, user_identity_programs) that are referenced in a string SQL snippet. For example:



    Post.includes(:comments).where("comments.title = 'foo'")



Currently, Active Record recognizes the table in the string, and knows to JOIN the comments table to the query, rather than loading comments in a separate query. However, doing this without writing a full-blown SQL parser is inherently flawed. Since we don't want to write an SQL parser, we are removing this functionality. From now on, you must explicitly tell Active Record when you are referencing a table from a string:



    Post.includes(:comments).where("comments.title = 'foo'").references(:comments)



If you don't rely on implicit join references you can disable the feature entirely by setting `config.active_record.disable_implicit_join_references = true`. (called from designations_received? at /home/travis/build/Liaison-Intl/WebAdMIT/app/models/applicant.rb:941)

[32m.[0mDEPRECATION WARNING: It looks like you are eager loading table(s) (one of: scoring_models, scoring_model_assignments, programs) that are referenced in a string SQL snippet. For example:



    Post.includes(:comments).where("comments.title = 'foo'")



Currently, Active Record recognizes the table in the string, and knows to JOIN the comments table to the query, rather than loading comments in a separate query. However, doing this without writing a full-blown SQL parser is inherently flawed. Since we don't want to write an SQL parser, we are removing this functionality. From now on, you must explicitly tell Active Record when you are referencing a table from a string:



    Post.includes(:comments).where("comments.title = 'foo'").references(:comments)



If you don't rely on implicit join references you can disable the feature entirely by setting `config.active_record.disable_implicit_join_references = true`. (called from score_for_scoring_models at /home/travis/build/Liaison-Intl/WebAdMIT/app/models/scoring/scorer.rb:50)

DEPRECATION WARNING: It looks like you are eager loading table(s) (one of: scoring_models, scoring_model_assignments, programs) that are referenced in a string SQL snippet. For example:



    Post.includes(:comments).where("comments.title = 'foo'")



Currently, Active Record recognizes the table in the string, and knows to JOIN the comments table to the query, rather than loading comments in a separate query. However, doing this without writing a full-blown SQL parser is inherently flawed. Since we don't want to write an SQL parser, we are removing this functionality. From now on, you must explicitly tell Active Record when you are referencing a table from a string:



    Post.includes(:comments).where("comments.title = 'foo'").references(:comments)



If you don't rely on implicit join references you can disable the feature entirely by setting `config.active_record.disable_implicit_join_references = true`. (called from score_for_scoring_models at /home/travis/build/Liaison-Intl/WebAdMIT/app/models/scoring/scorer.rb:50)

DEPRECATION WARNING: It looks like you are eager loading table(s) (one of: designations, programs, user_identity_programs) that are referenced in a string SQL snippet. For example:



    Post.includes(:comments).where("comments.title = 'foo'")



Currently, Active Record recognizes the table in the string, and knows to JOIN the comments table to the query, rather than loading comments in a separate query. However, doing this without writing a full-blown SQL parser is inherently flawed. Since we don't want to write an SQL parser, we are removing this functionality. From now on, you must explicitly tell Active Record when you are referencing a table from a string:



    Post.includes(:comments).where("comments.title = 'foo'").references(:comments)



If you don't rely on implicit join references you can disable the feature entirely by setting `config.active_record.disable_implicit_join_references = true`. (called from designations_received? at /home/travis/build/Liaison-Intl/WebAdMIT/app/models/applicant.rb:941)

[32m.[0mDEPRECATION WARNING: It looks like you are eager loading table(s) (one of: scoring_models, scoring_model_assignments, programs) that are referenced in a string SQL snippet. For example:



    Post.includes(:comments).where("comments.title = 'foo'")



Currently, Active Record recognizes the table in the string, and knows to JOIN the comments table to the query, rather than loading comments in a separate query. However, doing this without writing a full-blown SQL parser is inherently flawed. Since we don't want to write an SQL parser, we are removing this functionality. From now on, you must explicitly tell Active Record when you are referencing a table from a string:



    Post.includes(:comments).where("comments.title = 'foo'").references(:comments)



If you don't rely on implicit join references you can disable the feature entirely by setting `config.active_record.disable_implicit_join_references = true`. (called from score_for_scoring_models at /home/travis/build/Liaison-Intl/WebAdMIT/app/models/scoring/scorer.rb:50)

DEPRECATION WARNING: It looks like you are eager loading table(s) (one of: designations, programs, user_identity_programs) that are referenced in a string SQL snippet. For example:



    Post.includes(:comments).where("comments.title = 'foo'")



Currently, Active Record recognizes the table in the string, and knows to JOIN the comments table to the query, rather than loading comments in a separate query. However, doing this without writing a full-blown SQL parser is inherently flawed. Since we don't want to write an SQL parser, we are removing this functionality. From now on, you must explicitly tell Active Record when you are referencing a table from a string:



    Post.includes(:comments).where("comments.title = 'foo'").references(:comments)



If you don't rely on implicit join references you can disable the feature entirely by setting `config.active_record.disable_implicit_join_references = true`. (called from designations_received? at /home/travis/build/Liaison-Intl/WebAdMIT/app/models/applicant.rb:941)

[32m.[0mDEPRECATION WARNING: It looks like you are eager loading table(s) (one of: scoring_models, scoring_model_assignments, programs) that are referenced in a string SQL snippet. For example:



    Post.includes(:comments).where("comments.title = 'foo'")



Currently, Active Record recognizes the table in the string, and knows to JOIN the comments table to the query, rather than loading comments in a separate query. However, doing this without writing a full-blown SQL parser is inherently flawed. Since we don't want to write an SQL parser, we are removing this functionality. From now on, you must explicitly tell Active Record when you are referencing a table from a string:



    Post.includes(:comments).where("comments.title = 'foo'").references(:comments)



If you don't rely on implicit join references you can disable the feature entirely by setting `config.active_record.disable_implicit_join_references = true`. (called from score_for_scoring_models at /home/travis/build/Liaison-Intl/WebAdMIT/app/models/scoring/scorer.rb:50)

DEPRECATION WARNING: It looks like you are eager loading table(s) (one of: designations, programs, user_identity_programs) that are referenced in a string SQL snippet. For example:



    Post.includes(:comments).where("comments.title = 'foo'")



Currently, Active Record recognizes the table in the string, and knows to JOIN the comments table to the query, rather than loading comments in a separate query. However, doing this without writing a full-blown SQL parser is inherently flawed. Since we don't want to write an SQL parser, we are removing this functionality. From now on, you must explicitly tell Active Record when you are referencing a table from a string:



    Post.includes(:comments).where("comments.title = 'foo'").references(:comments)



If you don't rely on implicit join references you can disable the feature entirely by setting `config.active_record.disable_implicit_join_references = true`. (called from designations_received? at /home/travis/build/Liaison-Intl/WebAdMIT/app/models/applicant.rb:941)

[32m.[0mDEPRECATION WARNING: It looks like you are eager loading table(s) (one of: scoring_models, scoring_model_assignments, programs) that are referenced in a string SQL snippet. For example:



    Post.includes(:comments).where("comments.title = 'foo'")



Currently, Active Record recognizes the table in the string, and knows to JOIN the comments table to the query, rather than loading comments in a separate query. However, doing this without writing a full-blown SQL parser is inherently flawed. Since we don't want to write an SQL parser, we are removing this functionality. From now on, you must explicitly tell Active Record when you are referencing a table from a string:



    Post.includes(:comments).where("comments.title = 'foo'").references(:comments)



If you don't rely on implicit join references you can disable the feature entirely by setting `config.active_record.disable_implicit_join_references = true`. (called from score_for_scoring_models at /home/travis/build/Liaison-Intl/WebAdMIT/app/models/scoring/scorer.rb:50)

DEPRECATION WARNING: It looks like you are eager loading table(s) (one of: designations, programs, user_identity_programs) that are referenced in a string SQL snippet. For example:



    Post.includes(:comments).where("comments.title = 'foo'")



Currently, Active Record recognizes the table in the string, and knows to JOIN the comments table to the query, rather than loading comments in a separate query. However, doing this without writing a full-blown SQL parser is inherently flawed. Since we don't want to write an SQL parser, we are removing this functionality. From now on, you must explicitly tell Active Record when you are referencing a table from a string:



    Post.includes(:comments).where("comments.title = 'foo'").references(:comments)



If you don't rely on implicit join references you can disable the feature entirely by setting `config.active_record.disable_implicit_join_references = true`. (called from designations_received? at /home/travis/build/Liaison-Intl/WebAdMIT/app/models/applicant.rb:941)

[32m.[0mDEPRECATION WARNING: It looks like you are eager loading table(s) (one of: scoring_models, scoring_model_assignments, programs) that are referenced in a string SQL snippet. For example:



    Post.includes(:comments).where("comments.title = 'foo'")



Currently, Active Record recognizes the table in the string, and knows to JOIN the comments table to the query, rather than loading comments in a separate query. However, doing this without writing a full-blown SQL parser is inherently flawed. Since we don't want to write an SQL parser, we are removing this functionality. From now on, you must explicitly tell Active Record when you are referencing a table from a string:



    Post.includes(:comments).where("comments.title = 'foo'").references(:comments)



If you don't rely on implicit join references you can disable the feature entirely by setting `config.active_record.disable_implicit_join_references = true`. (called from score_for_scoring_models at /home/travis/build/Liaison-Intl/WebAdMIT/app/models/scoring/scorer.rb:50)

DEPRECATION WARNING: It looks like you are eager loading table(s) (one of: designations, programs, user_identity_programs) that are referenced in a string SQL snippet. For example:



    Post.includes(:comments).where("comments.title = 'foo'")



Currently, Active Record recognizes the table in the string, and knows to JOIN the comments table to the query, rather than loading comments in a separate query. However, doing this without writing a full-blown SQL parser is inherently flawed. Since we don't want to write an SQL parser, we are removing this functionality. From now on, you must explicitly tell Active Record when you are referencing a table from a string:



    Post.includes(:comments).where("comments.title = 'foo'").references(:comments)



If you don't rely on implicit join references you can disable the feature entirely by setting `config.active_record.disable_implicit_join_references = true`. (called from designations_received? at /home/travis/build/Liaison-Intl/WebAdMIT/app/models/applicant.rb:941)

[32m.[0mDEPRECATION WARNING: It looks like you are eager loading table(s) (one of: scoring_models, scoring_model_assignments, programs) that are referenced in a string SQL snippet. For example:



    Post.includes(:comments).where("comments.title = 'foo'")



Currently, Active Record recognizes the table in the string, and knows to JOIN the comments table to the query, rather than loading comments in a separate query. However, doing this without writing a full-blown SQL parser is inherently flawed. Since we don't want to write an SQL parser, we are removing this functionality. From now on, you must explicitly tell Active Record when you are referencing a table from a string:



    Post.includes(:comments).where("comments.title = 'foo'").references(:comments)



If you don't rely on implicit join references you can disable the feature entirely by setting `config.active_record.disable_implicit_join_references = true`. (called from score_for_scoring_models at /home/travis/build/Liaison-Intl/WebAdMIT/app/models/scoring/scorer.rb:50)

DEPRECATION WARNING: It looks like you are eager loading table(s) (one of: designations, programs, user_identity_programs) that are referenced in a string SQL snippet. For example:



    Post.includes(:comments).where("comments.title = 'foo'")



Currently, Active Record recognizes the table in the string, and knows to JOIN the comments table to the query, rather than loading comments in a separate query. However, doing this without writing a full-blown SQL parser is inherently flawed. Since we don't want to write an SQL parser, we are removing this functionality. From now on, you must explicitly tell Active Record when you are referencing a table from a string:



    Post.includes(:comments).where("comments.title = 'foo'").references(:comments)



If you don't rely on implicit join references you can disable the feature entirely by setting `config.active_record.disable_implicit_join_references = true`. (called from designations_received? at /home/travis/build/Liaison-Intl/WebAdMIT/app/models/applicant.rb:941)

[32m.[0mDEPRECATION WARNING: It looks like you are eager loading table(s) (one of: scoring_models, scoring_model_assignments, programs) that are referenced in a string SQL snippet. For example:



    Post.includes(:comments).where("comments.title = 'foo'")



Currently, Active Record recognizes the table in the string, and knows to JOIN the comments table to the query, rather than loading comments in a separate query. However, doing this without writing a full-blown SQL parser is inherently flawed. Since we don't want to write an SQL parser, we are removing this functionality. From now on, you must explicitly tell Active Record when you are referencing a table from a string:



    Post.includes(:comments).where("comments.title = 'foo'").references(:comments)



If you don't rely on implicit join references you can disable the feature entirely by setting `config.active_record.disable_implicit_join_references = true`. (called from score_for_scoring_models at /home/travis/build/Liaison-Intl/WebAdMIT/app/models/scoring/scorer.rb:50)

DEPRECATION WARNING: It looks like you are eager loading table(s) (one of: designations, programs, user_identity_programs) that are referenced in a string SQL snippet. For example:



    Post.includes(:comments).where("comments.title = 'foo'")



Currently, Active Record recognizes the table in the string, and knows to JOIN the comments table to the query, rather than loading comments in a separate query. However, doing this without writing a full-blown SQL parser is inherently flawed. Since we don't want to write an SQL parser, we are removing this functionality. From now on, you must explicitly tell Active Record when you are referencing a table from a string:



    Post.includes(:comments).where("comments.title = 'foo'").references(:comments)



If you don't rely on implicit join references you can disable the feature entirely by setting `config.active_record.disable_implicit_join_references = true`. (called from designations_received? at /home/travis/build/Liaison-Intl/WebAdMIT/app/models/applicant.rb:941)

[32m.[0mDEPRECATION WARNING: It looks like you are eager loading table(s) (one of: scoring_models, scoring_model_assignments, programs) that are referenced in a string SQL snippet. For example:



    Post.includes(:comments).where("comments.title = 'foo'")



Currently, Active Record recognizes the table in the string, and knows to JOIN the comments table to the query, rather than loading comments in a separate query. However, doing this without writing a full-blown SQL parser is inherently flawed. Since we don't want to write an SQL parser, we are removing this functionality. From now on, you must explicitly tell Active Record when you are referencing a table from a string:



    Post.includes(:comments).where("comments.title = 'foo'").references(:comments)



If you don't rely on implicit join references you can disable the feature entirely by setting `config.active_record.disable_implicit_join_references = true`. (called from score_for_scoring_models at /home/travis/build/Liaison-Intl/WebAdMIT/app/models/scoring/scorer.rb:50)

DEPRECATION WARNING: It looks like you are eager loading table(s) (one of: designations, programs, user_identity_programs) that are referenced in a string SQL snippet. For example:



    Post.includes(:comments).where("comments.title = 'foo'")



Currently, Active Record recognizes the table in the string, and knows to JOIN the comments table to the query, rather than loading comments in a separate query. However, doing this without writing a full-blown SQL parser is inherently flawed. Since we don't want to write an SQL parser, we are removing this functionality. From now on, you must explicitly tell Active Record when you are referencing a table from a string:



    Post.includes(:comments).where("comments.title = 'foo'").references(:comments)



If you don't rely on implicit join references you can disable the feature entirely by setting `config.active_record.disable_implicit_join_references = true`. (called from designations_received? at /home/travis/build/Liaison-Intl/WebAdMIT/app/models/applicant.rb:941)

[32m.[0mDEPRECATION WARNING: It looks like you are eager loading table(s) (one of: scoring_models, scoring_model_assignments, programs) that are referenced in a string SQL snippet. For example:



    Post.includes(:comments).where("comments.title = 'foo'")



Currently, Active Record recognizes the table in the string, and knows to JOIN the comments table to the query, rather than loading comments in a separate query. However, doing this without writing a full-blown SQL parser is inherently flawed. Since we don't want to write an SQL parser, we are removing this functionality. From now on, you must explicitly tell Active Record when you are referencing a table from a string:



    Post.includes(:comments).where("comments.title = 'foo'").references(:comments)



If you don't rely on implicit join references you can disable the feature entirely by setting `config.active_record.disable_implicit_join_references = true`. (called from score_for_scoring_models at /home/travis/build/Liaison-Intl/WebAdMIT/app/models/scoring/scorer.rb:50)

DEPRECATION WARNING: It looks like you are eager loading table(s) (one of: designations, programs, user_identity_programs) that are referenced in a string SQL snippet. For example:



    Post.includes(:comments).where("comments.title = 'foo'")



Currently, Active Record recognizes the table in the string, and knows to JOIN the comments table to the query, rather than loading comments in a separate query. However, doing this without writing a full-blown SQL parser is inherently flawed. Since we don't want to write an SQL parser, we are removing this functionality. From now on, you must explicitly tell Active Record when you are referencing a table from a string:



    Post.includes(:comments).where("comments.title = 'foo'").references(:comments)



If you don't rely on implicit join references you can disable the feature entirely by setting `config.active_record.disable_implicit_join_references = true`. (called from designations_received? at /home/travis/build/Liaison-Intl/WebAdMIT/app/models/applicant.rb:941)

[32m.[0mDEPRECATION WARNING: It looks like you are eager loading table(s) (one of: scoring_models, scoring_model_assignments, programs) that are referenced in a string SQL snippet. For example:



    Post.includes(:comments).where("comments.title = 'foo'")



Currently, Active Record recognizes the table in the string, and knows to JOIN the comments table to the query, rather than loading comments in a separate query. However, doing this without writing a full-blown SQL parser is inherently flawed. Since we don't want to write an SQL parser, we are removing this functionality. From now on, you must explicitly tell Active Record when you are referencing a table from a string:



    Post.includes(:comments).where("comments.title = 'foo'").references(:comments)



If you don't rely on implicit join references you can disable the feature entirely by setting `config.active_record.disable_implicit_join_references = true`. (called from score_for_scoring_models at /home/travis/build/Liaison-Intl/WebAdMIT/app/models/scoring/scorer.rb:50)

DEPRECATION WARNING: It looks like you are eager loading table(s) (one of: designations, programs, user_identity_programs) that are referenced in a string SQL snippet. For example:



    Post.includes(:comments).where("comments.title = 'foo'")



Currently, Active Record recognizes the table in the string, and knows to JOIN the comments table to the query, rather than loading comments in a separate query. However, doing this without writing a full-blown SQL parser is inherently flawed. Since we don't want to write an SQL parser, we are removing this functionality. From now on, you must explicitly tell Active Record when you are referencing a table from a string:



    Post.includes(:comments).where("comments.title = 'foo'").references(:comments)



If you don't rely on implicit join references you can disable the feature entirely by setting `config.active_record.disable_implicit_join_references = true`. (called from designations_received? at /home/travis/build/Liaison-Intl/WebAdMIT/app/models/applicant.rb:941)

[32m.[0mDEPRECATION WARNING: It looks like you are eager loading table(s) (one of: scoring_models, scoring_model_assignments, programs) that are referenced in a string SQL snippet. For example:



    Post.includes(:comments).where("comments.title = 'foo'")



Currently, Active Record recognizes the table in the string, and knows to JOIN the comments table to the query, rather than loading comments in a separate query. However, doing this without writing a full-blown SQL parser is inherently flawed. Since we don't want to write an SQL parser, we are removing this functionality. From now on, you must explicitly tell Active Record when you are referencing a table from a string:



    Post.includes(:comments).where("comments.title = 'foo'").references(:comments)



If you don't rely on implicit join references you can disable the feature entirely by setting `config.active_record.disable_implicit_join_references = true`. (called from score_for_scoring_models at /home/travis/build/Liaison-Intl/WebAdMIT/app/models/scoring/scorer.rb:50)

DEPRECATION WARNING: It looks like you are eager loading table(s) (one of: designations, programs, user_identity_programs) that are referenced in a string SQL snippet. For example:



    Post.includes(:comments).where("comments.title = 'foo'")



Currently, Active Record recognizes the table in the string, and knows to JOIN the comments table to the query, rather than loading comments in a separate query. However, doing this without writing a full-blown SQL parser is inherently flawed. Since we don't want to write an SQL parser, we are removing this functionality. From now on, you must explicitly tell Active Record when you are referencing a table from a string:



    Post.includes(:comments).where("comments.title = 'foo'").references(:comments)



If you don't rely on implicit join references you can disable the feature entirely by setting `config.active_record.disable_implicit_join_references = true`. (called from designations_received? at /home/travis/build/Liaison-Intl/WebAdMIT/app/models/applicant.rb:941)

[32m.[0mDEPRECATION WARNING: It looks like you are eager loading table(s) (one of: scoring_models, scoring_model_assignments, programs) that are referenced in a string SQL snippet. For example:



    Post.includes(:comments).where("comments.title = 'foo'")



Currently, Active Record recognizes the table in the string, and knows to JOIN the comments table to the query, rather than loading comments in a separate query. However, doing this without writing a full-blown SQL parser is inherently flawed. Since we don't want to write an SQL parser, we are removing this functionality. From now on, you must explicitly tell Active Record when you are referencing a table from a string:



    Post.includes(:comments).where("comments.title = 'foo'").references(:comments)



If you don't rely on implicit join references you can disable the feature entirely by setting `config.active_record.disable_implicit_join_references = true`. (called from score_for_scoring_models at /home/travis/build/Liaison-Intl/WebAdMIT/app/models/scoring/scorer.rb:50)

DEPRECATION WARNING: It looks like you are eager loading table(s) (one of: designations, programs, user_identity_programs) that are referenced in a string SQL snippet. For example:



    Post.includes(:comments).where("comments.title = 'foo'")



Currently, Active Record recognizes the table in the string, and knows to JOIN the comments table to the query, rather than loading comments in a separate query. However, doing this without writing a full-blown SQL parser is inherently flawed. Since we don't want to write an SQL parser, we are removing this functionality. From now on, you must explicitly tell Active Record when you are referencing a table from a string:



    Post.includes(:comments).where("comments.title = 'foo'").references(:comments)



If you don't rely on implicit join references you can disable the feature entirely by setting `config.active_record.disable_implicit_join_references = true`. (called from designations_received? at /home/travis/build/Liaison-Intl/WebAdMIT/app/models/applicant.rb:941)

[32m.[0mDEPRECATION WARNING: It looks like you are eager loading table(s) (one of: scoring_models, scoring_model_assignments, programs) that are referenced in a string SQL snippet. For example:



    Post.includes(:comments).where("comments.title = 'foo'")



Currently, Active Record recognizes the table in the string, and knows to JOIN the comments table to the query, rather than loading comments in a separate query. However, doing this without writing a full-blown SQL parser is inherently flawed. Since we don't want to write an SQL parser, we are removing this functionality. From now on, you must explicitly tell Active Record when you are referencing a table from a string:



    Post.includes(:comments).where("comments.title = 'foo'").references(:comments)



If you don't rely on implicit join references you can disable the feature entirely by setting `config.active_record.disable_implicit_join_references = true`. (called from score_for_scoring_models at /home/travis/build/Liaison-Intl/WebAdMIT/app/models/scoring/scorer.rb:50)

DEPRECATION WARNING: It looks like you are eager loading table(s) (one of: designations, programs, user_identity_programs) that are referenced in a string SQL snippet. For example:



    Post.includes(:comments).where("comments.title = 'foo'")



Currently, Active Record recognizes the table in the string, and knows to JOIN the comments table to the query, rather than loading comments in a separate query. However, doing this without writing a full-blown SQL parser is inherently flawed. Since we don't want to write an SQL parser, we are removing this functionality. From now on, you must explicitly tell Active Record when you are referencing a table from a string:



    Post.includes(:comments).where("comments.title = 'foo'").references(:comments)



If you don't rely on implicit join references you can disable the feature entirely by setting `config.active_record.disable_implicit_join_references = true`. (called from designations_received? at /home/travis/build/Liaison-Intl/WebAdMIT/app/models/applicant.rb:941)

[32m.[0mDEPRECATION WARNING: It looks like you are eager loading table(s) (one of: scoring_models, scoring_model_assignments, programs) that are referenced in a string SQL snippet. For example:



    Post.includes(:comments).where("comments.title = 'foo'")



Currently, Active Record recognizes the table in the string, and knows to JOIN the comments table to the query, rather than loading comments in a separate query. However, doing this without writing a full-blown SQL parser is inherently flawed. Since we don't want to write an SQL parser, we are removing this functionality. From now on, you must explicitly tell Active Record when you are referencing a table from a string:



    Post.includes(:comments).where("comments.title = 'foo'").references(:comments)



If you don't rely on implicit join references you can disable the feature entirely by setting `config.active_record.disable_implicit_join_references = true`. (called from score_for_scoring_models at /home/travis/build/Liaison-Intl/WebAdMIT/app/models/scoring/scorer.rb:50)

DEPRECATION WARNING: It looks like you are eager loading table(s) (one of: designations, programs, user_identity_programs) that are referenced in a string SQL snippet. For example:



    Post.includes(:comments).where("comments.title = 'foo'")



Currently, Active Record recognizes the table in the string, and knows to JOIN the comments table to the query, rather than loading comments in a separate query. However, doing this without writing a full-blown SQL parser is inherently flawed. Since we don't want to write an SQL parser, we are removing this functionality. From now on, you must explicitly tell Active Record when you are referencing a table from a string:



    Post.includes(:comments).where("comments.title = 'foo'").references(:comments)



If you don't rely on implicit join references you can disable the feature entirely by setting `config.active_record.disable_implicit_join_references = true`. (called from designations_received? at /home/travis/build/Liaison-Intl/WebAdMIT/app/models/applicant.rb:941)

[32m.[0mDEPRECATION WARNING: It looks like you are eager loading table(s) (one of: scoring_models, scoring_model_assignments, programs) that are referenced in a string SQL snippet. For example:



    Post.includes(:comments).where("comments.title = 'foo'")



Currently, Active Record recognizes the table in the string, and knows to JOIN the comments table to the query, rather than loading comments in a separate query. However, doing this without writing a full-blown SQL parser is inherently flawed. Since we don't want to write an SQL parser, we are removing this functionality. From now on, you must explicitly tell Active Record when you are referencing a table from a string:



    Post.includes(:comments).where("comments.title = 'foo'").references(:comments)



If you don't rely on implicit join references you can disable the feature entirely by setting `config.active_record.disable_implicit_join_references = true`. (called from score_for_scoring_models at /home/travis/build/Liaison-Intl/WebAdMIT/app/models/scoring/scorer.rb:50)

DEPRECATION WARNING: It looks like you are eager loading table(s) (one of: designations, programs, user_identity_programs) that are referenced in a string SQL snippet. For example:



    Post.includes(:comments).where("comments.title = 'foo'")



Currently, Active Record recognizes the table in the string, and knows to JOIN the comments table to the query, rather than loading comments in a separate query. However, doing this without writing a full-blown SQL parser is inherently flawed. Since we don't want to write an SQL parser, we are removing this functionality. From now on, you must explicitly tell Active Record when you are referencing a table from a string:



    Post.includes(:comments).where("comments.title = 'foo'").references(:comments)



If you don't rely on implicit join references you can disable the feature entirely by setting `config.active_record.disable_implicit_join_references = true`. (called from designations_received? at /home/travis/build/Liaison-Intl/WebAdMIT/app/models/applicant.rb:941)

[32m.[0mDEPRECATION WARNING: It looks like you are eager loading table(s) (one of: scoring_models, scoring_model_assignments, programs) that are referenced in a string SQL snippet. For example:



    Post.includes(:comments).where("comments.title = 'foo'")



Currently, Active Record recognizes the table in the string, and knows to JOIN the comments table to the query, rather than loading comments in a separate query. However, doing this without writing a full-blown SQL parser is inherently flawed. Since we don't want to write an SQL parser, we are removing this functionality. From now on, you must explicitly tell Active Record when you are referencing a table from a string:



    Post.includes(:comments).where("comments.title = 'foo'").references(:comments)



If you don't rely on implicit join references you can disable the feature entirely by setting `config.active_record.disable_implicit_join_references = true`. (called from score_for_scoring_models at /home/travis/build/Liaison-Intl/WebAdMIT/app/models/scoring/scorer.rb:50)

DEPRECATION WARNING: It looks like you are eager loading table(s) (one of: designations, programs, user_identity_programs) that are referenced in a string SQL snippet. For example:



    Post.includes(:comments).where("comments.title = 'foo'")



Currently, Active Record recognizes the table in the string, and knows to JOIN the comments table to the query, rather than loading comments in a separate query. However, doing this without writing a full-blown SQL parser is inherently flawed. Since we don't want to write an SQL parser, we are removing this functionality. From now on, you must explicitly tell Active Record when you are referencing a table from a string:



    Post.includes(:comments).where("comments.title = 'foo'").references(:comments)



If you don't rely on implicit join references you can disable the feature entirely by setting `config.active_record.disable_implicit_join_references = true`. (called from designations_received? at /home/travis/build/Liaison-Intl/WebAdMIT/app/models/applicant.rb:941)

[32m.[0mDEPRECATION WARNING: It looks like you are eager loading table(s) (one of: scoring_models, scoring_model_assignments, programs) that are referenced in a string SQL snippet. For example:



    Post.includes(:comments).where("comments.title = 'foo'")



Currently, Active Record recognizes the table in the string, and knows to JOIN the comments table to the query, rather than loading comments in a separate query. However, doing this without writing a full-blown SQL parser is inherently flawed. Since we don't want to write an SQL parser, we are removing this functionality. From now on, you must explicitly tell Active Record when you are referencing a table from a string:



    Post.includes(:comments).where("comments.title = 'foo'").references(:comments)



If you don't rely on implicit join references you can disable the feature entirely by setting `config.active_record.disable_implicit_join_references = true`. (called from score_for_scoring_models at /home/travis/build/Liaison-Intl/WebAdMIT/app/models/scoring/scorer.rb:50)

DEPRECATION WARNING: It looks like you are eager loading table(s) (one of: designations, programs, user_identity_programs) that are referenced in a string SQL snippet. For example:



    Post.includes(:comments).where("comments.title = 'foo'")



Currently, Active Record recognizes the table in the string, and knows to JOIN the comments table to the query, rather than loading comments in a separate query. However, doing this without writing a full-blown SQL parser is inherently flawed. Since we don't want to write an SQL parser, we are removing this functionality. From now on, you must explicitly tell Active Record when you are referencing a table from a string:



    Post.includes(:comments).where("comments.title = 'foo'").references(:comments)



If you don't rely on implicit join references you can disable the feature entirely by setting `config.active_record.disable_implicit_join_references = true`. (called from designations_received? at /home/travis/build/Liaison-Intl/WebAdMIT/app/models/applicant.rb:941)

[32m.[0mDEPRECATION WARNING: It looks like you are eager loading table(s) (one of: scoring_models, scoring_model_assignments, programs) that are referenced in a string SQL snippet. For example:



    Post.includes(:comments).where("comments.title = 'foo'")



Currently, Active Record recognizes the table in the string, and knows to JOIN the comments table to the query, rather than loading comments in a separate query. However, doing this without writing a full-blown SQL parser is inherently flawed. Since we don't want to write an SQL parser, we are removing this functionality. From now on, you must explicitly tell Active Record when you are referencing a table from a string:



    Post.includes(:comments).where("comments.title = 'foo'").references(:comments)



If you don't rely on implicit join references you can disable the feature entirely by setting `config.active_record.disable_implicit_join_references = true`. (called from score_for_scoring_models at /home/travis/build/Liaison-Intl/WebAdMIT/app/models/scoring/scorer.rb:50)

DEPRECATION WARNING: It looks like you are eager loading table(s) (one of: designations, programs, user_identity_programs) that are referenced in a string SQL snippet. For example:



    Post.includes(:comments).where("comments.title = 'foo'")



Currently, Active Record recognizes the table in the string, and knows to JOIN the comments table to the query, rather than loading comments in a separate query. However, doing this without writing a full-blown SQL parser is inherently flawed. Since we don't want to write an SQL parser, we are removing this functionality. From now on, you must explicitly tell Active Record when you are referencing a table from a string:



    Post.includes(:comments).where("comments.title = 'foo'").references(:comments)



If you don't rely on implicit join references you can disable the feature entirely by setting `config.active_record.disable_implicit_join_references = true`. (called from designations_received? at /home/travis/build/Liaison-Intl/WebAdMIT/app/models/applicant.rb:941)

[32m.[0mDEPRECATION WARNING: It looks like you are eager loading table(s) (one of: scoring_models, scoring_model_assignments, programs) that are referenced in a string SQL snippet. For example:



    Post.includes(:comments).where("comments.title = 'foo'")



Currently, Active Record recognizes the table in the string, and knows to JOIN the comments table to the query, rather than loading comments in a separate query. However, doing this without writing a full-blown SQL parser is inherently flawed. Since we don't want to write an SQL parser, we are removing this functionality. From now on, you must explicitly tell Active Record when you are referencing a table from a string:



    Post.includes(:comments).where("comments.title = 'foo'").references(:comments)



If you don't rely on implicit join references you can disable the feature entirely by setting `config.active_record.disable_implicit_join_references = true`. (called from score_for_scoring_models at /home/travis/build/Liaison-Intl/WebAdMIT/app/models/scoring/scorer.rb:50)

DEPRECATION WARNING: It looks like you are eager loading table(s) (one of: designations, programs, user_identity_programs) that are referenced in a string SQL snippet. For example:



    Post.includes(:comments).where("comments.title = 'foo'")



Currently, Active Record recognizes the table in the string, and knows to JOIN the comments table to the query, rather than loading comments in a separate query. However, doing this without writing a full-blown SQL parser is inherently flawed. Since we don't want to write an SQL parser, we are removing this functionality. From now on, you must explicitly tell Active Record when you are referencing a table from a string:



    Post.includes(:comments).where("comments.title = 'foo'").references(:comments)



If you don't rely on implicit join references you can disable the feature entirely by setting `config.active_record.disable_implicit_join_references = true`. (called from designations_received? at /home/travis/build/Liaison-Intl/WebAdMIT/app/models/applicant.rb:941)

[32m.[0mDEPRECATION WARNING: It looks like you are eager loading table(s) (one of: scoring_models, scoring_model_assignments, programs) that are referenced in a string SQL snippet. For example:



    Post.includes(:comments).where("comments.title = 'foo'")



Currently, Active Record recognizes the table in the string, and knows to JOIN the comments table to the query, rather than loading comments in a separate query. However, doing this without writing a full-blown SQL parser is inherently flawed. Since we don't want to write an SQL parser, we are removing this functionality. From now on, you must explicitly tell Active Record when you are referencing a table from a string:



    Post.includes(:comments).where("comments.title = 'foo'").references(:comments)



If you don't rely on implicit join references you can disable the feature entirely by setting `config.active_record.disable_implicit_join_references = true`. (called from score_for_scoring_models at /home/travis/build/Liaison-Intl/WebAdMIT/app/models/scoring/scorer.rb:50)

DEPRECATION WARNING: It looks like you are eager loading table(s) (one of: designations, programs, user_identity_programs) that are referenced in a string SQL snippet. For example:



    Post.includes(:comments).where("comments.title = 'foo'")



Currently, Active Record recognizes the table in the string, and knows to JOIN the comments table to the query, rather than loading comments in a separate query. However, doing this without writing a full-blown SQL parser is inherently flawed. Since we don't want to write an SQL parser, we are removing this functionality. From now on, you must explicitly tell Active Record when you are referencing a table from a string:



    Post.includes(:comments).where("comments.title = 'foo'").references(:comments)



If you don't rely on implicit join references you can disable the feature entirely by setting `config.active_record.disable_implicit_join_references = true`. (called from designations_received? at /home/travis/build/Liaison-Intl/WebAdMIT/app/models/applicant.rb:941)

[32m.[0mDEPRECATION WARNING: It looks like you are eager loading table(s) (one of: scoring_models, scoring_model_assignments, programs) that are referenced in a string SQL snippet. For example:



    Post.includes(:comments).where("comments.title = 'foo'")



Currently, Active Record recognizes the table in the string, and knows to JOIN the comments table to the query, rather than loading comments in a separate query. However, doing this without writing a full-blown SQL parser is inherently flawed. Since we don't want to write an SQL parser, we are removing this functionality. From now on, you must explicitly tell Active Record when you are referencing a table from a string:



    Post.includes(:comments).where("comments.title = 'foo'").references(:comments)



If you don't rely on implicit join references you can disable the feature entirely by setting `config.active_record.disable_implicit_join_references = true`. (called from score_for_scoring_models at /home/travis/build/Liaison-Intl/WebAdMIT/app/models/scoring/scorer.rb:50)

DEPRECATION WARNING: It looks like you are eager loading table(s) (one of: designations, programs, user_identity_programs) that are referenced in a string SQL snippet. For example:



    Post.includes(:comments).where("comments.title = 'foo'")



Currently, Active Record recognizes the table in the string, and knows to JOIN the comments table to the query, rather than loading comments in a separate query. However, doing this without writing a full-blown SQL parser is inherently flawed. Since we don't want to write an SQL parser, we are removing this functionality. From now on, you must explicitly tell Active Record when you are referencing a table from a string:



    Post.includes(:comments).where("comments.title = 'foo'").references(:comments)



If you don't rely on implicit join references you can disable the feature entirely by setting `config.active_record.disable_implicit_join_references = true`. (called from designations_received? at /home/travis/build/Liaison-Intl/WebAdMIT/app/models/applicant.rb:941)

[32m.[0mDEPRECATION WARNING: It looks like you are eager loading table(s) (one of: scoring_models, scoring_model_assignments, programs) that are referenced in a string SQL snippet. For example:



    Post.includes(:comments).where("comments.title = 'foo'")



Currently, Active Record recognizes the table in the string, and knows to JOIN the comments table to the query, rather than loading comments in a separate query. However, doing this without writing a full-blown SQL parser is inherently flawed. Since we don't want to write an SQL parser, we are removing this functionality. From now on, you must explicitly tell Active Record when you are referencing a table from a string:



    Post.includes(:comments).where("comments.title = 'foo'").references(:comments)



If you don't rely on implicit join references you can disable the feature entirely by setting `config.active_record.disable_implicit_join_references = true`. (called from score_for_scoring_models at /home/travis/build/Liaison-Intl/WebAdMIT/app/models/scoring/scorer.rb:50)

DEPRECATION WARNING: It looks like you are eager loading table(s) (one of: designations, programs, user_identity_programs) that are referenced in a string SQL snippet. For example:



    Post.includes(:comments).where("comments.title = 'foo'")



Currently, Active Record recognizes the table in the string, and knows to JOIN the comments table to the query, rather than loading comments in a separate query. However, doing this without writing a full-blown SQL parser is inherently flawed. Since we don't want to write an SQL parser, we are removing this functionality. From now on, you must explicitly tell Active Record when you are referencing a table from a string:



    Post.includes(:comments).where("comments.title = 'foo'").references(:comments)



If you don't rely on implicit join references you can disable the feature entirely by setting `config.active_record.disable_implicit_join_references = true`. (called from designations_received? at /home/travis/build/Liaison-Intl/WebAdMIT/app/models/applicant.rb:941)

[32m.[0mDEPRECATION WARNING: It looks like you are eager loading table(s) (one of: scoring_models, scoring_model_assignments, programs) that are referenced in a string SQL snippet. For example:



    Post.includes(:comments).where("comments.title = 'foo'")



Currently, Active Record recognizes the table in the string, and knows to JOIN the comments table to the query, rather than loading comments in a separate query. However, doing this without writing a full-blown SQL parser is inherently flawed. Since we don't want to write an SQL parser, we are removing this functionality. From now on, you must explicitly tell Active Record when you are referencing a table from a string:



    Post.includes(:comments).where("comments.title = 'foo'").references(:comments)



If you don't rely on implicit join references you can disable the feature entirely by setting `config.active_record.disable_implicit_join_references = true`. (called from score_for_scoring_models at /home/travis/build/Liaison-Intl/WebAdMIT/app/models/scoring/scorer.rb:50)

DEPRECATION WARNING: It looks like you are eager loading table(s) (one of: designations, programs, user_identity_programs) that are referenced in a string SQL snippet. For example:



    Post.includes(:comments).where("comments.title = 'foo'")



Currently, Active Record recognizes the table in the string, and knows to JOIN the comments table to the query, rather than loading comments in a separate query. However, doing this without writing a full-blown SQL parser is inherently flawed. Since we don't want to write an SQL parser, we are removing this functionality. From now on, you must explicitly tell Active Record when you are referencing a table from a string:



    Post.includes(:comments).where("comments.title = 'foo'").references(:comments)



If you don't rely on implicit join references you can disable the feature entirely by setting `config.active_record.disable_implicit_join_references = true`. (called from designations_received? at /home/travis/build/Liaison-Intl/WebAdMIT/app/models/applicant.rb:941)

[32m.[0mDEPRECATION WARNING: It looks like you are eager loading table(s) (one of: scoring_models, scoring_model_assignments, programs) that are referenced in a string SQL snippet. For example:



    Post.includes(:comments).where("comments.title = 'foo'")



Currently, Active Record recognizes the table in the string, and knows to JOIN the comments table to the query, rather than loading comments in a separate query. However, doing this without writing a full-blown SQL parser is inherently flawed. Since we don't want to write an SQL parser, we are removing this functionality. From now on, you must explicitly tell Active Record when you are referencing a table from a string:



    Post.includes(:comments).where("comments.title = 'foo'").references(:comments)



If you don't rely on implicit join references you can disable the feature entirely by setting `config.active_record.disable_implicit_join_references = true`. (called from score_for_scoring_models at /home/travis/build/Liaison-Intl/WebAdMIT/app/models/scoring/scorer.rb:50)

DEPRECATION WARNING: It looks like you are eager loading table(s) (one of: designations, programs, user_identity_programs) that are referenced in a string SQL snippet. For example:



    Post.includes(:comments).where("comments.title = 'foo'")



Currently, Active Record recognizes the table in the string, and knows to JOIN the comments table to the query, rather than loading comments in a separate query. However, doing this without writing a full-blown SQL parser is inherently flawed. Since we don't want to write an SQL parser, we are removing this functionality. From now on, you must explicitly tell Active Record when you are referencing a table from a string:



    Post.includes(:comments).where("comments.title = 'foo'").references(:comments)



If you don't rely on implicit join references you can disable the feature entirely by setting `config.active_record.disable_implicit_join_references = true`. (called from designations_received? at /home/travis/build/Liaison-Intl/WebAdMIT/app/models/applicant.rb:941)

[32m.[0mDEPRECATION WARNING: It looks like you are eager loading table(s) (one of: scoring_models, scoring_model_assignments, programs) that are referenced in a string SQL snippet. For example:



    Post.includes(:comments).where("comments.title = 'foo'")



Currently, Active Record recognizes the table in the string, and knows to JOIN the comments table to the query, rather than loading comments in a separate query. However, doing this without writing a full-blown SQL parser is inherently flawed. Since we don't want to write an SQL parser, we are removing this functionality. From now on, you must explicitly tell Active Record when you are referencing a table from a string:



    Post.includes(:comments).where("comments.title = 'foo'").references(:comments)



If you don't rely on implicit join references you can disable the feature entirely by setting `config.active_record.disable_implicit_join_references = true`. (called from score_for_scoring_models at /home/travis/build/Liaison-Intl/WebAdMIT/app/models/scoring/scorer.rb:50)

DEPRECATION WARNING: It looks like you are eager loading table(s) (one of: designations, programs, user_identity_programs) that are referenced in a string SQL snippet. For example:



    Post.includes(:comments).where("comments.title = 'foo'")



Currently, Active Record recognizes the table in the string, and knows to JOIN the comments table to the query, rather than loading comments in a separate query. However, doing this without writing a full-blown SQL parser is inherently flawed. Since we don't want to write an SQL parser, we are removing this functionality. From now on, you must explicitly tell Active Record when you are referencing a table from a string:



    Post.includes(:comments).where("comments.title = 'foo'").references(:comments)



If you don't rely on implicit join references you can disable the feature entirely by setting `config.active_record.disable_implicit_join_references = true`. (called from designations_received? at /home/travis/build/Liaison-Intl/WebAdMIT/app/models/applicant.rb:941)

[32m.[0mDEPRECATION WARNING: It looks like you are eager loading table(s) (one of: scoring_models, scoring_model_assignments, programs) that are referenced in a string SQL snippet. For example:



    Post.includes(:comments).where("comments.title = 'foo'")



Currently, Active Record recognizes the table in the string, and knows to JOIN the comments table to the query, rather than loading comments in a separate query. However, doing this without writing a full-blown SQL parser is inherently flawed. Since we don't want to write an SQL parser, we are removing this functionality. From now on, you must explicitly tell Active Record when you are referencing a table from a string:



    Post.includes(:comments).where("comments.title = 'foo'").references(:comments)



If you don't rely on implicit join references you can disable the feature entirely by setting `config.active_record.disable_implicit_join_references = true`. (called from score_for_scoring_models at /home/travis/build/Liaison-Intl/WebAdMIT/app/models/scoring/scorer.rb:50)

DEPRECATION WARNING: It looks like you are eager loading table(s) (one of: designations, programs, user_identity_programs) that are referenced in a string SQL snippet. For example:



    Post.includes(:comments).where("comments.title = 'foo'")



Currently, Active Record recognizes the table in the string, and knows to JOIN the comments table to the query, rather than loading comments in a separate query. However, doing this without writing a full-blown SQL parser is inherently flawed. Since we don't want to write an SQL parser, we are removing this functionality. From now on, you must explicitly tell Active Record when you are referencing a table from a string:



    Post.includes(:comments).where("comments.title = 'foo'").references(:comments)



If you don't rely on implicit join references you can disable the feature entirely by setting `config.active_record.disable_implicit_join_references = true`. (called from designations_received? at /home/travis/build/Liaison-Intl/WebAdMIT/app/models/applicant.rb:941)

[32m.[0mDEPRECATION WARNING: It looks like you are eager loading table(s) (one of: scoring_models, scoring_model_assignments, programs) that are referenced in a string SQL snippet. For example:



    Post.includes(:comments).where("comments.title = 'foo'")



Currently, Active Record recognizes the table in the string, and knows to JOIN the comments table to the query, rather than loading comments in a separate query. However, doing this without writing a full-blown SQL parser is inherently flawed. Since we don't want to write an SQL parser, we are removing this functionality. From now on, you must explicitly tell Active Record when you are referencing a table from a string:



    Post.includes(:comments).where("comments.title = 'foo'").references(:comments)



If you don't rely on implicit join references you can disable the feature entirely by setting `config.active_record.disable_implicit_join_references = true`. (called from score_for_scoring_models at /home/travis/build/Liaison-Intl/WebAdMIT/app/models/scoring/scorer.rb:50)

DEPRECATION WARNING: It looks like you are eager loading table(s) (one of: designations, programs, user_identity_programs) that are referenced in a string SQL snippet. For example:



    Post.includes(:comments).where("comments.title = 'foo'")



Currently, Active Record recognizes the table in the string, and knows to JOIN the comments table to the query, rather than loading comments in a separate query. However, doing this without writing a full-blown SQL parser is inherently flawed. Since we don't want to write an SQL parser, we are removing this functionality. From now on, you must explicitly tell Active Record when you are referencing a table from a string:



    Post.includes(:comments).where("comments.title = 'foo'").references(:comments)



If you don't rely on implicit join references you can disable the feature entirely by setting `config.active_record.disable_implicit_join_references = true`. (called from designations_received? at /home/travis/build/Liaison-Intl/WebAdMIT/app/models/applicant.rb:941)

[32m.[0mDEPRECATION WARNING: It looks like you are eager loading table(s) (one of: scoring_models, scoring_model_assignments, programs) that are referenced in a string SQL snippet. For example:



    Post.includes(:comments).where("comments.title = 'foo'")



Currently, Active Record recognizes the table in the string, and knows to JOIN the comments table to the query, rather than loading comments in a separate query. However, doing this without writing a full-blown SQL parser is inherently flawed. Since we don't want to write an SQL parser, we are removing this functionality. From now on, you must explicitly tell Active Record when you are referencing a table from a string:



    Post.includes(:comments).where("comments.title = 'foo'").references(:comments)



If you don't rely on implicit join references you can disable the feature entirely by setting `config.active_record.disable_implicit_join_references = true`. (called from score_for_scoring_models at /home/travis/build/Liaison-Intl/WebAdMIT/app/models/scoring/scorer.rb:50)

DEPRECATION WARNING: It looks like you are eager loading table(s) (one of: designations, programs, user_identity_programs) that are referenced in a string SQL snippet. For example:



    Post.includes(:comments).where("comments.title = 'foo'")



Currently, Active Record recognizes the table in the string, and knows to JOIN the comments table to the query, rather than loading comments in a separate query. However, doing this without writing a full-blown SQL parser is inherently flawed. Since we don't want to write an SQL parser, we are removing this functionality. From now on, you must explicitly tell Active Record when you are referencing a table from a string:



    Post.includes(:comments).where("comments.title = 'foo'").references(:comments)



If you don't rely on implicit join references you can disable the feature entirely by setting `config.active_record.disable_implicit_join_references = true`. (called from designations_received? at /home/travis/build/Liaison-Intl/WebAdMIT/app/models/applicant.rb:941)

[32m.[0mDEPRECATION WARNING: It looks like you are eager loading table(s) (one of: scoring_models, scoring_model_assignments, programs) that are referenced in a string SQL snippet. For example:



    Post.includes(:comments).where("comments.title = 'foo'")



Currently, Active Record recognizes the table in the string, and knows to JOIN the comments table to the query, rather than loading comments in a separate query. However, doing this without writing a full-blown SQL parser is inherently flawed. Since we don't want to write an SQL parser, we are removing this functionality. From now on, you must explicitly tell Active Record when you are referencing a table from a string:



    Post.includes(:comments).where("comments.title = 'foo'").references(:comments)



If you don't rely on implicit join references you can disable the feature entirely by setting `config.active_record.disable_implicit_join_references = true`. (called from score_for_scoring_models at /home/travis/build/Liaison-Intl/WebAdMIT/app/models/scoring/scorer.rb:50)

DEPRECATION WARNING: It looks like you are eager loading table(s) (one of: designations, programs, user_identity_programs) that are referenced in a string SQL snippet. For example:



    Post.includes(:comments).where("comments.title = 'foo'")



Currently, Active Record recognizes the table in the string, and knows to JOIN the comments table to the query, rather than loading comments in a separate query. However, doing this without writing a full-blown SQL parser is inherently flawed. Since we don't want to write an SQL parser, we are removing this functionality. From now on, you must explicitly tell Active Record when you are referencing a table from a string:



    Post.includes(:comments).where("comments.title = 'foo'").references(:comments)



If you don't rely on implicit join references you can disable the feature entirely by setting `config.active_record.disable_implicit_join_references = true`. (called from designations_received? at /home/travis/build/Liaison-Intl/WebAdMIT/app/models/applicant.rb:941)

[32m.[0m[32m.[0m[32m.[0m[32m.[0m[32m.[0mDEPRECATION WARNING: It looks like you are eager loading table(s) (one of: scoring_models, scoring_model_assignments, programs) that are referenced in a string SQL snippet. For example:



    Post.includes(:comments).where("comments.title = 'foo'")



Currently, Active Record recognizes the table in the string, and knows to JOIN the comments table to the query, rather than loading comments in a separate query. However, doing this without writing a full-blown SQL parser is inherently flawed. Since we don't want to write an SQL parser, we are removing this functionality. From now on, you must explicitly tell Active Record when you are referencing a table from a string:



    Post.includes(:comments).where("comments.title = 'foo'").references(:comments)



If you don't rely on implicit join references you can disable the feature entirely by setting `config.active_record.disable_implicit_join_references = true`. (called from score_for_scoring_models at /home/travis/build/Liaison-Intl/WebAdMIT/app/models/scoring/scorer.rb:50)

DEPRECATION WARNING: Passing options to #find is deprecated. Please build a scope and then call #find on it. (called from perform at /home/travis/build/Liaison-Intl/WebAdMIT/app/models/program_gpa_template.rb:75)

DEPRECATION WARNING: Passing options to #find is deprecated. Please build a scope and then call #find on it. (called from perform at /home/travis/build/Liaison-Intl/WebAdMIT/app/models/program_gpa_template.rb:75)

DEPRECATION WARNING: Passing options to #find is deprecated. Please build a scope and then call #find on it. (called from perform at /home/travis/build/Liaison-Intl/WebAdMIT/app/models/program_gpa_template.rb:75)

DEPRECATION WARNING: It looks like you are eager loading table(s) (one of: courses, academic_session, academic_years, academic_years_gpa_templates, academic_sessions, terms) that are referenced in a string SQL snippet. For example:



    Post.includes(:comments).where("comments.title = 'foo'")



Currently, Active Record recognizes the table in the string, and knows to JOIN the comments table to the query, rather than loading comments in a separate query. However, doing this without writing a full-blown SQL parser is inherently flawed. Since we don't want to write an SQL parser, we are removing this functionality. From now on, you must explicitly tell Active Record when you are referencing a table from a string:



    Post.includes(:comments).where("comments.title = 'foo'").references(:comments)



If you don't rely on implicit join references you can disable the feature entirely by setting `config.active_record.disable_implicit_join_references = true`. (called from by_valid_grade at /home/travis/build/Liaison-Intl/WebAdMIT/app/models/gpa_service_course_filter.rb:41)

DEPRECATION WARNING: It looks like you are eager loading table(s) (one of: scoring_models, scoring_model_assignments, programs) that are referenced in a string SQL snippet. For example:



    Post.includes(:comments).where("comments.title = 'foo'")



Currently, Active Record recognizes the table in the string, and knows to JOIN the comments table to the query, rather than loading comments in a separate query. However, doing this without writing a full-blown SQL parser is inherently flawed. Since we don't want to write an SQL parser, we are removing this functionality. From now on, you must explicitly tell Active Record when you are referencing a table from a string:



    Post.includes(:comments).where("comments.title = 'foo'").references(:comments)



If you don't rely on implicit join references you can disable the feature entirely by setting `config.active_record.disable_implicit_join_references = true`. (called from score_for_scoring_models at /home/travis/build/Liaison-Intl/WebAdMIT/app/models/scoring/scorer.rb:50)

DEPRECATION WARNING: It looks like you are eager loading table(s) (one of: designations, programs, user_identity_programs) that are referenced in a string SQL snippet. For example:



    Post.includes(:comments).where("comments.title = 'foo'")



Currently, Active Record recognizes the table in the string, and knows to JOIN the comments table to the query, rather than loading comments in a separate query. However, doing this without writing a full-blown SQL parser is inherently flawed. Since we don't want to write an SQL parser, we are removing this functionality. From now on, you must explicitly tell Active Record when you are referencing a table from a string:



    Post.includes(:comments).where("comments.title = 'foo'").references(:comments)



If you don't rely on implicit join references you can disable the feature entirely by setting `config.active_record.disable_implicit_join_references = true`. (called from designations_received? at /home/travis/build/Liaison-Intl/WebAdMIT/app/models/applicant.rb:941)

DEPRECATION WARNING: It looks like you are eager loading table(s) (one of: courses, academic_session, academic_years, academic_years_gpa_templates, academic_sessions, terms) that are referenced in a string SQL snippet. For example:



    Post.includes(:comments).where("comments.title = 'foo'")



Currently, Active Record recognizes the table in the string, and knows to JOIN the comments table to the query, rather than loading comments in a separate query. However, doing this without writing a full-blown SQL parser is inherently flawed. Since we don't want to write an SQL parser, we are removing this functionality. From now on, you must explicitly tell Active Record when you are referencing a table from a string:



    Post.includes(:comments).where("comments.title = 'foo'").references(:comments)



If you don't rely on implicit join references you can disable the feature entirely by setting `config.active_record.disable_implicit_join_references = true`. (called from by_valid_grade at /home/travis/build/Liaison-Intl/WebAdMIT/app/models/gpa_service_course_filter.rb:41)

DEPRECATION WARNING: It looks like you are eager loading table(s) (one of: courses, local_gpas_courses, academic_session, academic_years, academic_years_gpa_templates) that are referenced in a string SQL snippet. For example:



    Post.includes(:comments).where("comments.title = 'foo'")



Currently, Active Record recognizes the table in the string, and knows to JOIN the comments table to the query, rather than loading comments in a separate query. However, doing this without writing a full-blown SQL parser is inherently flawed. Since we don't want to write an SQL parser, we are removing this functionality. From now on, you must explicitly tell Active Record when you are referencing a table from a string:



    Post.includes(:comments).where("comments.title = 'foo'").references(:comments)



If you don't rely on implicit join references you can disable the feature entirely by setting `config.active_record.disable_implicit_join_references = true`. (called from by_valid_grade at /home/travis/build/Liaison-Intl/WebAdMIT/app/models/gpa_service_course_filter.rb:41)

DEPRECATION WARNING: It looks like you are eager loading table(s) (one of: scoring_models, scoring_model_assignments, programs) that are referenced in a string SQL snippet. For example:



    Post.includes(:comments).where("comments.title = 'foo'")



Currently, Active Record recognizes the table in the string, and knows to JOIN the comments table to the query, rather than loading comments in a separate query. However, doing this without writing a full-blown SQL parser is inherently flawed. Since we don't want to write an SQL parser, we are removing this functionality. From now on, you must explicitly tell Active Record when you are referencing a table from a string:



    Post.includes(:comments).where("comments.title = 'foo'").references(:comments)



If you don't rely on implicit join references you can disable the feature entirely by setting `config.active_record.disable_implicit_join_references = true`. (called from score_for_scoring_models at /home/travis/build/Liaison-Intl/WebAdMIT/app/models/scoring/scorer.rb:50)

[32m.[0mDEPRECATION WARNING: It looks like you are eager loading table(s) (one of: scoring_models, scoring_model_assignments, programs) that are referenced in a string SQL snippet. For example:



    Post.includes(:comments).where("comments.title = 'foo'")



Currently, Active Record recognizes the table in the string, and knows to JOIN the comments table to the query, rather than loading comments in a separate query. However, doing this without writing a full-blown SQL parser is inherently flawed. Since we don't want to write an SQL parser, we are removing this functionality. From now on, you must explicitly tell Active Record when you are referencing a table from a string:



    Post.includes(:comments).where("comments.title = 'foo'").references(:comments)



If you don't rely on implicit join references you can disable the feature entirely by setting `config.active_record.disable_implicit_join_references = true`. (called from score_for_scoring_models at /home/travis/build/Liaison-Intl/WebAdMIT/app/models/scoring/scorer.rb:50)

DEPRECATION WARNING: It looks like you are eager loading table(s) (one of: designations, programs, user_identity_programs) that are referenced in a string SQL snippet. For example:



    Post.includes(:comments).where("comments.title = 'foo'")



Currently, Active Record recognizes the table in the string, and knows to JOIN the comments table to the query, rather than loading comments in a separate query. However, doing this without writing a full-blown SQL parser is inherently flawed. Since we don't want to write an SQL parser, we are removing this functionality. From now on, you must explicitly tell Active Record when you are referencing a table from a string:



    Post.includes(:comments).where("comments.title = 'foo'").references(:comments)



If you don't rely on implicit join references you can disable the feature entirely by setting `config.active_record.disable_implicit_join_references = true`. (called from designations_received? at /home/travis/build/Liaison-Intl/WebAdMIT/app/models/applicant.rb:941)

[32m.[0mDEPRECATION WARNING: It looks like you are eager loading table(s) (one of: scoring_models, scoring_model_assignments, programs) that are referenced in a string SQL snippet. For example:



    Post.includes(:comments).where("comments.title = 'foo'")



Currently, Active Record recognizes the table in the string, and knows to JOIN the comments table to the query, rather than loading comments in a separate query. However, doing this without writing a full-blown SQL parser is inherently flawed. Since we don't want to write an SQL parser, we are removing this functionality. From now on, you must explicitly tell Active Record when you are referencing a table from a string:



    Post.includes(:comments).where("comments.title = 'foo'").references(:comments)



If you don't rely on implicit join references you can disable the feature entirely by setting `config.active_record.disable_implicit_join_references = true`. (called from score_for_scoring_models at /home/travis/build/Liaison-Intl/WebAdMIT/app/models/scoring/scorer.rb:50)

DEPRECATION WARNING: It looks like you are eager loading table(s) (one of: designations, programs, user_identity_programs) that are referenced in a string SQL snippet. For example:



    Post.includes(:comments).where("comments.title = 'foo'")



Currently, Active Record recognizes the table in the string, and knows to JOIN the comments table to the query, rather than loading comments in a separate query. However, doing this without writing a full-blown SQL parser is inherently flawed. Since we don't want to write an SQL parser, we are removing this functionality. From now on, you must explicitly tell Active Record when you are referencing a table from a string:



    Post.includes(:comments).where("comments.title = 'foo'").references(:comments)



If you don't rely on implicit join references you can disable the feature entirely by setting `config.active_record.disable_implicit_join_references = true`. (called from designations_received? at /home/travis/build/Liaison-Intl/WebAdMIT/app/models/applicant.rb:941)

[32m.[0mDEPRECATION WARNING: It looks like you are eager loading table(s) (one of: scoring_models, scoring_model_assignments, programs) that are referenced in a string SQL snippet. For example:



    Post.includes(:comments).where("comments.title = 'foo'")



Currently, Active Record recognizes the table in the string, and knows to JOIN the comments table to the query, rather than loading comments in a separate query. However, doing this without writing a full-blown SQL parser is inherently flawed. Since we don't want to write an SQL parser, we are removing this functionality. From now on, you must explicitly tell Active Record when you are referencing a table from a string:



    Post.includes(:comments).where("comments.title = 'foo'").references(:comments)



If you don't rely on implicit join references you can disable the feature entirely by setting `config.active_record.disable_implicit_join_references = true`. (called from score_for_scoring_models at /home/travis/build/Liaison-Intl/WebAdMIT/app/models/scoring/scorer.rb:50)

DEPRECATION WARNING: It looks like you are eager loading table(s) (one of: designations, programs, user_identity_programs) that are referenced in a string SQL snippet. For example:



    Post.includes(:comments).where("comments.title = 'foo'")



Currently, Active Record recognizes the table in the string, and knows to JOIN the comments table to the query, rather than loading comments in a separate query. However, doing this without writing a full-blown SQL parser is inherently flawed. Since we don't want to write an SQL parser, we are removing this functionality. From now on, you must explicitly tell Active Record when you are referencing a table from a string:



    Post.includes(:comments).where("comments.title = 'foo'").references(:comments)



If you don't rely on implicit join references you can disable the feature entirely by setting `config.active_record.disable_implicit_join_references = true`. (called from designations_received? at /home/travis/build/Liaison-Intl/WebAdMIT/app/models/applicant.rb:941)

[32m.[0mDEPRECATION WARNING: It looks like you are eager loading table(s) (one of: scoring_models, scoring_model_assignments, programs) that are referenced in a string SQL snippet. For example:



    Post.includes(:comments).where("comments.title = 'foo'")



Currently, Active Record recognizes the table in the string, and knows to JOIN the comments table to the query, rather than loading comments in a separate query. However, doing this without writing a full-blown SQL parser is inherently flawed. Since we don't want to write an SQL parser, we are removing this functionality. From now on, you must explicitly tell Active Record when you are referencing a table from a string:



    Post.includes(:comments).where("comments.title = 'foo'").references(:comments)



If you don't rely on implicit join references you can disable the feature entirely by setting `config.active_record.disable_implicit_join_references = true`. (called from score_for_scoring_models at /home/travis/build/Liaison-Intl/WebAdMIT/app/models/scoring/scorer.rb:50)

DEPRECATION WARNING: It looks like you are eager loading table(s) (one of: designations, programs, user_identity_programs) that are referenced in a string SQL snippet. For example:



    Post.includes(:comments).where("comments.title = 'foo'")



Currently, Active Record recognizes the table in the string, and knows to JOIN the comments table to the query, rather than loading comments in a separate query. However, doing this without writing a full-blown SQL parser is inherently flawed. Since we don't want to write an SQL parser, we are removing this functionality. From now on, you must explicitly tell Active Record when you are referencing a table from a string:



    Post.includes(:comments).where("comments.title = 'foo'").references(:comments)



If you don't rely on implicit join references you can disable the feature entirely by setting `config.active_record.disable_implicit_join_references = true`. (called from designations_received? at /home/travis/build/Liaison-Intl/WebAdMIT/app/models/applicant.rb:941)

[32m.[0mDEPRECATION WARNING: It looks like you are eager loading table(s) (one of: scoring_models, scoring_model_assignments, programs) that are referenced in a string SQL snippet. For example:



    Post.includes(:comments).where("comments.title = 'foo'")



Currently, Active Record recognizes the table in the string, and knows to JOIN the comments table to the query, rather than loading comments in a separate query. However, doing this without writing a full-blown SQL parser is inherently flawed. Since we don't want to write an SQL parser, we are removing this functionality. From now on, you must explicitly tell Active Record when you are referencing a table from a string:



    Post.includes(:comments).where("comments.title = 'foo'").references(:comments)



If you don't rely on implicit join references you can disable the feature entirely by setting `config.active_record.disable_implicit_join_references = true`. (called from score_for_scoring_models at /home/travis/build/Liaison-Intl/WebAdMIT/app/models/scoring/scorer.rb:50)

DEPRECATION WARNING: It looks like you are eager loading table(s) (one of: designations, programs, user_identity_programs) that are referenced in a string SQL snippet. For example:



    Post.includes(:comments).where("comments.title = 'foo'")



Currently, Active Record recognizes the table in the string, and knows to JOIN the comments table to the query, rather than loading comments in a separate query. However, doing this without writing a full-blown SQL parser is inherently flawed. Since we don't want to write an SQL parser, we are removing this functionality. From now on, you must explicitly tell Active Record when you are referencing a table from a string:



    Post.includes(:comments).where("comments.title = 'foo'").references(:comments)



If you don't rely on implicit join references you can disable the feature entirely by setting `config.active_record.disable_implicit_join_references = true`. (called from designations_received? at /home/travis/build/Liaison-Intl/WebAdMIT/app/models/applicant.rb:941)

[32m.[0mDEPRECATION WARNING: It looks like you are eager loading table(s) (one of: scoring_models, scoring_model_assignments, programs) that are referenced in a string SQL snippet. For example:



    Post.includes(:comments).where("comments.title = 'foo'")



Currently, Active Record recognizes the table in the string, and knows to JOIN the comments table to the query, rather than loading comments in a separate query. However, doing this without writing a full-blown SQL parser is inherently flawed. Since we don't want to write an SQL parser, we are removing this functionality. From now on, you must explicitly tell Active Record when you are referencing a table from a string:



    Post.includes(:comments).where("comments.title = 'foo'").references(:comments)



If you don't rely on implicit join references you can disable the feature entirely by setting `config.active_record.disable_implicit_join_references = true`. (called from score_for_scoring_models at /home/travis/build/Liaison-Intl/WebAdMIT/app/models/scoring/scorer.rb:50)

DEPRECATION WARNING: It looks like you are eager loading table(s) (one of: designations, programs, user_identity_programs) that are referenced in a string SQL snippet. For example:



    Post.includes(:comments).where("comments.title = 'foo'")



Currently, Active Record recognizes the table in the string, and knows to JOIN the comments table to the query, rather than loading comments in a separate query. However, doing this without writing a full-blown SQL parser is inherently flawed. Since we don't want to write an SQL parser, we are removing this functionality. From now on, you must explicitly tell Active Record when you are referencing a table from a string:



    Post.includes(:comments).where("comments.title = 'foo'").references(:comments)



If you don't rely on implicit join references you can disable the feature entirely by setting `config.active_record.disable_implicit_join_references = true`. (called from designations_received? at /home/travis/build/Liaison-Intl/WebAdMIT/app/models/applicant.rb:941)

[32m.[0mDEPRECATION WARNING: It looks like you are eager loading table(s) (one of: scoring_models, scoring_model_assignments, programs) that are referenced in a string SQL snippet. For example:



    Post.includes(:comments).where("comments.title = 'foo'")



Currently, Active Record recognizes the table in the string, and knows to JOIN the comments table to the query, rather than loading comments in a separate query. However, doing this without writing a full-blown SQL parser is inherently flawed. Since we don't want to write an SQL parser, we are removing this functionality. From now on, you must explicitly tell Active Record when you are referencing a table from a string:



    Post.includes(:comments).where("comments.title = 'foo'").references(:comments)



If you don't rely on implicit join references you can disable the feature entirely by setting `config.active_record.disable_implicit_join_references = true`. (called from score_for_scoring_models at /home/travis/build/Liaison-Intl/WebAdMIT/app/models/scoring/scorer.rb:50)

DEPRECATION WARNING: It looks like you are eager loading table(s) (one of: designations, programs, user_identity_programs) that are referenced in a string SQL snippet. For example:



    Post.includes(:comments).where("comments.title = 'foo'")



Currently, Active Record recognizes the table in the string, and knows to JOIN the comments table to the query, rather than loading comments in a separate query. However, doing this without writing a full-blown SQL parser is inherently flawed. Since we don't want to write an SQL parser, we are removing this functionality. From now on, you must explicitly tell Active Record when you are referencing a table from a string:



    Post.includes(:comments).where("comments.title = 'foo'").references(:comments)



If you don't rely on implicit join references you can disable the feature entirely by setting `config.active_record.disable_implicit_join_references = true`. (called from designations_received? at /home/travis/build/Liaison-Intl/WebAdMIT/app/models/applicant.rb:941)

[32m.[0mDEPRECATION WARNING: It looks like you are eager loading table(s) (one of: scoring_models, scoring_model_assignments, programs) that are referenced in a string SQL snippet. For example:



    Post.includes(:comments).where("comments.title = 'foo'")



Currently, Active Record recognizes the table in the string, and knows to JOIN the comments table to the query, rather than loading comments in a separate query. However, doing this without writing a full-blown SQL parser is inherently flawed. Since we don't want to write an SQL parser, we are removing this functionality. From now on, you must explicitly tell Active Record when you are referencing a table from a string:



    Post.includes(:comments).where("comments.title = 'foo'").references(:comments)



If you don't rely on implicit join references you can disable the feature entirely by setting `config.active_record.disable_implicit_join_references = true`. (called from score_for_scoring_models at /home/travis/build/Liaison-Intl/WebAdMIT/app/models/scoring/scorer.rb:50)

DEPRECATION WARNING: It looks like you are eager loading table(s) (one of: designations, programs, user_identity_programs) that are referenced in a string SQL snippet. For example:



    Post.includes(:comments).where("comments.title = 'foo'")



Currently, Active Record recognizes the table in the string, and knows to JOIN the comments table to the query, rather than loading comments in a separate query. However, doing this without writing a full-blown SQL parser is inherently flawed. Since we don't want to write an SQL parser, we are removing this functionality. From now on, you must explicitly tell Active Record when you are referencing a table from a string:



    Post.includes(:comments).where("comments.title = 'foo'").references(:comments)



If you don't rely on implicit join references you can disable the feature entirely by setting `config.active_record.disable_implicit_join_references = true`. (called from designations_received? at /home/travis/build/Liaison-Intl/WebAdMIT/app/models/applicant.rb:941)

[32m.[0mDEPRECATION WARNING: It looks like you are eager loading table(s) (one of: scoring_models, scoring_model_assignments, programs) that are referenced in a string SQL snippet. For example:



    Post.includes(:comments).where("comments.title = 'foo'")



Currently, Active Record recognizes the table in the string, and knows to JOIN the comments table to the query, rather than loading comments in a separate query. However, doing this without writing a full-blown SQL parser is inherently flawed. Since we don't want to write an SQL parser, we are removing this functionality. From now on, you must explicitly tell Active Record when you are referencing a table from a string:



    Post.includes(:comments).where("comments.title = 'foo'").references(:comments)



If you don't rely on implicit join references you can disable the feature entirely by setting `config.active_record.disable_implicit_join_references = true`. (called from score_for_scoring_models at /home/travis/build/Liaison-Intl/WebAdMIT/app/models/scoring/scorer.rb:50)

DEPRECATION WARNING: It looks like you are eager loading table(s) (one of: designations, programs, user_identity_programs) that are referenced in a string SQL snippet. For example:



    Post.includes(:comments).where("comments.title = 'foo'")



Currently, Active Record recognizes the table in the string, and knows to JOIN the comments table to the query, rather than loading comments in a separate query. However, doing this without writing a full-blown SQL parser is inherently flawed. Since we don't want to write an SQL parser, we are removing this functionality. From now on, you must explicitly tell Active Record when you are referencing a table from a string:



    Post.includes(:comments).where("comments.title = 'foo'").references(:comments)



If you don't rely on implicit join references you can disable the feature entirely by setting `config.active_record.disable_implicit_join_references = true`. (called from designations_received? at /home/travis/build/Liaison-Intl/WebAdMIT/app/models/applicant.rb:941)

[32m.[0mDEPRECATION WARNING: It looks like you are eager loading table(s) (one of: scoring_models, scoring_model_assignments, programs) that are referenced in a string SQL snippet. For example:



    Post.includes(:comments).where("comments.title = 'foo'")



Currently, Active Record recognizes the table in the string, and knows to JOIN the comments table to the query, rather than loading comments in a separate query. However, doing this without writing a full-blown SQL parser is inherently flawed. Since we don't want to write an SQL parser, we are removing this functionality. From now on, you must explicitly tell Active Record when you are referencing a table from a string:



    Post.includes(:comments).where("comments.title = 'foo'").references(:comments)



If you don't rely on implicit join references you can disable the feature entirely by setting `config.active_record.disable_implicit_join_references = true`. (called from score_for_scoring_models at /home/travis/build/Liaison-Intl/WebAdMIT/app/models/scoring/scorer.rb:50)

DEPRECATION WARNING: It looks like you are eager loading table(s) (one of: designations, programs, user_identity_programs) that are referenced in a string SQL snippet. For example:



    Post.includes(:comments).where("comments.title = 'foo'")



Currently, Active Record recognizes the table in the string, and knows to JOIN the comments table to the query, rather than loading comments in a separate query. However, doing this without writing a full-blown SQL parser is inherently flawed. Since we don't want to write an SQL parser, we are removing this functionality. From now on, you must explicitly tell Active Record when you are referencing a table from a string:



    Post.includes(:comments).where("comments.title = 'foo'").references(:comments)



If you don't rely on implicit join references you can disable the feature entirely by setting `config.active_record.disable_implicit_join_references = true`. (called from designations_received? at /home/travis/build/Liaison-Intl/WebAdMIT/app/models/applicant.rb:941)

[32m.[0mDEPRECATION WARNING: It looks like you are eager loading table(s) (one of: scoring_models, scoring_model_assignments, programs) that are referenced in a string SQL snippet. For example:



    Post.includes(:comments).where("comments.title = 'foo'")



Currently, Active Record recognizes the table in the string, and knows to JOIN the comments table to the query, rather than loading comments in a separate query. However, doing this without writing a full-blown SQL parser is inherently flawed. Since we don't want to write an SQL parser, we are removing this functionality. From now on, you must explicitly tell Active Record when you are referencing a table from a string:



    Post.includes(:comments).where("comments.title = 'foo'").references(:comments)



If you don't rely on implicit join references you can disable the feature entirely by setting `config.active_record.disable_implicit_join_references = true`. (called from score_for_scoring_models at /home/travis/build/Liaison-Intl/WebAdMIT/app/models/scoring/scorer.rb:50)

DEPRECATION WARNING: It looks like you are eager loading table(s) (one of: designations, programs, user_identity_programs) that are referenced in a string SQL snippet. For example:



    Post.includes(:comments).where("comments.title = 'foo'")



Currently, Active Record recognizes the table in the string, and knows to JOIN the comments table to the query, rather than loading comments in a separate query. However, doing this without writing a full-blown SQL parser is inherently flawed. Since we don't want to write an SQL parser, we are removing this functionality. From now on, you must explicitly tell Active Record when you are referencing a table from a string:



    Post.includes(:comments).where("comments.title = 'foo'").references(:comments)



If you don't rely on implicit join references you can disable the feature entirely by setting `config.active_record.disable_implicit_join_references = true`. (called from designations_received? at /home/travis/build/Liaison-Intl/WebAdMIT/app/models/applicant.rb:941)

[32m.[0mDEPRECATION WARNING: It looks like you are eager loading table(s) (one of: scoring_models, scoring_model_assignments, programs) that are referenced in a string SQL snippet. For example:



    Post.includes(:comments).where("comments.title = 'foo'")



Currently, Active Record recognizes the table in the string, and knows to JOIN the comments table to the query, rather than loading comments in a separate query. However, doing this without writing a full-blown SQL parser is inherently flawed. Since we don't want to write an SQL parser, we are removing this functionality. From now on, you must explicitly tell Active Record when you are referencing a table from a string:



    Post.includes(:comments).where("comments.title = 'foo'").references(:comments)



If you don't rely on implicit join references you can disable the feature entirely by setting `config.active_record.disable_implicit_join_references = true`. (called from score_for_scoring_models at /home/travis/build/Liaison-Intl/WebAdMIT/app/models/scoring/scorer.rb:50)

DEPRECATION WARNING: It looks like you are eager loading table(s) (one of: designations, programs, user_identity_programs) that are referenced in a string SQL snippet. For example:



    Post.includes(:comments).where("comments.title = 'foo'")



Currently, Active Record recognizes the table in the string, and knows to JOIN the comments table to the query, rather than loading comments in a separate query. However, doing this without writing a full-blown SQL parser is inherently flawed. Since we don't want to write an SQL parser, we are removing this functionality. From now on, you must explicitly tell Active Record when you are referencing a table from a string:



    Post.includes(:comments).where("comments.title = 'foo'").references(:comments)



If you don't rely on implicit join references you can disable the feature entirely by setting `config.active_record.disable_implicit_join_references = true`. (called from designations_received? at /home/travis/build/Liaison-Intl/WebAdMIT/app/models/applicant.rb:941)

[32m.[0mDEPRECATION WARNING: It looks like you are eager loading table(s) (one of: scoring_models, scoring_model_assignments, programs) that are referenced in a string SQL snippet. For example:



    Post.includes(:comments).where("comments.title = 'foo'")



Currently, Active Record recognizes the table in the string, and knows to JOIN the comments table to the query, rather than loading comments in a separate query. However, doing this without writing a full-blown SQL parser is inherently flawed. Since we don't want to write an SQL parser, we are removing this functionality. From now on, you must explicitly tell Active Record when you are referencing a table from a string:



    Post.includes(:comments).where("comments.title = 'foo'").references(:comments)



If you don't rely on implicit join references you can disable the feature entirely by setting `config.active_record.disable_implicit_join_references = true`. (called from score_for_scoring_models at /home/travis/build/Liaison-Intl/WebAdMIT/app/models/scoring/scorer.rb:50)

DEPRECATION WARNING: It looks like you are eager loading table(s) (one of: designations, programs, user_identity_programs) that are referenced in a string SQL snippet. For example:



    Post.includes(:comments).where("comments.title = 'foo'")



Currently, Active Record recognizes the table in the string, and knows to JOIN the comments table to the query, rather than loading comments in a separate query. However, doing this without writing a full-blown SQL parser is inherently flawed. Since we don't want to write an SQL parser, we are removing this functionality. From now on, you must explicitly tell Active Record when you are referencing a table from a string:



    Post.includes(:comments).where("comments.title = 'foo'").references(:comments)



If you don't rely on implicit join references you can disable the feature entirely by setting `config.active_record.disable_implicit_join_references = true`. (called from designations_received? at /home/travis/build/Liaison-Intl/WebAdMIT/app/models/applicant.rb:941)

[32m.[0mDEPRECATION WARNING: It looks like you are eager loading table(s) (one of: scoring_models, scoring_model_assignments, programs) that are referenced in a string SQL snippet. For example:



    Post.includes(:comments).where("comments.title = 'foo'")



Currently, Active Record recognizes the table in the string, and knows to JOIN the comments table to the query, rather than loading comments in a separate query. However, doing this without writing a full-blown SQL parser is inherently flawed. Since we don't want to write an SQL parser, we are removing this functionality. From now on, you must explicitly tell Active Record when you are referencing a table from a string:



    Post.includes(:comments).where("comments.title = 'foo'").references(:comments)



If you don't rely on implicit join references you can disable the feature entirely by setting `config.active_record.disable_implicit_join_references = true`. (called from score_for_scoring_models at /home/travis/build/Liaison-Intl/WebAdMIT/app/models/scoring/scorer.rb:50)

DEPRECATION WARNING: It looks like you are eager loading table(s) (one of: designations, programs, user_identity_programs) that are referenced in a string SQL snippet. For example:



    Post.includes(:comments).where("comments.title = 'foo'")



Currently, Active Record recognizes the table in the string, and knows to JOIN the comments table to the query, rather than loading comments in a separate query. However, doing this without writing a full-blown SQL parser is inherently flawed. Since we don't want to write an SQL parser, we are removing this functionality. From now on, you must explicitly tell Active Record when you are referencing a table from a string:



    Post.includes(:comments).where("comments.title = 'foo'").references(:comments)



If you don't rely on implicit join references you can disable the feature entirely by setting `config.active_record.disable_implicit_join_references = true`. (called from designations_received? at /home/travis/build/Liaison-Intl/WebAdMIT/app/models/applicant.rb:941)

[32m.[0mDEPRECATION WARNING: It looks like you are eager loading table(s) (one of: scoring_models, scoring_model_assignments, programs) that are referenced in a string SQL snippet. For example:



    Post.includes(:comments).where("comments.title = 'foo'")



Currently, Active Record recognizes the table in the string, and knows to JOIN the comments table to the query, rather than loading comments in a separate query. However, doing this without writing a full-blown SQL parser is inherently flawed. Since we don't want to write an SQL parser, we are removing this functionality. From now on, you must explicitly tell Active Record when you are referencing a table from a string:



    Post.includes(:comments).where("comments.title = 'foo'").references(:comments)



If you don't rely on implicit join references you can disable the feature entirely by setting `config.active_record.disable_implicit_join_references = true`. (called from score_for_scoring_models at /home/travis/build/Liaison-Intl/WebAdMIT/app/models/scoring/scorer.rb:50)

DEPRECATION WARNING: It looks like you are eager loading table(s) (one of: designations, programs, user_identity_programs) that are referenced in a string SQL snippet. For example:



    Post.includes(:comments).where("comments.title = 'foo'")



Currently, Active Record recognizes the table in the string, and knows to JOIN the comments table to the query, rather than loading comments in a separate query. However, doing this without writing a full-blown SQL parser is inherently flawed. Since we don't want to write an SQL parser, we are removing this functionality. From now on, you must explicitly tell Active Record when you are referencing a table from a string:



    Post.includes(:comments).where("comments.title = 'foo'").references(:comments)



If you don't rely on implicit join references you can disable the feature entirely by setting `config.active_record.disable_implicit_join_references = true`. (called from designations_received? at /home/travis/build/Liaison-Intl/WebAdMIT/app/models/applicant.rb:941)

[32m.[0mDEPRECATION WARNING: It looks like you are eager loading table(s) (one of: scoring_models, scoring_model_assignments, programs) that are referenced in a string SQL snippet. For example:



    Post.includes(:comments).where("comments.title = 'foo'")



Currently, Active Record recognizes the table in the string, and knows to JOIN the comments table to the query, rather than loading comments in a separate query. However, doing this without writing a full-blown SQL parser is inherently flawed. Since we don't want to write an SQL parser, we are removing this functionality. From now on, you must explicitly tell Active Record when you are referencing a table from a string:



    Post.includes(:comments).where("comments.title = 'foo'").references(:comments)



If you don't rely on implicit join references you can disable the feature entirely by setting `config.active_record.disable_implicit_join_references = true`. (called from score_for_scoring_models at /home/travis/build/Liaison-Intl/WebAdMIT/app/models/scoring/scorer.rb:50)

DEPRECATION WARNING: It looks like you are eager loading table(s) (one of: designations, programs, user_identity_programs) that are referenced in a string SQL snippet. For example:



    Post.includes(:comments).where("comments.title = 'foo'")



Currently, Active Record recognizes the table in the string, and knows to JOIN the comments table to the query, rather than loading comments in a separate query. However, doing this without writing a full-blown SQL parser is inherently flawed. Since we don't want to write an SQL parser, we are removing this functionality. From now on, you must explicitly tell Active Record when you are referencing a table from a string:



    Post.includes(:comments).where("comments.title = 'foo'").references(:comments)



If you don't rely on implicit join references you can disable the feature entirely by setting `config.active_record.disable_implicit_join_references = true`. (called from designations_received? at /home/travis/build/Liaison-Intl/WebAdMIT/app/models/applicant.rb:941)

[32m.[0mDEPRECATION WARNING: It looks like you are eager loading table(s) (one of: scoring_models, scoring_model_assignments, programs) that are referenced in a string SQL snippet. For example:



    Post.includes(:comments).where("comments.title = 'foo'")



Currently, Active Record recognizes the table in the string, and knows to JOIN the comments table to the query, rather than loading comments in a separate query. However, doing this without writing a full-blown SQL parser is inherently flawed. Since we don't want to write an SQL parser, we are removing this functionality. From now on, you must explicitly tell Active Record when you are referencing a table from a string:



    Post.includes(:comments).where("comments.title = 'foo'").references(:comments)



If you don't rely on implicit join references you can disable the feature entirely by setting `config.active_record.disable_implicit_join_references = true`. (called from score_for_scoring_models at /home/travis/build/Liaison-Intl/WebAdMIT/app/models/scoring/scorer.rb:50)

DEPRECATION WARNING: It looks like you are eager loading table(s) (one of: designations, programs, user_identity_programs) that are referenced in a string SQL snippet. For example:



    Post.includes(:comments).where("comments.title = 'foo'")



Currently, Active Record recognizes the table in the string, and knows to JOIN the comments table to the query, rather than loading comments in a separate query. However, doing this without writing a full-blown SQL parser is inherently flawed. Since we don't want to write an SQL parser, we are removing this functionality. From now on, you must explicitly tell Active Record when you are referencing a table from a string:



    Post.includes(:comments).where("comments.title = 'foo'").references(:comments)



If you don't rely on implicit join references you can disable the feature entirely by setting `config.active_record.disable_implicit_join_references = true`. (called from designations_received? at /home/travis/build/Liaison-Intl/WebAdMIT/app/models/applicant.rb:941)

[32m.[0mDEPRECATION WARNING: It looks like you are eager loading table(s) (one of: scoring_models, scoring_model_assignments, programs) that are referenced in a string SQL snippet. For example:



    Post.includes(:comments).where("comments.title = 'foo'")



Currently, Active Record recognizes the table in the string, and knows to JOIN the comments table to the query, rather than loading comments in a separate query. However, doing this without writing a full-blown SQL parser is inherently flawed. Since we don't want to write an SQL parser, we are removing this functionality. From now on, you must explicitly tell Active Record when you are referencing a table from a string:



    Post.includes(:comments).where("comments.title = 'foo'").references(:comments)



If you don't rely on implicit join references you can disable the feature entirely by setting `config.active_record.disable_implicit_join_references = true`. (called from score_for_scoring_models at /home/travis/build/Liaison-Intl/WebAdMIT/app/models/scoring/scorer.rb:50)

DEPRECATION WARNING: It looks like you are eager loading table(s) (one of: designations, programs, user_identity_programs) that are referenced in a string SQL snippet. For example:



    Post.includes(:comments).where("comments.title = 'foo'")



Currently, Active Record recognizes the table in the string, and knows to JOIN the comments table to the query, rather than loading comments in a separate query. However, doing this without writing a full-blown SQL parser is inherently flawed. Since we don't want to write an SQL parser, we are removing this functionality. From now on, you must explicitly tell Active Record when you are referencing a table from a string:



    Post.includes(:comments).where("comments.title = 'foo'").references(:comments)



If you don't rely on implicit join references you can disable the feature entirely by setting `config.active_record.disable_implicit_join_references = true`. (called from designations_received? at /home/travis/build/Liaison-Intl/WebAdMIT/app/models/applicant.rb:941)

[32m.[0mDEPRECATION WARNING: It looks like you are eager loading table(s) (one of: scoring_models, scoring_model_assignments, programs) that are referenced in a string SQL snippet. For example:



    Post.includes(:comments).where("comments.title = 'foo'")



Currently, Active Record recognizes the table in the string, and knows to JOIN the comments table to the query, rather than loading comments in a separate query. However, doing this without writing a full-blown SQL parser is inherently flawed. Since we don't want to write an SQL parser, we are removing this functionality. From now on, you must explicitly tell Active Record when you are referencing a table from a string:



    Post.includes(:comments).where("comments.title = 'foo'").references(:comments)



If you don't rely on implicit join references you can disable the feature entirely by setting `config.active_record.disable_implicit_join_references = true`. (called from score_for_scoring_models at /home/travis/build/Liaison-Intl/WebAdMIT/app/models/scoring/scorer.rb:50)

DEPRECATION WARNING: It looks like you are eager loading table(s) (one of: designations, programs, user_identity_programs) that are referenced in a string SQL snippet. For example:



    Post.includes(:comments).where("comments.title = 'foo'")



Currently, Active Record recognizes the table in the string, and knows to JOIN the comments table to the query, rather than loading comments in a separate query. However, doing this without writing a full-blown SQL parser is inherently flawed. Since we don't want to write an SQL parser, we are removing this functionality. From now on, you must explicitly tell Active Record when you are referencing a table from a string:



    Post.includes(:comments).where("comments.title = 'foo'").references(:comments)



If you don't rely on implicit join references you can disable the feature entirely by setting `config.active_record.disable_implicit_join_references = true`. (called from designations_received? at /home/travis/build/Liaison-Intl/WebAdMIT/app/models/applicant.rb:941)

[32m.[0mDEPRECATION WARNING: It looks like you are eager loading table(s) (one of: scoring_models, scoring_model_assignments, programs) that are referenced in a string SQL snippet. For example:



    Post.includes(:comments).where("comments.title = 'foo'")



Currently, Active Record recognizes the table in the string, and knows to JOIN the comments table to the query, rather than loading comments in a separate query. However, doing this without writing a full-blown SQL parser is inherently flawed. Since we don't want to write an SQL parser, we are removing this functionality. From now on, you must explicitly tell Active Record when you are referencing a table from a string:



    Post.includes(:comments).where("comments.title = 'foo'").references(:comments)



If you don't rely on implicit join references you can disable the feature entirely by setting `config.active_record.disable_implicit_join_references = true`. (called from score_for_scoring_models at /home/travis/build/Liaison-Intl/WebAdMIT/app/models/scoring/scorer.rb:50)

DEPRECATION WARNING: It looks like you are eager loading table(s) (one of: designations, programs, user_identity_programs) that are referenced in a string SQL snippet. For example:



    Post.includes(:comments).where("comments.title = 'foo'")



Currently, Active Record recognizes the table in the string, and knows to JOIN the comments table to the query, rather than loading comments in a separate query. However, doing this without writing a full-blown SQL parser is inherently flawed. Since we don't want to write an SQL parser, we are removing this functionality. From now on, you must explicitly tell Active Record when you are referencing a table from a string:



    Post.includes(:comments).where("comments.title = 'foo'").references(:comments)



If you don't rely on implicit join references you can disable the feature entirely by setting `config.active_record.disable_implicit_join_references = true`. (called from designations_received? at /home/travis/build/Liaison-Intl/WebAdMIT/app/models/applicant.rb:941)

[32m.[0mDEPRECATION WARNING: It looks like you are eager loading table(s) (one of: scoring_models, scoring_model_assignments, programs) that are referenced in a string SQL snippet. For example:



    Post.includes(:comments).where("comments.title = 'foo'")



Currently, Active Record recognizes the table in the string, and knows to JOIN the comments table to the query, rather than loading comments in a separate query. However, doing this without writing a full-blown SQL parser is inherently flawed. Since we don't want to write an SQL parser, we are removing this functionality. From now on, you must explicitly tell Active Record when you are referencing a table from a string:



    Post.includes(:comments).where("comments.title = 'foo'").references(:comments)



If you don't rely on implicit join references you can disable the feature entirely by setting `config.active_record.disable_implicit_join_references = true`. (called from score_for_scoring_models at /home/travis/build/Liaison-Intl/WebAdMIT/app/models/scoring/scorer.rb:50)

DEPRECATION WARNING: It looks like you are eager loading table(s) (one of: designations, programs, user_identity_programs) that are referenced in a string SQL snippet. For example:



    Post.includes(:comments).where("comments.title = 'foo'")



Currently, Active Record recognizes the table in the string, and knows to JOIN the comments table to the query, rather than loading comments in a separate query. However, doing this without writing a full-blown SQL parser is inherently flawed. Since we don't want to write an SQL parser, we are removing this functionality. From now on, you must explicitly tell Active Record when you are referencing a table from a string:



    Post.includes(:comments).where("comments.title = 'foo'").references(:comments)



If you don't rely on implicit join references you can disable the feature entirely by setting `config.active_record.disable_implicit_join_references = true`. (called from designations_received? at /home/travis/build/Liaison-Intl/WebAdMIT/app/models/applicant.rb:941)

[32m.[0mDEPRECATION WARNING: It looks like you are eager loading table(s) (one of: scoring_models, scoring_model_assignments, programs) that are referenced in a string SQL snippet. For example:



    Post.includes(:comments).where("comments.title = 'foo'")



Currently, Active Record recognizes the table in the string, and knows to JOIN the comments table to the query, rather than loading comments in a separate query. However, doing this without writing a full-blown SQL parser is inherently flawed. Since we don't want to write an SQL parser, we are removing this functionality. From now on, you must explicitly tell Active Record when you are referencing a table from a string:



    Post.includes(:comments).where("comments.title = 'foo'").references(:comments)



If you don't rely on implicit join references you can disable the feature entirely by setting `config.active_record.disable_implicit_join_references = true`. (called from score_for_scoring_models at /home/travis/build/Liaison-Intl/WebAdMIT/app/models/scoring/scorer.rb:50)

DEPRECATION WARNING: It looks like you are eager loading table(s) (one of: designations, programs, user_identity_programs) that are referenced in a string SQL snippet. For example:



    Post.includes(:comments).where("comments.title = 'foo'")



Currently, Active Record recognizes the table in the string, and knows to JOIN the comments table to the query, rather than loading comments in a separate query. However, doing this without writing a full-blown SQL parser is inherently flawed. Since we don't want to write an SQL parser, we are removing this functionality. From now on, you must explicitly tell Active Record when you are referencing a table from a string:



    Post.includes(:comments).where("comments.title = 'foo'").references(:comments)



If you don't rely on implicit join references you can disable the feature entirely by setting `config.active_record.disable_implicit_join_references = true`. (called from designations_received? at /home/travis/build/Liaison-Intl/WebAdMIT/app/models/applicant.rb:941)

[32m.[0mDEPRECATION WARNING: It looks like you are eager loading table(s) (one of: scoring_models, scoring_model_assignments, programs) that are referenced in a string SQL snippet. For example:



    Post.includes(:comments).where("comments.title = 'foo'")



Currently, Active Record recognizes the table in the string, and knows to JOIN the comments table to the query, rather than loading comments in a separate query. However, doing this without writing a full-blown SQL parser is inherently flawed. Since we don't want to write an SQL parser, we are removing this functionality. From now on, you must explicitly tell Active Record when you are referencing a table from a string:



    Post.includes(:comments).where("comments.title = 'foo'").references(:comments)



If you don't rely on implicit join references you can disable the feature entirely by setting `config.active_record.disable_implicit_join_references = true`. (called from score_for_scoring_models at /home/travis/build/Liaison-Intl/WebAdMIT/app/models/scoring/scorer.rb:50)

DEPRECATION WARNING: It looks like you are eager loading table(s) (one of: designations, programs, user_identity_programs) that are referenced in a string SQL snippet. For example:



    Post.includes(:comments).where("comments.title = 'foo'")



Currently, Active Record recognizes the table in the string, and knows to JOIN the comments table to the query, rather than loading comments in a separate query. However, doing this without writing a full-blown SQL parser is inherently flawed. Since we don't want to write an SQL parser, we are removing this functionality. From now on, you must explicitly tell Active Record when you are referencing a table from a string:



    Post.includes(:comments).where("comments.title = 'foo'").references(:comments)



If you don't rely on implicit join references you can disable the feature entirely by setting `config.active_record.disable_implicit_join_references = true`. (called from designations_received? at /home/travis/build/Liaison-Intl/WebAdMIT/app/models/applicant.rb:941)

[32m.[0mDEPRECATION WARNING: It looks like you are eager loading table(s) (one of: scoring_models, scoring_model_assignments, programs) that are referenced in a string SQL snippet. For example:



    Post.includes(:comments).where("comments.title = 'foo'")



Currently, Active Record recognizes the table in the string, and knows to JOIN the comments table to the query, rather than loading comments in a separate query. However, doing this without writing a full-blown SQL parser is inherently flawed. Since we don't want to write an SQL parser, we are removing this functionality. From now on, you must explicitly tell Active Record when you are referencing a table from a string:



    Post.includes(:comments).where("comments.title = 'foo'").references(:comments)



If you don't rely on implicit join references you can disable the feature entirely by setting `config.active_record.disable_implicit_join_references = true`. (called from score_for_scoring_models at /home/travis/build/Liaison-Intl/WebAdMIT/app/models/scoring/scorer.rb:50)

DEPRECATION WARNING: It looks like you are eager loading table(s) (one of: designations, programs, user_identity_programs) that are referenced in a string SQL snippet. For example:



    Post.includes(:comments).where("comments.title = 'foo'")



Currently, Active Record recognizes the table in the string, and knows to JOIN the comments table to the query, rather than loading comments in a separate query. However, doing this without writing a full-blown SQL parser is inherently flawed. Since we don't want to write an SQL parser, we are removing this functionality. From now on, you must explicitly tell Active Record when you are referencing a table from a string:



    Post.includes(:comments).where("comments.title = 'foo'").references(:comments)



If you don't rely on implicit join references you can disable the feature entirely by setting `config.active_record.disable_implicit_join_references = true`. (called from designations_received? at /home/travis/build/Liaison-Intl/WebAdMIT/app/models/applicant.rb:941)

[32m.[0mDEPRECATION WARNING: It looks like you are eager loading table(s) (one of: scoring_models, scoring_model_assignments, programs) that are referenced in a string SQL snippet. For example:



    Post.includes(:comments).where("comments.title = 'foo'")



Currently, Active Record recognizes the table in the string, and knows to JOIN the comments table to the query, rather than loading comments in a separate query. However, doing this without writing a full-blown SQL parser is inherently flawed. Since we don't want to write an SQL parser, we are removing this functionality. From now on, you must explicitly tell Active Record when you are referencing a table from a string:



    Post.includes(:comments).where("comments.title = 'foo'").references(:comments)



If you don't rely on implicit join references you can disable the feature entirely by setting `config.active_record.disable_implicit_join_references = true`. (called from score_for_scoring_models at /home/travis/build/Liaison-Intl/WebAdMIT/app/models/scoring/scorer.rb:50)

DEPRECATION WARNING: It looks like you are eager loading table(s) (one of: designations, programs, user_identity_programs) that are referenced in a string SQL snippet. For example:



    Post.includes(:comments).where("comments.title = 'foo'")



Currently, Active Record recognizes the table in the string, and knows to JOIN the comments table to the query, rather than loading comments in a separate query. However, doing this without writing a full-blown SQL parser is inherently flawed. Since we don't want to write an SQL parser, we are removing this functionality. From now on, you must explicitly tell Active Record when you are referencing a table from a string:



    Post.includes(:comments).where("comments.title = 'foo'").references(:comments)



If you don't rely on implicit join references you can disable the feature entirely by setting `config.active_record.disable_implicit_join_references = true`. (called from designations_received? at /home/travis/build/Liaison-Intl/WebAdMIT/app/models/applicant.rb:941)

[32m.[0m[32m.[0mDEPRECATION WARNING: It looks like you are eager loading table(s) (one of: scoring_models, scoring_model_assignments, programs) that are referenced in a string SQL snippet. For example:



    Post.includes(:comments).where("comments.title = 'foo'")



Currently, Active Record recognizes the table in the string, and knows to JOIN the comments table to the query, rather than loading comments in a separate query. However, doing this without writing a full-blown SQL parser is inherently flawed. Since we don't want to write an SQL parser, we are removing this functionality. From now on, you must explicitly tell Active Record when you are referencing a table from a string:



    Post.includes(:comments).where("comments.title = 'foo'").references(:comments)



If you don't rely on implicit join references you can disable the feature entirely by setting `config.active_record.disable_implicit_join_references = true`. (called from score_for_scoring_models at /home/travis/build/Liaison-Intl/WebAdMIT/app/models/scoring/scorer.rb:50)

DEPRECATION WARNING: It looks like you are eager loading table(s) (one of: scoring_models, scoring_model_assignments, programs) that are referenced in a string SQL snippet. For example:



    Post.includes(:comments).where("comments.title = 'foo'")



Currently, Active Record recognizes the table in the string, and knows to JOIN the comments table to the query, rather than loading comments in a separate query. However, doing this without writing a full-blown SQL parser is inherently flawed. Since we don't want to write an SQL parser, we are removing this functionality. From now on, you must explicitly tell Active Record when you are referencing a table from a string:



    Post.includes(:comments).where("comments.title = 'foo'").references(:comments)



If you don't rely on implicit join references you can disable the feature entirely by setting `config.active_record.disable_implicit_join_references = true`. (called from score_for_scoring_models at /home/travis/build/Liaison-Intl/WebAdMIT/app/models/scoring/scorer.rb:50)

DEPRECATION WARNING: It looks like you are eager loading table(s) (one of: designations, programs, user_identity_programs) that are referenced in a string SQL snippet. For example:



    Post.includes(:comments).where("comments.title = 'foo'")



Currently, Active Record recognizes the table in the string, and knows to JOIN the comments table to the query, rather than loading comments in a separate query. However, doing this without writing a full-blown SQL parser is inherently flawed. Since we don't want to write an SQL parser, we are removing this functionality. From now on, you must explicitly tell Active Record when you are referencing a table from a string:



    Post.includes(:comments).where("comments.title = 'foo'").references(:comments)



If you don't rely on implicit join references you can disable the feature entirely by setting `config.active_record.disable_implicit_join_references = true`. (called from designations_received? at /home/travis/build/Liaison-Intl/WebAdMIT/app/models/applicant.rb:941)

[32m.[0mDEPRECATION WARNING: It looks like you are eager loading table(s) (one of: scoring_models, scoring_model_assignments, programs) that are referenced in a string SQL snippet. For example:



    Post.includes(:comments).where("comments.title = 'foo'")



Currently, Active Record recognizes the table in the string, and knows to JOIN the comments table to the query, rather than loading comments in a separate query. However, doing this without writing a full-blown SQL parser is inherently flawed. Since we don't want to write an SQL parser, we are removing this functionality. From now on, you must explicitly tell Active Record when you are referencing a table from a string:



    Post.includes(:comments).where("comments.title = 'foo'").references(:comments)



If you don't rely on implicit join references you can disable the feature entirely by setting `config.active_record.disable_implicit_join_references = true`. (called from score_for_scoring_models at /home/travis/build/Liaison-Intl/WebAdMIT/app/models/scoring/scorer.rb:50)

DEPRECATION WARNING: It looks like you are eager loading table(s) (one of: scoring_models, scoring_model_assignments, programs) that are referenced in a string SQL snippet. For example:



    Post.includes(:comments).where("comments.title = 'foo'")



Currently, Active Record recognizes the table in the string, and knows to JOIN the comments table to the query, rather than loading comments in a separate query. However, doing this without writing a full-blown SQL parser is inherently flawed. Since we don't want to write an SQL parser, we are removing this functionality. From now on, you must explicitly tell Active Record when you are referencing a table from a string:



    Post.includes(:comments).where("comments.title = 'foo'").references(:comments)



If you don't rely on implicit join references you can disable the feature entirely by setting `config.active_record.disable_implicit_join_references = true`. (called from score_for_scoring_models at /home/travis/build/Liaison-Intl/WebAdMIT/app/models/scoring/scorer.rb:50)

DEPRECATION WARNING: It looks like you are eager loading table(s) (one of: designations, programs, user_identity_programs) that are referenced in a string SQL snippet. For example:



    Post.includes(:comments).where("comments.title = 'foo'")



Currently, Active Record recognizes the table in the string, and knows to JOIN the comments table to the query, rather than loading comments in a separate query. However, doing this without writing a full-blown SQL parser is inherently flawed. Since we don't want to write an SQL parser, we are removing this functionality. From now on, you must explicitly tell Active Record when you are referencing a table from a string:



    Post.includes(:comments).where("comments.title = 'foo'").references(:comments)



If you don't rely on implicit join references you can disable the feature entirely by setting `config.active_record.disable_implicit_join_references = true`. (called from designations_received? at /home/travis/build/Liaison-Intl/WebAdMIT/app/models/applicant.rb:941)

[32m.[0mDEPRECATION WARNING: It looks like you are eager loading table(s) (one of: scoring_models, scoring_model_assignments, programs) that are referenced in a string SQL snippet. For example:



    Post.includes(:comments).where("comments.title = 'foo'")



Currently, Active Record recognizes the table in the string, and knows to JOIN the comments table to the query, rather than loading comments in a separate query. However, doing this without writing a full-blown SQL parser is inherently flawed. Since we don't want to write an SQL parser, we are removing this functionality. From now on, you must explicitly tell Active Record when you are referencing a table from a string:



    Post.includes(:comments).where("comments.title = 'foo'").references(:comments)



If you don't rely on implicit join references you can disable the feature entirely by setting `config.active_record.disable_implicit_join_references = true`. (called from score_for_scoring_models at /home/travis/build/Liaison-Intl/WebAdMIT/app/models/scoring/scorer.rb:50)

DEPRECATION WARNING: It looks like you are eager loading table(s) (one of: scoring_models, scoring_model_assignments, programs) that are referenced in a string SQL snippet. For example:



    Post.includes(:comments).where("comments.title = 'foo'")



Currently, Active Record recognizes the table in the string, and knows to JOIN the comments table to the query, rather than loading comments in a separate query. However, doing this without writing a full-blown SQL parser is inherently flawed. Since we don't want to write an SQL parser, we are removing this functionality. From now on, you must explicitly tell Active Record when you are referencing a table from a string:



    Post.includes(:comments).where("comments.title = 'foo'").references(:comments)



If you don't rely on implicit join references you can disable the feature entirely by setting `config.active_record.disable_implicit_join_references = true`. (called from score_for_scoring_models at /home/travis/build/Liaison-Intl/WebAdMIT/app/models/scoring/scorer.rb:50)

DEPRECATION WARNING: It looks like you are eager loading table(s) (one of: designations, programs, user_identity_programs) that are referenced in a string SQL snippet. For example:



    Post.includes(:comments).where("comments.title = 'foo'")



Currently, Active Record recognizes the table in the string, and knows to JOIN the comments table to the query, rather than loading comments in a separate query. However, doing this without writing a full-blown SQL parser is inherently flawed. Since we don't want to write an SQL parser, we are removing this functionality. From now on, you must explicitly tell Active Record when you are referencing a table from a string:



    Post.includes(:comments).where("comments.title = 'foo'").references(:comments)



If you don't rely on implicit join references you can disable the feature entirely by setting `config.active_record.disable_implicit_join_references = true`. (called from designations_received? at /home/travis/build/Liaison-Intl/WebAdMIT/app/models/applicant.rb:941)

[32m.[0mDEPRECATION WARNING: It looks like you are eager loading table(s) (one of: scoring_models, scoring_model_assignments, programs) that are referenced in a string SQL snippet. For example:



    Post.includes(:comments).where("comments.title = 'foo'")



Currently, Active Record recognizes the table in the string, and knows to JOIN the comments table to the query, rather than loading comments in a separate query. However, doing this without writing a full-blown SQL parser is inherently flawed. Since we don't want to write an SQL parser, we are removing this functionality. From now on, you must explicitly tell Active Record when you are referencing a table from a string:



    Post.includes(:comments).where("comments.title = 'foo'").references(:comments)



If you don't rely on implicit join references you can disable the feature entirely by setting `config.active_record.disable_implicit_join_references = true`. (called from score_for_scoring_models at /home/travis/build/Liaison-Intl/WebAdMIT/app/models/scoring/scorer.rb:50)

DEPRECATION WARNING: It looks like you are eager loading table(s) (one of: scoring_models, scoring_model_assignments, programs) that are referenced in a string SQL snippet. For example:



    Post.includes(:comments).where("comments.title = 'foo'")



Currently, Active Record recognizes the table in the string, and knows to JOIN the comments table to the query, rather than loading comments in a separate query. However, doing this without writing a full-blown SQL parser is inherently flawed. Since we don't want to write an SQL parser, we are removing this functionality. From now on, you must explicitly tell Active Record when you are referencing a table from a string:



    Post.includes(:comments).where("comments.title = 'foo'").references(:comments)



If you don't rely on implicit join references you can disable the feature entirely by setting `config.active_record.disable_implicit_join_references = true`. (called from score_for_scoring_models at /home/travis/build/Liaison-Intl/WebAdMIT/app/models/scoring/scorer.rb:50)

DEPRECATION WARNING: It looks like you are eager loading table(s) (one of: designations, programs, user_identity_programs) that are referenced in a string SQL snippet. For example:



    Post.includes(:comments).where("comments.title = 'foo'")



Currently, Active Record recognizes the table in the string, and knows to JOIN the comments table to the query, rather than loading comments in a separate query. However, doing this without writing a full-blown SQL parser is inherently flawed. Since we don't want to write an SQL parser, we are removing this functionality. From now on, you must explicitly tell Active Record when you are referencing a table from a string:



    Post.includes(:comments).where("comments.title = 'foo'").references(:comments)



If you don't rely on implicit join references you can disable the feature entirely by setting `config.active_record.disable_implicit_join_references = true`. (called from designations_received? at /home/travis/build/Liaison-Intl/WebAdMIT/app/models/applicant.rb:941)

[32m.[0mDEPRECATION WARNING: It looks like you are eager loading table(s) (one of: scoring_models, scoring_model_assignments, programs) that are referenced in a string SQL snippet. For example:



    Post.includes(:comments).where("comments.title = 'foo'")



Currently, Active Record recognizes the table in the string, and knows to JOIN the comments table to the query, rather than loading comments in a separate query. However, doing this without writing a full-blown SQL parser is inherently flawed. Since we don't want to write an SQL parser, we are removing this functionality. From now on, you must explicitly tell Active Record when you are referencing a table from a string:



    Post.includes(:comments).where("comments.title = 'foo'").references(:comments)



If you don't rely on implicit join references you can disable the feature entirely by setting `config.active_record.disable_implicit_join_references = true`. (called from score_for_scoring_models at /home/travis/build/Liaison-Intl/WebAdMIT/app/models/scoring/scorer.rb:50)

DEPRECATION WARNING: It looks like you are eager loading table(s) (one of: scoring_models, scoring_model_assignments, programs) that are referenced in a string SQL snippet. For example:



    Post.includes(:comments).where("comments.title = 'foo'")



Currently, Active Record recognizes the table in the string, and knows to JOIN the comments table to the query, rather than loading comments in a separate query. However, doing this without writing a full-blown SQL parser is inherently flawed. Since we don't want to write an SQL parser, we are removing this functionality. From now on, you must explicitly tell Active Record when you are referencing a table from a string:



    Post.includes(:comments).where("comments.title = 'foo'").references(:comments)



If you don't rely on implicit join references you can disable the feature entirely by setting `config.active_record.disable_implicit_join_references = true`. (called from score_for_scoring_models at /home/travis/build/Liaison-Intl/WebAdMIT/app/models/scoring/scorer.rb:50)

DEPRECATION WARNING: It looks like you are eager loading table(s) (one of: designations, programs, user_identity_programs) that are referenced in a string SQL snippet. For example:



    Post.includes(:comments).where("comments.title = 'foo'")



Currently, Active Record recognizes the table in the string, and knows to JOIN the comments table to the query, rather than loading comments in a separate query. However, doing this without writing a full-blown SQL parser is inherently flawed. Since we don't want to write an SQL parser, we are removing this functionality. From now on, you must explicitly tell Active Record when you are referencing a table from a string:



    Post.includes(:comments).where("comments.title = 'foo'").references(:comments)



If you don't rely on implicit join references you can disable the feature entirely by setting `config.active_record.disable_implicit_join_references = true`. (called from designations_received? at /home/travis/build/Liaison-Intl/WebAdMIT/app/models/applicant.rb:941)

[32m.[0mDEPRECATION WARNING: It looks like you are eager loading table(s) (one of: scoring_models, scoring_model_assignments, programs) that are referenced in a string SQL snippet. For example:



    Post.includes(:comments).where("comments.title = 'foo'")



Currently, Active Record recognizes the table in the string, and knows to JOIN the comments table to the query, rather than loading comments in a separate query. However, doing this without writing a full-blown SQL parser is inherently flawed. Since we don't want to write an SQL parser, we are removing this functionality. From now on, you must explicitly tell Active Record when you are referencing a table from a string:



    Post.includes(:comments).where("comments.title = 'foo'").references(:comments)



If you don't rely on implicit join references you can disable the feature entirely by setting `config.active_record.disable_implicit_join_references = true`. (called from score_for_scoring_models at /home/travis/build/Liaison-Intl/WebAdMIT/app/models/scoring/scorer.rb:50)

DEPRECATION WARNING: It looks like you are eager loading table(s) (one of: scoring_models, scoring_model_assignments, programs) that are referenced in a string SQL snippet. For example:



    Post.includes(:comments).where("comments.title = 'foo'")



Currently, Active Record recognizes the table in the string, and knows to JOIN the comments table to the query, rather than loading comments in a separate query. However, doing this without writing a full-blown SQL parser is inherently flawed. Since we don't want to write an SQL parser, we are removing this functionality. From now on, you must explicitly tell Active Record when you are referencing a table from a string:



    Post.includes(:comments).where("comments.title = 'foo'").references(:comments)



If you don't rely on implicit join references you can disable the feature entirely by setting `config.active_record.disable_implicit_join_references = true`. (called from score_for_scoring_models at /home/travis/build/Liaison-Intl/WebAdMIT/app/models/scoring/scorer.rb:50)

DEPRECATION WARNING: Relation#all is deprecated. If you want to eager-load a relation, you can call #load (e.g. `Post.where(published: true).load`). If you want to get an array of records from a relation, you can call #to_a (e.g. `Post.where(published: true).to_a`). (called from _app_views_lists_show_html_haml___2214543903039240092_516440520 at /home/travis/build/Liaison-Intl/WebAdMIT/app/views/lists/show.html.haml:9)

[32m.[0mDEPRECATION WARNING: It looks like you are eager loading table(s) (one of: scoring_models, scoring_model_assignments, programs) that are referenced in a string SQL snippet. For example:



    Post.includes(:comments).where("comments.title = 'foo'")



Currently, Active Record recognizes the table in the string, and knows to JOIN the comments table to the query, rather than loading comments in a separate query. However, doing this without writing a full-blown SQL parser is inherently flawed. Since we don't want to write an SQL parser, we are removing this functionality. From now on, you must explicitly tell Active Record when you are referencing a table from a string:



    Post.includes(:comments).where("comments.title = 'foo'").references(:comments)



If you don't rely on implicit join references you can disable the feature entirely by setting `config.active_record.disable_implicit_join_references = true`. (called from score_for_scoring_models at /home/travis/build/Liaison-Intl/WebAdMIT/app/models/scoring/scorer.rb:50)

DEPRECATION WARNING: It looks like you are eager loading table(s) (one of: scoring_models, scoring_model_assignments, programs) that are referenced in a string SQL snippet. For example:



    Post.includes(:comments).where("comments.title = 'foo'")



Currently, Active Record recognizes the table in the string, and knows to JOIN the comments table to the query, rather than loading comments in a separate query. However, doing this without writing a full-blown SQL parser is inherently flawed. Since we don't want to write an SQL parser, we are removing this functionality. From now on, you must explicitly tell Active Record when you are referencing a table from a string:



    Post.includes(:comments).where("comments.title = 'foo'").references(:comments)



If you don't rely on implicit join references you can disable the feature entirely by setting `config.active_record.disable_implicit_join_references = true`. (called from score_for_scoring_models at /home/travis/build/Liaison-Intl/WebAdMIT/app/models/scoring/scorer.rb:50)

DEPRECATION WARNING: Relation#all is deprecated. If you want to eager-load a relation, you can call #load (e.g. `Post.where(published: true).load`). If you want to get an array of records from a relation, you can call #to_a (e.g. `Post.where(published: true).to_a`). (called from _app_views_lists_show_html_haml___2214543903039240092_516440520 at /home/travis/build/Liaison-Intl/WebAdMIT/app/views/lists/show.html.haml:9)

[32m.[0m[32m.[0m[32m.[0m[32m.[0mDEPRECATION WARNING: It looks like you are eager loading table(s) (one of: scoring_models, scoring_model_assignments, programs) that are referenced in a string SQL snippet. For example:



    Post.includes(:comments).where("comments.title = 'foo'")



Currently, Active Record recognizes the table in the string, and knows to JOIN the comments table to the query, rather than loading comments in a separate query. However, doing this without writing a full-blown SQL parser is inherently flawed. Since we don't want to write an SQL parser, we are removing this functionality. From now on, you must explicitly tell Active Record when you are referencing a table from a string:



    Post.includes(:comments).where("comments.title = 'foo'").references(:comments)



If you don't rely on implicit join references you can disable the feature entirely by setting `config.active_record.disable_implicit_join_references = true`. (called from score_for_scoring_models at /home/travis/build/Liaison-Intl/WebAdMIT/app/models/scoring/scorer.rb:50)

[32m.[0m[32m.[0m[32m.[0m[32m.[0m[32m.[0m[32m.[0m[32m.[0mDEPRECATION WARNING: It looks like you are eager loading table(s) (one of: scoring_models, scoring_model_assignments, programs) that are referenced in a string SQL snippet. For example:



    Post.includes(:comments).where("comments.title = 'foo'")



Currently, Active Record recognizes the table in the string, and knows to JOIN the comments table to the query, rather than loading comments in a separate query. However, doing this without writing a full-blown SQL parser is inherently flawed. Since we don't want to write an SQL parser, we are removing this functionality. From now on, you must explicitly tell Active Record when you are referencing a table from a string:



    Post.includes(:comments).where("comments.title = 'foo'").references(:comments)



If you don't rely on implicit join references you can disable the feature entirely by setting `config.active_record.disable_implicit_join_references = true`. (called from score_for_scoring_models at /home/travis/build/Liaison-Intl/WebAdMIT/app/models/scoring/scorer.rb:50)

DEPRECATION WARNING: It looks like you are eager loading table(s) (one of: designations, programs, user_identity_programs) that are referenced in a string SQL snippet. For example:



    Post.includes(:comments).where("comments.title = 'foo'")



Currently, Active Record recognizes the table in the string, and knows to JOIN the comments table to the query, rather than loading comments in a separate query. However, doing this without writing a full-blown SQL parser is inherently flawed. Since we don't want to write an SQL parser, we are removing this functionality. From now on, you must explicitly tell Active Record when you are referencing a table from a string:



    Post.includes(:comments).where("comments.title = 'foo'").references(:comments)



If you don't rely on implicit join references you can disable the feature entirely by setting `config.active_record.disable_implicit_join_references = true`. (called from designations_received? at /home/travis/build/Liaison-Intl/WebAdMIT/app/models/applicant.rb:941)

DEPRECATION WARNING: #scoped is deprecated. use #scope instead. (called from parse_relation at /home/travis/build/Liaison-Intl/WebAdMIT/app/models/exports/field_value.rb:134)

DEPRECATION WARNING: #scoped is deprecated. use #scope instead. (called from parse_relation at /home/travis/build/Liaison-Intl/WebAdMIT/app/models/exports/field_value.rb:134)

DEPRECATION WARNING: #scoped is deprecated. use #scope instead. (called from parse_relation at /home/travis/build/Liaison-Intl/WebAdMIT/app/models/exports/field_value.rb:134)

DEPRECATION WARNING: #scoped is deprecated. use #scope instead. (called from parse_relation at /home/travis/build/Liaison-Intl/WebAdMIT/app/models/exports/field_value.rb:134)

[32m.[0mDEPRECATION WARNING: It looks like you are eager loading table(s) (one of: scoring_models, scoring_model_assignments, programs) that are referenced in a string SQL snippet. For example:



    Post.includes(:comments).where("comments.title = 'foo'")



Currently, Active Record recognizes the table in the string, and knows to JOIN the comments table to the query, rather than loading comments in a separate query. However, doing this without writing a full-blown SQL parser is inherently flawed. Since we don't want to write an SQL parser, we are removing this functionality. From now on, you must explicitly tell Active Record when you are referencing a table from a string:



    Post.includes(:comments).where("comments.title = 'foo'").references(:comments)



If you don't rely on implicit join references you can disable the feature entirely by setting `config.active_record.disable_implicit_join_references = true`. (called from score_for_scoring_models at /home/travis/build/Liaison-Intl/WebAdMIT/app/models/scoring/scorer.rb:50)

DEPRECATION WARNING: It looks like you are eager loading table(s) (one of: designations, programs, user_identity_programs) that are referenced in a string SQL snippet. For example:



    Post.includes(:comments).where("comments.title = 'foo'")



Currently, Active Record recognizes the table in the string, and knows to JOIN the comments table to the query, rather than loading comments in a separate query. However, doing this without writing a full-blown SQL parser is inherently flawed. Since we don't want to write an SQL parser, we are removing this functionality. From now on, you must explicitly tell Active Record when you are referencing a table from a string:



    Post.includes(:comments).where("comments.title = 'foo'").references(:comments)



If you don't rely on implicit join references you can disable the feature entirely by setting `config.active_record.disable_implicit_join_references = true`. (called from designations_received? at /home/travis/build/Liaison-Intl/WebAdMIT/app/models/applicant.rb:941)

DEPRECATION WARNING: #scoped is deprecated. use #scope instead. (called from parse_relation at /home/travis/build/Liaison-Intl/WebAdMIT/app/models/exports/field_value.rb:134)

DEPRECATION WARNING: #scoped is deprecated. use #scope instead. (called from parse_relation at /home/travis/build/Liaison-Intl/WebAdMIT/app/models/exports/field_value.rb:134)

[32m.[0mDEPRECATION WARNING: It looks like you are eager loading table(s) (one of: scoring_models, scoring_model_assignments, programs) that are referenced in a string SQL snippet. For example:



    Post.includes(:comments).where("comments.title = 'foo'")



Currently, Active Record recognizes the table in the string, and knows to JOIN the comments table to the query, rather than loading comments in a separate query. However, doing this without writing a full-blown SQL parser is inherently flawed. Since we don't want to write an SQL parser, we are removing this functionality. From now on, you must explicitly tell Active Record when you are referencing a table from a string:



    Post.includes(:comments).where("comments.title = 'foo'").references(:comments)



If you don't rely on implicit join references you can disable the feature entirely by setting `config.active_record.disable_implicit_join_references = true`. (called from score_for_scoring_models at /home/travis/build/Liaison-Intl/WebAdMIT/app/models/scoring/scorer.rb:50)

DEPRECATION WARNING: It looks like you are eager loading table(s) (one of: designations, programs, user_identity_programs) that are referenced in a string SQL snippet. For example:



    Post.includes(:comments).where("comments.title = 'foo'")



Currently, Active Record recognizes the table in the string, and knows to JOIN the comments table to the query, rather than loading comments in a separate query. However, doing this without writing a full-blown SQL parser is inherently flawed. Since we don't want to write an SQL parser, we are removing this functionality. From now on, you must explicitly tell Active Record when you are referencing a table from a string:



    Post.includes(:comments).where("comments.title = 'foo'").references(:comments)



If you don't rely on implicit join references you can disable the feature entirely by setting `config.active_record.disable_implicit_join_references = true`. (called from designations_received? at /home/travis/build/Liaison-Intl/WebAdMIT/app/models/applicant.rb:941)

[32m.[0mDEPRECATION WARNING: It looks like you are eager loading table(s) (one of: scoring_models, scoring_model_assignments, programs) that are referenced in a string SQL snippet. For example:



    Post.includes(:comments).where("comments.title = 'foo'")



Currently, Active Record recognizes the table in the string, and knows to JOIN the comments table to the query, rather than loading comments in a separate query. However, doing this without writing a full-blown SQL parser is inherently flawed. Since we don't want to write an SQL parser, we are removing this functionality. From now on, you must explicitly tell Active Record when you are referencing a table from a string:



    Post.includes(:comments).where("comments.title = 'foo'").references(:comments)



If you don't rely on implicit join references you can disable the feature entirely by setting `config.active_record.disable_implicit_join_references = true`. (called from score_for_scoring_models at /home/travis/build/Liaison-Intl/WebAdMIT/app/models/scoring/scorer.rb:50)

DEPRECATION WARNING: It looks like you are eager loading table(s) (one of: designations, programs, user_identity_programs) that are referenced in a string SQL snippet. For example:



    Post.includes(:comments).where("comments.title = 'foo'")



Currently, Active Record recognizes the table in the string, and knows to JOIN the comments table to the query, rather than loading comments in a separate query. However, doing this without writing a full-blown SQL parser is inherently flawed. Since we don't want to write an SQL parser, we are removing this functionality. From now on, you must explicitly tell Active Record when you are referencing a table from a string:



    Post.includes(:comments).where("comments.title = 'foo'").references(:comments)



If you don't rely on implicit join references you can disable the feature entirely by setting `config.active_record.disable_implicit_join_references = true`. (called from designations_received? at /home/travis/build/Liaison-Intl/WebAdMIT/app/models/applicant.rb:941)

[32m.[0mDEPRECATION WARNING: It looks like you are eager loading table(s) (one of: scoring_models, scoring_model_assignments, programs) that are referenced in a string SQL snippet. For example:



    Post.includes(:comments).where("comments.title = 'foo'")



Currently, Active Record recognizes the table in the string, and knows to JOIN the comments table to the query, rather than loading comments in a separate query. However, doing this without writing a full-blown SQL parser is inherently flawed. Since we don't want to write an SQL parser, we are removing this functionality. From now on, you must explicitly tell Active Record when you are referencing a table from a string:



    Post.includes(:comments).where("comments.title = 'foo'").references(:comments)



If you don't rely on implicit join references you can disable the feature entirely by setting `config.active_record.disable_implicit_join_references = true`. (called from score_for_scoring_models at /home/travis/build/Liaison-Intl/WebAdMIT/app/models/scoring/scorer.rb:50)

DEPRECATION WARNING: It looks like you are eager loading table(s) (one of: designations, programs, user_identity_programs) that are referenced in a string SQL snippet. For example:



    Post.includes(:comments).where("comments.title = 'foo'")



Currently, Active Record recognizes the table in the string, and knows to JOIN the comments table to the query, rather than loading comments in a separate query. However, doing this without writing a full-blown SQL parser is inherently flawed. Since we don't want to write an SQL parser, we are removing this functionality. From now on, you must explicitly tell Active Record when you are referencing a table from a string:



    Post.includes(:comments).where("comments.title = 'foo'").references(:comments)



If you don't rely on implicit join references you can disable the feature entirely by setting `config.active_record.disable_implicit_join_references = true`. (called from designations_received? at /home/travis/build/Liaison-Intl/WebAdMIT/app/models/applicant.rb:941)

[32m.[0mDEPRECATION WARNING: It looks like you are eager loading table(s) (one of: scoring_models, scoring_model_assignments, programs) that are referenced in a string SQL snippet. For example:



    Post.includes(:comments).where("comments.title = 'foo'")



Currently, Active Record recognizes the table in the string, and knows to JOIN the comments table to the query, rather than loading comments in a separate query. However, doing this without writing a full-blown SQL parser is inherently flawed. Since we don't want to write an SQL parser, we are removing this functionality. From now on, you must explicitly tell Active Record when you are referencing a table from a string:



    Post.includes(:comments).where("comments.title = 'foo'").references(:comments)



If you don't rely on implicit join references you can disable the feature entirely by setting `config.active_record.disable_implicit_join_references = true`. (called from score_for_scoring_models at /home/travis/build/Liaison-Intl/WebAdMIT/app/models/scoring/scorer.rb:50)

DEPRECATION WARNING: It looks like you are eager loading table(s) (one of: designations, programs, user_identity_programs) that are referenced in a string SQL snippet. For example:



    Post.includes(:comments).where("comments.title = 'foo'")



Currently, Active Record recognizes the table in the string, and knows to JOIN the comments table to the query, rather than loading comments in a separate query. However, doing this without writing a full-blown SQL parser is inherently flawed. Since we don't want to write an SQL parser, we are removing this functionality. From now on, you must explicitly tell Active Record when you are referencing a table from a string:



    Post.includes(:comments).where("comments.title = 'foo'").references(:comments)



If you don't rely on implicit join references you can disable the feature entirely by setting `config.active_record.disable_implicit_join_references = true`. (called from designations_received? at /home/travis/build/Liaison-Intl/WebAdMIT/app/models/applicant.rb:941)

[32m.[0mDEPRECATION WARNING: It looks like you are eager loading table(s) (one of: scoring_models, scoring_model_assignments, programs) that are referenced in a string SQL snippet. For example:



    Post.includes(:comments).where("comments.title = 'foo'")



Currently, Active Record recognizes the table in the string, and knows to JOIN the comments table to the query, rather than loading comments in a separate query. However, doing this without writing a full-blown SQL parser is inherently flawed. Since we don't want to write an SQL parser, we are removing this functionality. From now on, you must explicitly tell Active Record when you are referencing a table from a string:



    Post.includes(:comments).where("comments.title = 'foo'").references(:comments)



If you don't rely on implicit join references you can disable the feature entirely by setting `config.active_record.disable_implicit_join_references = true`. (called from score_for_scoring_models at /home/travis/build/Liaison-Intl/WebAdMIT/app/models/scoring/scorer.rb:50)

DEPRECATION WARNING: It looks like you are eager loading table(s) (one of: designations, programs, user_identity_programs) that are referenced in a string SQL snippet. For example:



    Post.includes(:comments).where("comments.title = 'foo'")



Currently, Active Record recognizes the table in the string, and knows to JOIN the comments table to the query, rather than loading comments in a separate query. However, doing this without writing a full-blown SQL parser is inherently flawed. Since we don't want to write an SQL parser, we are removing this functionality. From now on, you must explicitly tell Active Record when you are referencing a table from a string:



    Post.includes(:comments).where("comments.title = 'foo'").references(:comments)



If you don't rely on implicit join references you can disable the feature entirely by setting `config.active_record.disable_implicit_join_references = true`. (called from designations_received? at /home/travis/build/Liaison-Intl/WebAdMIT/app/models/applicant.rb:941)

[32m.[0mDEPRECATION WARNING: It looks like you are eager loading table(s) (one of: scoring_models, scoring_model_assignments, programs) that are referenced in a string SQL snippet. For example:



    Post.includes(:comments).where("comments.title = 'foo'")



Currently, Active Record recognizes the table in the string, and knows to JOIN the comments table to the query, rather than loading comments in a separate query. However, doing this without writing a full-blown SQL parser is inherently flawed. Since we don't want to write an SQL parser, we are removing this functionality. From now on, you must explicitly tell Active Record when you are referencing a table from a string:



    Post.includes(:comments).where("comments.title = 'foo'").references(:comments)



If you don't rely on implicit join references you can disable the feature entirely by setting `config.active_record.disable_implicit_join_references = true`. (called from score_for_scoring_models at /home/travis/build/Liaison-Intl/WebAdMIT/app/models/scoring/scorer.rb:50)

DEPRECATION WARNING: It looks like you are eager loading table(s) (one of: designations, programs, user_identity_programs) that are referenced in a string SQL snippet. For example:



    Post.includes(:comments).where("comments.title = 'foo'")



Currently, Active Record recognizes the table in the string, and knows to JOIN the comments table to the query, rather than loading comments in a separate query. However, doing this without writing a full-blown SQL parser is inherently flawed. Since we don't want to write an SQL parser, we are removing this functionality. From now on, you must explicitly tell Active Record when you are referencing a table from a string:



    Post.includes(:comments).where("comments.title = 'foo'").references(:comments)



If you don't rely on implicit join references you can disable the feature entirely by setting `config.active_record.disable_implicit_join_references = true`. (called from designations_received? at /home/travis/build/Liaison-Intl/WebAdMIT/app/models/applicant.rb:941)

[32m.[0m[32m.[0m[32m.[0m[32m.[0m[32m.[0m[32m.[0m[32m.[0m[32m.[0m

    [33mERROR[0m (0:13:27.473) test_0002_shows the Edit PDF Settings page with selected subpanels and save an edited PDF template successfully

[1m          One or more errors were raised in the Javascript code on the page. If you don't care about these errors, you can ignore them by setting js_errors: false in your Poltergeist configuration (see documentation for details).



          TypeError: undefined is not an object (evaluating 'this.$["data-cke-expando"]')

          TypeError: undefined is not an object (evaluating 'this.$["data-cke-expando"]')

              at http://127.0.0.1:37620/assets/ckeditor/ckeditor.js:47 in getCustomData

              at http://127.0.0.1:37620/assets/ckeditor/ckeditor.js:44 in on

              at http://127.0.0.1:37620/assets/ckeditor/template_config.js?t=D3NA:77

              at http://127.0.0.1:37620/assets/ckeditor/ckeditor.js:11 in i

              at http://127.0.0.1:37620/assets/ckeditor/ckeditor.js:13

              at http://127.0.0.1:37620/assets/ckeditor/ckeditor.js:14 in fire

              at http://127.0.0.1:37620/assets/ckeditor/ckeditor.js:758

              at http://127.0.0.1:37620/assets/ckeditor/ckeditor.js:25[0m

        @ vendor/bundle/ruby/1.9.1/gems/poltergeist-1.15.0/lib/capybara/poltergeist/browser.rb:377:in `command'

          vendor/bundle/ruby/1.9.1/gems/poltergeist-1.15.0/lib/capybara/poltergeist/browser.rb:64:in `find'

          vendor/bundle/ruby/1.9.1/gems/poltergeist-1.15.0/lib/capybara/poltergeist/driver.rb:122:in `find'

          vendor/bundle/ruby/1.9.1/gems/poltergeist-1.15.0/lib/capybara/poltergeist/driver.rb:130:in `find_css'

          vendor/bundle/ruby/1.9.1/gems/capybara-2.1.0/lib/capybara/node/finders.rb:152:in `block in resolve_query'

          vendor/bundle/ruby/1.9.1/gems/capybara-2.1.0/lib/capybara/node/base.rb:77:in `synchronize'

          vendor/bundle/ruby/1.9.1/gems/capybara-2.1.0/lib/capybara/node/finders.rb:150:in `resolve_query'

          vendor/bundle/ruby/1.9.1/gems/capybara-2.1.0/lib/capybara/node/finders.rb:32:in `block in find'

          vendor/bundle/ruby/1.9.1/gems/capybara-2.1.0/lib/capybara/node/base.rb:81:in `synchronize'

          vendor/bundle/ruby/1.9.1/gems/capybara-2.1.0/lib/capybara/node/finders.rb:30:in `find'

          vendor/bundle/ruby/1.9.1/gems/capybara-2.1.0/lib/capybara/session.rb:354:in `block (2 levels) in <class:Session>'

          vendor/bundle/ruby/1.9.1/gems/capybara-2.1.0/lib/capybara/dsl.rb:51:in `block (2 levels) in <module:DSL>'

          test/support/pdf_manager_template_helpers.rb:36:in `wait_for_editor_ready'

          test/support/pdf_manager_template_helpers.rb:32:in `set_document_type'

          test/support/pdf_manager_template_helpers.rb:24:in `must_populate_file_name_pattern'

          test/integration/pdf_manager_test.rb:148:in `block (4 levels) in <top (required)>'

          vendor/bundle/ruby/1.9.1/gems/minitest-4.7.5/lib/minitest/unit.rb:1258:in `run'

          vendor/bundle/ruby/1.9.1/gems/turn-0.9.7/lib/turn/runners/minirunner.rb:91:in `block in _run_suite'

          vendor/bundle/ruby/1.9.1/gems/turn-0.9.7/lib/turn/runners/minirunner.rb:84:in `map'

          vendor/bundle/ruby/1.9.1/gems/turn-0.9.7/lib/turn/runners/minirunner.rb:84:in `_run_suite'

          vendor/bundle/ruby/1.9.1/gems/turn-0.9.7/lib/turn/runners/minirunner.rb:61:in `block in _run_suites'

          vendor/bundle/ruby/1.9.1/gems/turn-0.9.7/lib/turn/runners/minirunner.rb:61:in `map'

          vendor/bundle/ruby/1.9.1/gems/turn-0.9.7/lib/turn/runners/minirunner.rb:61:in `_run_suites'

          vendor/bundle/ruby/1.9.1/gems/minitest-4.7.5/lib/minitest/unit.rb:877:in `_run_anything'

          vendor/bundle/ruby/1.9.1/gems/minitest-4.7.5/lib/minitest/unit.rb:1085:in `run_tests'

          vendor/bundle/ruby/1.9.1/gems/minitest-4.7.5/lib/minitest/unit.rb:1072:in `block in _run'

          vendor/bundle/ruby/1.9.1/gems/minitest-4.7.5/lib/minitest/unit.rb:1071:in `each'

          vendor/bundle/ruby/1.9.1/gems/minitest-4.7.5/lib/minitest/unit.rb:1071:in `_run'

          vendor/bundle/ruby/1.9.1/gems/minitest-4.7.5/lib/minitest/unit.rb:1059:in `run'

          vendor/bundle/ruby/1.9.1/gems/minitest-4.7.5/lib/minitest/unit.rb:795:in `block in autorun'



[32m.[0m[32m.[0m[32m.[0m[32m.[0m[32m.[0m[32m.[0m[32m.[0m[32m.[0m[32m.[0mDEPRECATION WARNING: It looks like you are eager loading table(s) (one of: scoring_models, scoring_model_assignments, programs) that are referenced in a string SQL snippet. For example:



    Post.includes(:comments).where("comments.title = 'foo'")



Currently, Active Record recognizes the table in the string, and knows to JOIN the comments table to the query, rather than loading comments in a separate query. However, doing this without writing a full-blown SQL parser is inherently flawed. Since we don't want to write an SQL parser, we are removing this functionality. From now on, you must explicitly tell Active Record when you are referencing a table from a string:



    Post.includes(:comments).where("comments.title = 'foo'").references(:comments)



If you don't rely on implicit join references you can disable the feature entirely by setting `config.active_record.disable_implicit_join_references = true`. (called from score_for_scoring_models at /home/travis/build/Liaison-Intl/WebAdMIT/app/models/scoring/scorer.rb:50)

DEPRECATION WARNING: It looks like you are eager loading table(s) (one of: designations, programs, user_identity_programs) that are referenced in a string SQL snippet. For example:



    Post.includes(:comments).where("comments.title = 'foo'")



Currently, Active Record recognizes the table in the string, and knows to JOIN the comments table to the query, rather than loading comments in a separate query. However, doing this without writing a full-blown SQL parser is inherently flawed. Since we don't want to write an SQL parser, we are removing this functionality. From now on, you must explicitly tell Active Record when you are referencing a table from a string:



    Post.includes(:comments).where("comments.title = 'foo'").references(:comments)



If you don't rely on implicit join references you can disable the feature entirely by setting `config.active_record.disable_implicit_join_references = true`. (called from designations_received? at /home/travis/build/Liaison-Intl/WebAdMIT/app/models/applicant.rb:941)

[32m.[0mDEPRECATION WARNING: It looks like you are eager loading table(s) (one of: scoring_models, scoring_model_assignments, programs) that are referenced in a string SQL snippet. For example:



    Post.includes(:comments).where("comments.title = 'foo'")



Currently, Active Record recognizes the table in the string, and knows to JOIN the comments table to the query, rather than loading comments in a separate query. However, doing this without writing a full-blown SQL parser is inherently flawed. Since we don't want to write an SQL parser, we are removing this functionality. From now on, you must explicitly tell Active Record when you are referencing a table from a string:



    Post.includes(:comments).where("comments.title = 'foo'").references(:comments)



If you don't rely on implicit join references you can disable the feature entirely by setting `config.active_record.disable_implicit_join_references = true`. (called from score_for_scoring_models at /home/travis/build/Liaison-Intl/WebAdMIT/app/models/scoring/scorer.rb:50)

DEPRECATION WARNING: It looks like you are eager loading table(s) (one of: designations, programs, user_identity_programs) that are referenced in a string SQL snippet. For example:



    Post.includes(:comments).where("comments.title = 'foo'")



Currently, Active Record recognizes the table in the string, and knows to JOIN the comments table to the query, rather than loading comments in a separate query. However, doing this without writing a full-blown SQL parser is inherently flawed. Since we don't want to write an SQL parser, we are removing this functionality. From now on, you must explicitly tell Active Record when you are referencing a table from a string:



    Post.includes(:comments).where("comments.title = 'foo'").references(:comments)



If you don't rely on implicit join references you can disable the feature entirely by setting `config.active_record.disable_implicit_join_references = true`. (called from designations_received? at /home/travis/build/Liaison-Intl/WebAdMIT/app/models/applicant.rb:941)

[32m.[0mDEPRECATION WARNING: It looks like you are eager loading table(s) (one of: scoring_models, scoring_model_assignments, programs) that are referenced in a string SQL snippet. For example:



    Post.includes(:comments).where("comments.title = 'foo'")



Currently, Active Record recognizes the table in the string, and knows to JOIN the comments table to the query, rather than loading comments in a separate query. However, doing this without writing a full-blown SQL parser is inherently flawed. Since we don't want to write an SQL parser, we are removing this functionality. From now on, you must explicitly tell Active Record when you are referencing a table from a string:



    Post.includes(:comments).where("comments.title = 'foo'").references(:comments)



If you don't rely on implicit join references you can disable the feature entirely by setting `config.active_record.disable_implicit_join_references = true`. (called from score_for_scoring_models at /home/travis/build/Liaison-Intl/WebAdMIT/app/models/scoring/scorer.rb:50)

DEPRECATION WARNING: It looks like you are eager loading table(s) (one of: designations, programs, user_identity_programs) that are referenced in a string SQL snippet. For example:



    Post.includes(:comments).where("comments.title = 'foo'")



Currently, Active Record recognizes the table in the string, and knows to JOIN the comments table to the query, rather than loading comments in a separate query. However, doing this without writing a full-blown SQL parser is inherently flawed. Since we don't want to write an SQL parser, we are removing this functionality. From now on, you must explicitly tell Active Record when you are referencing a table from a string:



    Post.includes(:comments).where("comments.title = 'foo'").references(:comments)



If you don't rely on implicit join references you can disable the feature entirely by setting `config.active_record.disable_implicit_join_references = true`. (called from designations_received? at /home/travis/build/Liaison-Intl/WebAdMIT/app/models/applicant.rb:941)

[32m.[0mDEPRECATION WARNING: It looks like you are eager loading table(s) (one of: scoring_models, scoring_model_assignments, programs) that are referenced in a string SQL snippet. For example:



    Post.includes(:comments).where("comments.title = 'foo'")



Currently, Active Record recognizes the table in the string, and knows to JOIN the comments table to the query, rather than loading comments in a separate query. However, doing this without writing a full-blown SQL parser is inherently flawed. Since we don't want to write an SQL parser, we are removing this functionality. From now on, you must explicitly tell Active Record when you are referencing a table from a string:



    Post.includes(:comments).where("comments.title = 'foo'").references(:comments)



If you don't rely on implicit join references you can disable the feature entirely by setting `config.active_record.disable_implicit_join_references = true`. (called from score_for_scoring_models at /home/travis/build/Liaison-Intl/WebAdMIT/app/models/scoring/scorer.rb:50)

DEPRECATION WARNING: It looks like you are eager loading table(s) (one of: designations, programs, user_identity_programs) that are referenced in a string SQL snippet. For example:



    Post.includes(:comments).where("comments.title = 'foo'")



Currently, Active Record recognizes the table in the string, and knows to JOIN the comments table to the query, rather than loading comments in a separate query. However, doing this without writing a full-blown SQL parser is inherently flawed. Since we don't want to write an SQL parser, we are removing this functionality. From now on, you must explicitly tell Active Record when you are referencing a table from a string:



    Post.includes(:comments).where("comments.title = 'foo'").references(:comments)



If you don't rely on implicit join references you can disable the feature entirely by setting `config.active_record.disable_implicit_join_references = true`. (called from designations_received? at /home/travis/build/Liaison-Intl/WebAdMIT/app/models/applicant.rb:941)

[32m.[0mDEPRECATION WARNING: It looks like you are eager loading table(s) (one of: scoring_models, scoring_model_assignments, programs) that are referenced in a string SQL snippet. For example:



    Post.includes(:comments).where("comments.title = 'foo'")



Currently, Active Record recognizes the table in the string, and knows to JOIN the comments table to the query, rather than loading comments in a separate query. However, doing this without writing a full-blown SQL parser is inherently flawed. Since we don't want to write an SQL parser, we are removing this functionality. From now on, you must explicitly tell Active Record when you are referencing a table from a string:



    Post.includes(:comments).where("comments.title = 'foo'").references(:comments)



If you don't rely on implicit join references you can disable the feature entirely by setting `config.active_record.disable_implicit_join_references = true`. (called from score_for_scoring_models at /home/travis/build/Liaison-Intl/WebAdMIT/app/models/scoring/scorer.rb:50)

DEPRECATION WARNING: It looks like you are eager loading table(s) (one of: designations, programs, user_identity_programs) that are referenced in a string SQL snippet. For example:



    Post.includes(:comments).where("comments.title = 'foo'")



Currently, Active Record recognizes the table in the string, and knows to JOIN the comments table to the query, rather than loading comments in a separate query. However, doing this without writing a full-blown SQL parser is inherently flawed. Since we don't want to write an SQL parser, we are removing this functionality. From now on, you must explicitly tell Active Record when you are referencing a table from a string:



    Post.includes(:comments).where("comments.title = 'foo'").references(:comments)



If you don't rely on implicit join references you can disable the feature entirely by setting `config.active_record.disable_implicit_join_references = true`. (called from designations_received? at /home/travis/build/Liaison-Intl/WebAdMIT/app/models/applicant.rb:941)

[32m.[0mDEPRECATION WARNING: It looks like you are eager loading table(s) (one of: scoring_models, scoring_model_assignments, programs) that are referenced in a string SQL snippet. For example:



    Post.includes(:comments).where("comments.title = 'foo'")



Currently, Active Record recognizes the table in the string, and knows to JOIN the comments table to the query, rather than loading comments in a separate query. However, doing this without writing a full-blown SQL parser is inherently flawed. Since we don't want to write an SQL parser, we are removing this functionality. From now on, you must explicitly tell Active Record when you are referencing a table from a string:



    Post.includes(:comments).where("comments.title = 'foo'").references(:comments)



If you don't rely on implicit join references you can disable the feature entirely by setting `config.active_record.disable_implicit_join_references = true`. (called from score_for_scoring_models at /home/travis/build/Liaison-Intl/WebAdMIT/app/models/scoring/scorer.rb:50)

DEPRECATION WARNING: It looks like you are eager loading table(s) (one of: designations, programs, user_identity_programs) that are referenced in a string SQL snippet. For example:



    Post.includes(:comments).where("comments.title = 'foo'")



Currently, Active Record recognizes the table in the string, and knows to JOIN the comments table to the query, rather than loading comments in a separate query. However, doing this without writing a full-blown SQL parser is inherently flawed. Since we don't want to write an SQL parser, we are removing this functionality. From now on, you must explicitly tell Active Record when you are referencing a table from a string:



    Post.includes(:comments).where("comments.title = 'foo'").references(:comments)



If you don't rely on implicit join references you can disable the feature entirely by setting `config.active_record.disable_implicit_join_references = true`. (called from designations_received? at /home/travis/build/Liaison-Intl/WebAdMIT/app/models/applicant.rb:941)

[32m.[0mDEPRECATION WARNING: It looks like you are eager loading table(s) (one of: scoring_models, scoring_model_assignments, programs) that are referenced in a string SQL snippet. For example:



    Post.includes(:comments).where("comments.title = 'foo'")



Currently, Active Record recognizes the table in the string, and knows to JOIN the comments table to the query, rather than loading comments in a separate query. However, doing this without writing a full-blown SQL parser is inherently flawed. Since we don't want to write an SQL parser, we are removing this functionality. From now on, you must explicitly tell Active Record when you are referencing a table from a string:



    Post.includes(:comments).where("comments.title = 'foo'").references(:comments)



If you don't rely on implicit join references you can disable the feature entirely by setting `config.active_record.disable_implicit_join_references = true`. (called from score_for_scoring_models at /home/travis/build/Liaison-Intl/WebAdMIT/app/models/scoring/scorer.rb:50)

DEPRECATION WARNING: It looks like you are eager loading table(s) (one of: designations, programs, user_identity_programs) that are referenced in a string SQL snippet. For example:



    Post.includes(:comments).where("comments.title = 'foo'")



Currently, Active Record recognizes the table in the string, and knows to JOIN the comments table to the query, rather than loading comments in a separate query. However, doing this without writing a full-blown SQL parser is inherently flawed. Since we don't want to write an SQL parser, we are removing this functionality. From now on, you must explicitly tell Active Record when you are referencing a table from a string:



    Post.includes(:comments).where("comments.title = 'foo'").references(:comments)



If you don't rely on implicit join references you can disable the feature entirely by setting `config.active_record.disable_implicit_join_references = true`. (called from designations_received? at /home/travis/build/Liaison-Intl/WebAdMIT/app/models/applicant.rb:941)

[32m.[0mDEPRECATION WARNING: It looks like you are eager loading table(s) (one of: scoring_models, scoring_model_assignments, programs) that are referenced in a string SQL snippet. For example:



    Post.includes(:comments).where("comments.title = 'foo'")



Currently, Active Record recognizes the table in the string, and knows to JOIN the comments table to the query, rather than loading comments in a separate query. However, doing this without writing a full-blown SQL parser is inherently flawed. Since we don't want to write an SQL parser, we are removing this functionality. From now on, you must explicitly tell Active Record when you are referencing a table from a string:



    Post.includes(:comments).where("comments.title = 'foo'").references(:comments)



If you don't rely on implicit join references you can disable the feature entirely by setting `config.active_record.disable_implicit_join_references = true`. (called from score_for_scoring_models at /home/travis/build/Liaison-Intl/WebAdMIT/app/models/scoring/scorer.rb:50)

DEPRECATION WARNING: It looks like you are eager loading table(s) (one of: designations, programs, user_identity_programs) that are referenced in a string SQL snippet. For example:



    Post.includes(:comments).where("comments.title = 'foo'")



Currently, Active Record recognizes the table in the string, and knows to JOIN the comments table to the query, rather than loading comments in a separate query. However, doing this without writing a full-blown SQL parser is inherently flawed. Since we don't want to write an SQL parser, we are removing this functionality. From now on, you must explicitly tell Active Record when you are referencing a table from a string:



    Post.includes(:comments).where("comments.title = 'foo'").references(:comments)



If you don't rely on implicit join references you can disable the feature entirely by setting `config.active_record.disable_implicit_join_references = true`. (called from designations_received? at /home/travis/build/Liaison-Intl/WebAdMIT/app/models/applicant.rb:941)

[32m.[0mDEPRECATION WARNING: It looks like you are eager loading table(s) (one of: scoring_models, scoring_model_assignments, programs) that are referenced in a string SQL snippet. For example:



    Post.includes(:comments).where("comments.title = 'foo'")



Currently, Active Record recognizes the table in the string, and knows to JOIN the comments table to the query, rather than loading comments in a separate query. However, doing this without writing a full-blown SQL parser is inherently flawed. Since we don't want to write an SQL parser, we are removing this functionality. From now on, you must explicitly tell Active Record when you are referencing a table from a string:



    Post.includes(:comments).where("comments.title = 'foo'").references(:comments)



If you don't rely on implicit join references you can disable the feature entirely by setting `config.active_record.disable_implicit_join_references = true`. (called from score_for_scoring_models at /home/travis/build/Liaison-Intl/WebAdMIT/app/models/scoring/scorer.rb:50)

DEPRECATION WARNING: It looks like you are eager loading table(s) (one of: designations, programs, user_identity_programs) that are referenced in a string SQL snippet. For example:



    Post.includes(:comments).where("comments.title = 'foo'")



Currently, Active Record recognizes the table in the string, and knows to JOIN the comments table to the query, rather than loading comments in a separate query. However, doing this without writing a full-blown SQL parser is inherently flawed. Since we don't want to write an SQL parser, we are removing this functionality. From now on, you must explicitly tell Active Record when you are referencing a table from a string:



    Post.includes(:comments).where("comments.title = 'foo'").references(:comments)



If you don't rely on implicit join references you can disable the feature entirely by setting `config.active_record.disable_implicit_join_references = true`. (called from designations_received? at /home/travis/build/Liaison-Intl/WebAdMIT/app/models/applicant.rb:941)

[32m.[0m[32m.[0m[32m.[0m[32m.[0mDEPRECATION WARNING: Relation#all is deprecated. If you want to eager-load a relation, you can call #load (e.g. `Post.where(published: true).load`). If you want to get an array of records from a relation, you can call #to_a (e.g. `Post.where(published: true).to_a`). (called from _app_views_reports_files__form_html_haml___1464073540288648491_263052100 at /home/travis/build/Liaison-Intl/WebAdMIT/app/views/reports/files/_form.html.haml:48)

[32m.[0mDEPRECATION WARNING: It looks like you are eager loading table(s) (one of: scoring_models, scoring_model_assignments, programs) that are referenced in a string SQL snippet. For example:



    Post.includes(:comments).where("comments.title = 'foo'")



Currently, Active Record recognizes the table in the string, and knows to JOIN the comments table to the query, rather than loading comments in a separate query. However, doing this without writing a full-blown SQL parser is inherently flawed. Since we don't want to write an SQL parser, we are removing this functionality. From now on, you must explicitly tell Active Record when you are referencing a table from a string:



    Post.includes(:comments).where("comments.title = 'foo'").references(:comments)



If you don't rely on implicit join references you can disable the feature entirely by setting `config.active_record.disable_implicit_join_references = true`. (called from score_for_scoring_models at /home/travis/build/Liaison-Intl/WebAdMIT/app/models/scoring/scorer.rb:50)

[32m.[0m[32m.[0mDEPRECATION WARNING: It looks like you are eager loading table(s) (one of: scoring_models, scoring_model_assignments, programs) that are referenced in a string SQL snippet. For example:



    Post.includes(:comments).where("comments.title = 'foo'")



Currently, Active Record recognizes the table in the string, and knows to JOIN the comments table to the query, rather than loading comments in a separate query. However, doing this without writing a full-blown SQL parser is inherently flawed. Since we don't want to write an SQL parser, we are removing this functionality. From now on, you must explicitly tell Active Record when you are referencing a table from a string:



    Post.includes(:comments).where("comments.title = 'foo'").references(:comments)



If you don't rely on implicit join references you can disable the feature entirely by setting `config.active_record.disable_implicit_join_references = true`. (called from score_for_scoring_models at /home/travis/build/Liaison-Intl/WebAdMIT/app/models/scoring/scorer.rb:50)

DEPRECATION WARNING: It looks like you are eager loading table(s) (one of: designations, programs, user_identity_programs) that are referenced in a string SQL snippet. For example:



    Post.includes(:comments).where("comments.title = 'foo'")



Currently, Active Record recognizes the table in the string, and knows to JOIN the comments table to the query, rather than loading comments in a separate query. However, doing this without writing a full-blown SQL parser is inherently flawed. Since we don't want to write an SQL parser, we are removing this functionality. From now on, you must explicitly tell Active Record when you are referencing a table from a string:



    Post.includes(:comments).where("comments.title = 'foo'").references(:comments)



If you don't rely on implicit join references you can disable the feature entirely by setting `config.active_record.disable_implicit_join_references = true`. (called from designations_received? at /home/travis/build/Liaison-Intl/WebAdMIT/app/models/applicant.rb:941)

DEPRECATION WARNING: dom_id method will no longer be included by default in controllers since Rails 4.1. If you would like to use it in controllers, please include ActionView::RecordIdentifier module. (called from test_receipt_control at /home/travis/build/Liaison-Intl/WebAdMIT/app/helpers/applicants/standardized_tests_helper.rb:27)

DEPRECATION WARNING: dom_id method will no longer be included by default in controllers since Rails 4.1. If you would like to use it in controllers, please include ActionView::RecordIdentifier module. (called from test_receipt_control at /home/travis/build/Liaison-Intl/WebAdMIT/app/helpers/applicants/standardized_tests_helper.rb:31)

[32m.[0mDEPRECATION WARNING: It looks like you are eager loading table(s) (one of: scoring_models, scoring_model_assignments, programs) that are referenced in a string SQL snippet. For example:



    Post.includes(:comments).where("comments.title = 'foo'")



Currently, Active Record recognizes the table in the string, and knows to JOIN the comments table to the query, rather than loading comments in a separate query. However, doing this without writing a full-blown SQL parser is inherently flawed. Since we don't want to write an SQL parser, we are removing this functionality. From now on, you must explicitly tell Active Record when you are referencing a table from a string:



    Post.includes(:comments).where("comments.title = 'foo'").references(:comments)



If you don't rely on implicit join references you can disable the feature entirely by setting `config.active_record.disable_implicit_join_references = true`. (called from score_for_scoring_models at /home/travis/build/Liaison-Intl/WebAdMIT/app/models/scoring/scorer.rb:50)

DEPRECATION WARNING: It looks like you are eager loading table(s) (one of: designations, programs, user_identity_programs) that are referenced in a string SQL snippet. For example:



    Post.includes(:comments).where("comments.title = 'foo'")



Currently, Active Record recognizes the table in the string, and knows to JOIN the comments table to the query, rather than loading comments in a separate query. However, doing this without writing a full-blown SQL parser is inherently flawed. Since we don't want to write an SQL parser, we are removing this functionality. From now on, you must explicitly tell Active Record when you are referencing a table from a string:



    Post.includes(:comments).where("comments.title = 'foo'").references(:comments)



If you don't rely on implicit join references you can disable the feature entirely by setting `config.active_record.disable_implicit_join_references = true`. (called from designations_received? at /home/travis/build/Liaison-Intl/WebAdMIT/app/models/applicant.rb:941)

DEPRECATION WARNING: dom_id method will no longer be included by default in controllers since Rails 4.1. If you would like to use it in controllers, please include ActionView::RecordIdentifier module. (called from test_receipt_control at /home/travis/build/Liaison-Intl/WebAdMIT/app/helpers/applicants/standardized_tests_helper.rb:27)

DEPRECATION WARNING: dom_id method will no longer be included by default in controllers since Rails 4.1. If you would like to use it in controllers, please include ActionView::RecordIdentifier module. (called from test_receipt_control at /home/travis/build/Liaison-Intl/WebAdMIT/app/helpers/applicants/standardized_tests_helper.rb:31)

DEPRECATION WARNING: dom_id method will no longer be included by default in controllers since Rails 4.1. If you would like to use it in controllers, please include ActionView::RecordIdentifier module. (called from test_receipt_control at /home/travis/build/Liaison-Intl/WebAdMIT/app/helpers/applicants/standardized_tests_helper.rb:27)

DEPRECATION WARNING: dom_id method will no longer be included by default in controllers since Rails 4.1. If you would like to use it in controllers, please include ActionView::RecordIdentifier module. (called from test_receipt_control at /home/travis/build/Liaison-Intl/WebAdMIT/app/helpers/applicants/standardized_tests_helper.rb:31)

[32m.[0mDEPRECATION WARNING: It looks like you are eager loading table(s) (one of: scoring_models, scoring_model_assignments, programs) that are referenced in a string SQL snippet. For example:



    Post.includes(:comments).where("comments.title = 'foo'")



Currently, Active Record recognizes the table in the string, and knows to JOIN the comments table to the query, rather than loading comments in a separate query. However, doing this without writing a full-blown SQL parser is inherently flawed. Since we don't want to write an SQL parser, we are removing this functionality. From now on, you must explicitly tell Active Record when you are referencing a table from a string:



    Post.includes(:comments).where("comments.title = 'foo'").references(:comments)



If you don't rely on implicit join references you can disable the feature entirely by setting `config.active_record.disable_implicit_join_references = true`. (called from score_for_scoring_models at /home/travis/build/Liaison-Intl/WebAdMIT/app/models/scoring/scorer.rb:50)

DEPRECATION WARNING: It looks like you are eager loading table(s) (one of: designations, programs, user_identity_programs) that are referenced in a string SQL snippet. For example:



    Post.includes(:comments).where("comments.title = 'foo'")



Currently, Active Record recognizes the table in the string, and knows to JOIN the comments table to the query, rather than loading comments in a separate query. However, doing this without writing a full-blown SQL parser is inherently flawed. Since we don't want to write an SQL parser, we are removing this functionality. From now on, you must explicitly tell Active Record when you are referencing a table from a string:



    Post.includes(:comments).where("comments.title = 'foo'").references(:comments)



If you don't rely on implicit join references you can disable the feature entirely by setting `config.active_record.disable_implicit_join_references = true`. (called from designations_received? at /home/travis/build/Liaison-Intl/WebAdMIT/app/models/applicant.rb:941)

DEPRECATION WARNING: dom_id method will no longer be included by default in controllers since Rails 4.1. If you would like to use it in controllers, please include ActionView::RecordIdentifier module. (called from test_receipt_control at /home/travis/build/Liaison-Intl/WebAdMIT/app/helpers/applicants/standardized_tests_helper.rb:27)

DEPRECATION WARNING: dom_id method will no longer be included by default in controllers since Rails 4.1. If you would like to use it in controllers, please include ActionView::RecordIdentifier module. (called from test_receipt_control at /home/travis/build/Liaison-Intl/WebAdMIT/app/helpers/applicants/standardized_tests_helper.rb:31)

[32m.[0mDEPRECATION WARNING: It looks like you are eager loading table(s) (one of: scoring_models, scoring_model_assignments, programs) that are referenced in a string SQL snippet. For example:



    Post.includes(:comments).where("comments.title = 'foo'")



Currently, Active Record recognizes the table in the string, and knows to JOIN the comments table to the query, rather than loading comments in a separate query. However, doing this without writing a full-blown SQL parser is inherently flawed. Since we don't want to write an SQL parser, we are removing this functionality. From now on, you must explicitly tell Active Record when you are referencing a table from a string:



    Post.includes(:comments).where("comments.title = 'foo'").references(:comments)



If you don't rely on implicit join references you can disable the feature entirely by setting `config.active_record.disable_implicit_join_references = true`. (called from score_for_scoring_models at /home/travis/build/Liaison-Intl/WebAdMIT/app/models/scoring/scorer.rb:50)

DEPRECATION WARNING: It looks like you are eager loading table(s) (one of: designations, programs, user_identity_programs) that are referenced in a string SQL snippet. For example:



    Post.includes(:comments).where("comments.title = 'foo'")



Currently, Active Record recognizes the table in the string, and knows to JOIN the comments table to the query, rather than loading comments in a separate query. However, doing this without writing a full-blown SQL parser is inherently flawed. Since we don't want to write an SQL parser, we are removing this functionality. From now on, you must explicitly tell Active Record when you are referencing a table from a string:



    Post.includes(:comments).where("comments.title = 'foo'").references(:comments)



If you don't rely on implicit join references you can disable the feature entirely by setting `config.active_record.disable_implicit_join_references = true`. (called from designations_received? at /home/travis/build/Liaison-Intl/WebAdMIT/app/models/applicant.rb:941)

DEPRECATION WARNING: dom_id method will no longer be included by default in controllers since Rails 4.1. If you would like to use it in controllers, please include ActionView::RecordIdentifier module. (called from test_receipt_control at /home/travis/build/Liaison-Intl/WebAdMIT/app/helpers/applicants/standardized_tests_helper.rb:27)

DEPRECATION WARNING: dom_id method will no longer be included by default in controllers since Rails 4.1. If you would like to use it in controllers, please include ActionView::RecordIdentifier module. (called from test_receipt_control at /home/travis/build/Liaison-Intl/WebAdMIT/app/helpers/applicants/standardized_tests_helper.rb:31)

DEPRECATION WARNING: It looks like you are eager loading table(s) (one of: designations, programs, user_identity_programs) that are referenced in a string SQL snippet. For example:



    Post.includes(:comments).where("comments.title = 'foo'")



Currently, Active Record recognizes the table in the string, and knows to JOIN the comments table to the query, rather than loading comments in a separate query. However, doing this without writing a full-blown SQL parser is inherently flawed. Since we don't want to write an SQL parser, we are removing this functionality. From now on, you must explicitly tell Active Record when you are referencing a table from a string:



    Post.includes(:comments).where("comments.title = 'foo'").references(:comments)



If you don't rely on implicit join references you can disable the feature entirely by setting `config.active_record.disable_implicit_join_references = true`. (called from designations_received? at /home/travis/build/Liaison-Intl/WebAdMIT/app/models/applicant.rb:941)

DEPRECATION WARNING: dom_id method will no longer be included by default in controllers since Rails 4.1. If you would like to use it in controllers, please include ActionView::RecordIdentifier module. (called from test_receipt_control at /home/travis/build/Liaison-Intl/WebAdMIT/app/helpers/applicants/standardized_tests_helper.rb:27)

DEPRECATION WARNING: dom_id method will no longer be included by default in controllers since Rails 4.1. If you would like to use it in controllers, please include ActionView::RecordIdentifier module. (called from test_receipt_control at /home/travis/build/Liaison-Intl/WebAdMIT/app/helpers/applicants/standardized_tests_helper.rb:31)

[32m.[0mDEPRECATION WARNING: It looks like you are eager loading table(s) (one of: scoring_models, scoring_model_assignments, programs) that are referenced in a string SQL snippet. For example:



    Post.includes(:comments).where("comments.title = 'foo'")



Currently, Active Record recognizes the table in the string, and knows to JOIN the comments table to the query, rather than loading comments in a separate query. However, doing this without writing a full-blown SQL parser is inherently flawed. Since we don't want to write an SQL parser, we are removing this functionality. From now on, you must explicitly tell Active Record when you are referencing a table from a string:



    Post.includes(:comments).where("comments.title = 'foo'").references(:comments)



If you don't rely on implicit join references you can disable the feature entirely by setting `config.active_record.disable_implicit_join_references = true`. (called from score_for_scoring_models at /home/travis/build/Liaison-Intl/WebAdMIT/app/models/scoring/scorer.rb:50)

DEPRECATION WARNING: It looks like you are eager loading table(s) (one of: designations, programs, user_identity_programs) that are referenced in a string SQL snippet. For example:



    Post.includes(:comments).where("comments.title = 'foo'")



Currently, Active Record recognizes the table in the string, and knows to JOIN the comments table to the query, rather than loading comments in a separate query. However, doing this without writing a full-blown SQL parser is inherently flawed. Since we don't want to write an SQL parser, we are removing this functionality. From now on, you must explicitly tell Active Record when you are referencing a table from a string:



    Post.includes(:comments).where("comments.title = 'foo'").references(:comments)



If you don't rely on implicit join references you can disable the feature entirely by setting `config.active_record.disable_implicit_join_references = true`. (called from designations_received? at /home/travis/build/Liaison-Intl/WebAdMIT/app/models/applicant.rb:941)

DEPRECATION WARNING: dom_id method will no longer be included by default in controllers since Rails 4.1. If you would like to use it in controllers, please include ActionView::RecordIdentifier module. (called from test_receipt_control at /home/travis/build/Liaison-Intl/WebAdMIT/app/helpers/applicants/standardized_tests_helper.rb:27)

DEPRECATION WARNING: dom_id method will no longer be included by default in controllers since Rails 4.1. If you would like to use it in controllers, please include ActionView::RecordIdentifier module. (called from test_receipt_control at /home/travis/build/Liaison-Intl/WebAdMIT/app/helpers/applicants/standardized_tests_helper.rb:31)

[32m.[0mDEPRECATION WARNING: It looks like you are eager loading table(s) (one of: scoring_models, scoring_model_assignments, programs) that are referenced in a string SQL snippet. For example:



    Post.includes(:comments).where("comments.title = 'foo'")



Currently, Active Record recognizes the table in the string, and knows to JOIN the comments table to the query, rather than loading comments in a separate query. However, doing this without writing a full-blown SQL parser is inherently flawed. Since we don't want to write an SQL parser, we are removing this functionality. From now on, you must explicitly tell Active Record when you are referencing a table from a string:



    Post.includes(:comments).where("comments.title = 'foo'").references(:comments)



If you don't rely on implicit join references you can disable the feature entirely by setting `config.active_record.disable_implicit_join_references = true`. (called from score_for_scoring_models at /home/travis/build/Liaison-Intl/WebAdMIT/app/models/scoring/scorer.rb:50)

DEPRECATION WARNING: It looks like you are eager loading table(s) (one of: designations, programs, user_identity_programs) that are referenced in a string SQL snippet. For example:



    Post.includes(:comments).where("comments.title = 'foo'")



Currently, Active Record recognizes the table in the string, and knows to JOIN the comments table to the query, rather than loading comments in a separate query. However, doing this without writing a full-blown SQL parser is inherently flawed. Since we don't want to write an SQL parser, we are removing this functionality. From now on, you must explicitly tell Active Record when you are referencing a table from a string:



    Post.includes(:comments).where("comments.title = 'foo'").references(:comments)



If you don't rely on implicit join references you can disable the feature entirely by setting `config.active_record.disable_implicit_join_references = true`. (called from designations_received? at /home/travis/build/Liaison-Intl/WebAdMIT/app/models/applicant.rb:941)

DEPRECATION WARNING: dom_id method will no longer be included by default in controllers since Rails 4.1. If you would like to use it in controllers, please include ActionView::RecordIdentifier module. (called from test_receipt_control at /home/travis/build/Liaison-Intl/WebAdMIT/app/helpers/applicants/standardized_tests_helper.rb:27)

DEPRECATION WARNING: dom_id method will no longer be included by default in controllers since Rails 4.1. If you would like to use it in controllers, please include ActionView::RecordIdentifier module. (called from test_receipt_control at /home/travis/build/Liaison-Intl/WebAdMIT/app/helpers/applicants/standardized_tests_helper.rb:31)

[32m.[0mDEPRECATION WARNING: It looks like you are eager loading table(s) (one of: scoring_models, scoring_model_assignments, programs) that are referenced in a string SQL snippet. For example:



    Post.includes(:comments).where("comments.title = 'foo'")



Currently, Active Record recognizes the table in the string, and knows to JOIN the comments table to the query, rather than loading comments in a separate query. However, doing this without writing a full-blown SQL parser is inherently flawed. Since we don't want to write an SQL parser, we are removing this functionality. From now on, you must explicitly tell Active Record when you are referencing a table from a string:



    Post.includes(:comments).where("comments.title = 'foo'").references(:comments)



If you don't rely on implicit join references you can disable the feature entirely by setting `config.active_record.disable_implicit_join_references = true`. (called from score_for_scoring_models at /home/travis/build/Liaison-Intl/WebAdMIT/app/models/scoring/scorer.rb:50)

DEPRECATION WARNING: It looks like you are eager loading table(s) (one of: designations, programs, user_identity_programs) that are referenced in a string SQL snippet. For example:



    Post.includes(:comments).where("comments.title = 'foo'")



Currently, Active Record recognizes the table in the string, and knows to JOIN the comments table to the query, rather than loading comments in a separate query. However, doing this without writing a full-blown SQL parser is inherently flawed. Since we don't want to write an SQL parser, we are removing this functionality. From now on, you must explicitly tell Active Record when you are referencing a table from a string:



    Post.includes(:comments).where("comments.title = 'foo'").references(:comments)



If you don't rely on implicit join references you can disable the feature entirely by setting `config.active_record.disable_implicit_join_references = true`. (called from designations_received? at /home/travis/build/Liaison-Intl/WebAdMIT/app/models/applicant.rb:941)

DEPRECATION WARNING: dom_id method will no longer be included by default in controllers since Rails 4.1. If you would like to use it in controllers, please include ActionView::RecordIdentifier module. (called from test_receipt_control at /home/travis/build/Liaison-Intl/WebAdMIT/app/helpers/applicants/standardized_tests_helper.rb:27)

DEPRECATION WARNING: dom_id method will no longer be included by default in controllers since Rails 4.1. If you would like to use it in controllers, please include ActionView::RecordIdentifier module. (called from test_receipt_control at /home/travis/build/Liaison-Intl/WebAdMIT/app/helpers/applicants/standardized_tests_helper.rb:31)

DEPRECATION WARNING: dom_id method will no longer be included by default in controllers since Rails 4.1. If you would like to use it in controllers, please include ActionView::RecordIdentifier module. (called from test_receipt_control at /home/travis/build/Liaison-Intl/WebAdMIT/app/helpers/applicants/standardized_tests_helper.rb:27)

DEPRECATION WARNING: dom_id method will no longer be included by default in controllers since Rails 4.1. If you would like to use it in controllers, please include ActionView::RecordIdentifier module. (called from test_receipt_control at /home/travis/build/Liaison-Intl/WebAdMIT/app/helpers/applicants/standardized_tests_helper.rb:31)

[32m.[0mDEPRECATION WARNING: It looks like you are eager loading table(s) (one of: scoring_models, scoring_model_assignments, programs) that are referenced in a string SQL snippet. For example:



    Post.includes(:comments).where("comments.title = 'foo'")



Currently, Active Record recognizes the table in the string, and knows to JOIN the comments table to the query, rather than loading comments in a separate query. However, doing this without writing a full-blown SQL parser is inherently flawed. Since we don't want to write an SQL parser, we are removing this functionality. From now on, you must explicitly tell Active Record when you are referencing a table from a string:



    Post.includes(:comments).where("comments.title = 'foo'").references(:comments)



If you don't rely on implicit join references you can disable the feature entirely by setting `config.active_record.disable_implicit_join_references = true`. (called from score_for_scoring_models at /home/travis/build/Liaison-Intl/WebAdMIT/app/models/scoring/scorer.rb:50)

DEPRECATION WARNING: It looks like you are eager loading table(s) (one of: designations, programs, user_identity_programs) that are referenced in a string SQL snippet. For example:



    Post.includes(:comments).where("comments.title = 'foo'")



Currently, Active Record recognizes the table in the string, and knows to JOIN the comments table to the query, rather than loading comments in a separate query. However, doing this without writing a full-blown SQL parser is inherently flawed. Since we don't want to write an SQL parser, we are removing this functionality. From now on, you must explicitly tell Active Record when you are referencing a table from a string:



    Post.includes(:comments).where("comments.title = 'foo'").references(:comments)



If you don't rely on implicit join references you can disable the feature entirely by setting `config.active_record.disable_implicit_join_references = true`. (called from designations_received? at /home/travis/build/Liaison-Intl/WebAdMIT/app/models/applicant.rb:941)

DEPRECATION WARNING: dom_id method will no longer be included by default in controllers since Rails 4.1. If you would like to use it in controllers, please include ActionView::RecordIdentifier module. (called from test_receipt_control at /home/travis/build/Liaison-Intl/WebAdMIT/app/helpers/applicants/standardized_tests_helper.rb:27)

DEPRECATION WARNING: dom_id method will no longer be included by default in controllers since Rails 4.1. If you would like to use it in controllers, please include ActionView::RecordIdentifier module. (called from test_receipt_control at /home/travis/build/Liaison-Intl/WebAdMIT/app/helpers/applicants/standardized_tests_helper.rb:31)

[32m.[0mDEPRECATION WARNING: It looks like you are eager loading table(s) (one of: scoring_models, scoring_model_assignments, programs) that are referenced in a string SQL snippet. For example:



    Post.includes(:comments).where("comments.title = 'foo'")



Currently, Active Record recognizes the table in the string, and knows to JOIN the comments table to the query, rather than loading comments in a separate query. However, doing this without writing a full-blown SQL parser is inherently flawed. Since we don't want to write an SQL parser, we are removing this functionality. From now on, you must explicitly tell Active Record when you are referencing a table from a string:



    Post.includes(:comments).where("comments.title = 'foo'").references(:comments)



If you don't rely on implicit join references you can disable the feature entirely by setting `config.active_record.disable_implicit_join_references = true`. (called from score_for_scoring_models at /home/travis/build/Liaison-Intl/WebAdMIT/app/models/scoring/scorer.rb:50)

DEPRECATION WARNING: It looks like you are eager loading table(s) (one of: designations, programs, user_identity_programs) that are referenced in a string SQL snippet. For example:



    Post.includes(:comments).where("comments.title = 'foo'")



Currently, Active Record recognizes the table in the string, and knows to JOIN the comments table to the query, rather than loading comments in a separate query. However, doing this without writing a full-blown SQL parser is inherently flawed. Since we don't want to write an SQL parser, we are removing this functionality. From now on, you must explicitly tell Active Record when you are referencing a table from a string:



    Post.includes(:comments).where("comments.title = 'foo'").references(:comments)



If you don't rely on implicit join references you can disable the feature entirely by setting `config.active_record.disable_implicit_join_references = true`. (called from designations_received? at /home/travis/build/Liaison-Intl/WebAdMIT/app/models/applicant.rb:941)

DEPRECATION WARNING: dom_id method will no longer be included by default in controllers since Rails 4.1. If you would like to use it in controllers, please include ActionView::RecordIdentifier module. (called from test_receipt_control at /home/travis/build/Liaison-Intl/WebAdMIT/app/helpers/applicants/standardized_tests_helper.rb:27)

DEPRECATION WARNING: dom_id method will no longer be included by default in controllers since Rails 4.1. If you would like to use it in controllers, please include ActionView::RecordIdentifier module. (called from test_receipt_control at /home/travis/build/Liaison-Intl/WebAdMIT/app/helpers/applicants/standardized_tests_helper.rb:31)

DEPRECATION WARNING: It looks like you are eager loading table(s) (one of: designations, programs, user_identity_programs) that are referenced in a string SQL snippet. For example:



    Post.includes(:comments).where("comments.title = 'foo'")



Currently, Active Record recognizes the table in the string, and knows to JOIN the comments table to the query, rather than loading comments in a separate query. However, doing this without writing a full-blown SQL parser is inherently flawed. Since we don't want to write an SQL parser, we are removing this functionality. From now on, you must explicitly tell Active Record when you are referencing a table from a string:



    Post.includes(:comments).where("comments.title = 'foo'").references(:comments)



If you don't rely on implicit join references you can disable the feature entirely by setting `config.active_record.disable_implicit_join_references = true`. (called from designations_received? at /home/travis/build/Liaison-Intl/WebAdMIT/app/models/applicant.rb:941)

DEPRECATION WARNING: dom_id method will no longer be included by default in controllers since Rails 4.1. If you would like to use it in controllers, please include ActionView::RecordIdentifier module. (called from test_receipt_control at /home/travis/build/Liaison-Intl/WebAdMIT/app/helpers/applicants/standardized_tests_helper.rb:27)

DEPRECATION WARNING: dom_id method will no longer be included by default in controllers since Rails 4.1. If you would like to use it in controllers, please include ActionView::RecordIdentifier module. (called from test_receipt_control at /home/travis/build/Liaison-Intl/WebAdMIT/app/helpers/applicants/standardized_tests_helper.rb:31)

[32m.[0mDEPRECATION WARNING: It looks like you are eager loading table(s) (one of: scoring_models, scoring_model_assignments, programs) that are referenced in a string SQL snippet. For example:



    Post.includes(:comments).where("comments.title = 'foo'")



Currently, Active Record recognizes the table in the string, and knows to JOIN the comments table to the query, rather than loading comments in a separate query. However, doing this without writing a full-blown SQL parser is inherently flawed. Since we don't want to write an SQL parser, we are removing this functionality. From now on, you must explicitly tell Active Record when you are referencing a table from a string:



    Post.includes(:comments).where("comments.title = 'foo'").references(:comments)



If you don't rely on implicit join references you can disable the feature entirely by setting `config.active_record.disable_implicit_join_references = true`. (called from score_for_scoring_models at /home/travis/build/Liaison-Intl/WebAdMIT/app/models/scoring/scorer.rb:50)

DEPRECATION WARNING: It looks like you are eager loading table(s) (one of: designations, programs, user_identity_programs) that are referenced in a string SQL snippet. For example:



    Post.includes(:comments).where("comments.title = 'foo'")



Currently, Active Record recognizes the table in the string, and knows to JOIN the comments table to the query, rather than loading comments in a separate query. However, doing this without writing a full-blown SQL parser is inherently flawed. Since we don't want to write an SQL parser, we are removing this functionality. From now on, you must explicitly tell Active Record when you are referencing a table from a string:



    Post.includes(:comments).where("comments.title = 'foo'").references(:comments)



If you don't rely on implicit join references you can disable the feature entirely by setting `config.active_record.disable_implicit_join_references = true`. (called from designations_received? at /home/travis/build/Liaison-Intl/WebAdMIT/app/models/applicant.rb:941)

[32m.[0mDEPRECATION WARNING: It looks like you are eager loading table(s) (one of: scoring_models, scoring_model_assignments, programs) that are referenced in a string SQL snippet. For example:



    Post.includes(:comments).where("comments.title = 'foo'")



Currently, Active Record recognizes the table in the string, and knows to JOIN the comments table to the query, rather than loading comments in a separate query. However, doing this without writing a full-blown SQL parser is inherently flawed. Since we don't want to write an SQL parser, we are removing this functionality. From now on, you must explicitly tell Active Record when you are referencing a table from a string:



    Post.includes(:comments).where("comments.title = 'foo'").references(:comments)



If you don't rely on implicit join references you can disable the feature entirely by setting `config.active_record.disable_implicit_join_references = true`. (called from score_for_scoring_models at /home/travis/build/Liaison-Intl/WebAdMIT/app/models/scoring/scorer.rb:50)

DEPRECATION WARNING: It looks like you are eager loading table(s) (one of: designations, programs, user_identity_programs) that are referenced in a string SQL snippet. For example:



    Post.includes(:comments).where("comments.title = 'foo'")



Currently, Active Record recognizes the table in the string, and knows to JOIN the comments table to the query, rather than loading comments in a separate query. However, doing this without writing a full-blown SQL parser is inherently flawed. Since we don't want to write an SQL parser, we are removing this functionality. From now on, you must explicitly tell Active Record when you are referencing a table from a string:



    Post.includes(:comments).where("comments.title = 'foo'").references(:comments)



If you don't rely on implicit join references you can disable the feature entirely by setting `config.active_record.disable_implicit_join_references = true`. (called from designations_received? at /home/travis/build/Liaison-Intl/WebAdMIT/app/models/applicant.rb:941)

[32m.[0mDEPRECATION WARNING: It looks like you are eager loading table(s) (one of: scoring_models, scoring_model_assignments, programs) that are referenced in a string SQL snippet. For example:



    Post.includes(:comments).where("comments.title = 'foo'")



Currently, Active Record recognizes the table in the string, and knows to JOIN the comments table to the query, rather than loading comments in a separate query. However, doing this without writing a full-blown SQL parser is inherently flawed. Since we don't want to write an SQL parser, we are removing this functionality. From now on, you must explicitly tell Active Record when you are referencing a table from a string:



    Post.includes(:comments).where("comments.title = 'foo'").references(:comments)



If you don't rely on implicit join references you can disable the feature entirely by setting `config.active_record.disable_implicit_join_references = true`. (called from score_for_scoring_models at /home/travis/build/Liaison-Intl/WebAdMIT/app/models/scoring/scorer.rb:50)

DEPRECATION WARNING: It looks like you are eager loading table(s) (one of: designations, programs, user_identity_programs) that are referenced in a string SQL snippet. For example:



    Post.includes(:comments).where("comments.title = 'foo'")



Currently, Active Record recognizes the table in the string, and knows to JOIN the comments table to the query, rather than loading comments in a separate query. However, doing this without writing a full-blown SQL parser is inherently flawed. Since we don't want to write an SQL parser, we are removing this functionality. From now on, you must explicitly tell Active Record when you are referencing a table from a string:



    Post.includes(:comments).where("comments.title = 'foo'").references(:comments)



If you don't rely on implicit join references you can disable the feature entirely by setting `config.active_record.disable_implicit_join_references = true`. (called from designations_received? at /home/travis/build/Liaison-Intl/WebAdMIT/app/models/applicant.rb:941)

[32m.[0mDEPRECATION WARNING: It looks like you are eager loading table(s) (one of: scoring_models, scoring_model_assignments, programs) that are referenced in a string SQL snippet. For example:



    Post.includes(:comments).where("comments.title = 'foo'")



Currently, Active Record recognizes the table in the string, and knows to JOIN the comments table to the query, rather than loading comments in a separate query. However, doing this without writing a full-blown SQL parser is inherently flawed. Since we don't want to write an SQL parser, we are removing this functionality. From now on, you must explicitly tell Active Record when you are referencing a table from a string:



    Post.includes(:comments).where("comments.title = 'foo'").references(:comments)



If you don't rely on implicit join references you can disable the feature entirely by setting `config.active_record.disable_implicit_join_references = true`. (called from score_for_scoring_models at /home/travis/build/Liaison-Intl/WebAdMIT/app/models/scoring/scorer.rb:50)

DEPRECATION WARNING: It looks like you are eager loading table(s) (one of: designations, programs, user_identity_programs) that are referenced in a string SQL snippet. For example:



    Post.includes(:comments).where("comments.title = 'foo'")



Currently, Active Record recognizes the table in the string, and knows to JOIN the comments table to the query, rather than loading comments in a separate query. However, doing this without writing a full-blown SQL parser is inherently flawed. Since we don't want to write an SQL parser, we are removing this functionality. From now on, you must explicitly tell Active Record when you are referencing a table from a string:



    Post.includes(:comments).where("comments.title = 'foo'").references(:comments)



If you don't rely on implicit join references you can disable the feature entirely by setting `config.active_record.disable_implicit_join_references = true`. (called from designations_received? at /home/travis/build/Liaison-Intl/WebAdMIT/app/models/applicant.rb:941)

DEPRECATION WARNING: It looks like you are eager loading table(s) (one of: designations, programs, user_identity_programs) that are referenced in a string SQL snippet. For example:



    Post.includes(:comments).where("comments.title = 'foo'")



Currently, Active Record recognizes the table in the string, and knows to JOIN the comments table to the query, rather than loading comments in a separate query. However, doing this without writing a full-blown SQL parser is inherently flawed. Since we don't want to write an SQL parser, we are removing this functionality. From now on, you must explicitly tell Active Record when you are referencing a table from a string:



    Post.includes(:comments).where("comments.title = 'foo'").references(:comments)



If you don't rely on implicit join references you can disable the feature entirely by setting `config.active_record.disable_implicit_join_references = true`. (called from designations_received? at /home/travis/build/Liaison-Intl/WebAdMIT/app/models/applicant.rb:941)

[32m.[0mDEPRECATION WARNING: It looks like you are eager loading table(s) (one of: scoring_models, scoring_model_assignments, programs) that are referenced in a string SQL snippet. For example:



    Post.includes(:comments).where("comments.title = 'foo'")



Currently, Active Record recognizes the table in the string, and knows to JOIN the comments table to the query, rather than loading comments in a separate query. However, doing this without writing a full-blown SQL parser is inherently flawed. Since we don't want to write an SQL parser, we are removing this functionality. From now on, you must explicitly tell Active Record when you are referencing a table from a string:



    Post.includes(:comments).where("comments.title = 'foo'").references(:comments)



If you don't rely on implicit join references you can disable the feature entirely by setting `config.active_record.disable_implicit_join_references = true`. (called from score_for_scoring_models at /home/travis/build/Liaison-Intl/WebAdMIT/app/models/scoring/scorer.rb:50)

DEPRECATION WARNING: It looks like you are eager loading table(s) (one of: designations, programs, user_identity_programs) that are referenced in a string SQL snippet. For example:



    Post.includes(:comments).where("comments.title = 'foo'")



Currently, Active Record recognizes the table in the string, and knows to JOIN the comments table to the query, rather than loading comments in a separate query. However, doing this without writing a full-blown SQL parser is inherently flawed. Since we don't want to write an SQL parser, we are removing this functionality. From now on, you must explicitly tell Active Record when you are referencing a table from a string:



    Post.includes(:comments).where("comments.title = 'foo'").references(:comments)



If you don't rely on implicit join references you can disable the feature entirely by setting `config.active_record.disable_implicit_join_references = true`. (called from designations_received? at /home/travis/build/Liaison-Intl/WebAdMIT/app/models/applicant.rb:941)

[32m.[0mDEPRECATION WARNING: It looks like you are eager loading table(s) (one of: scoring_models, scoring_model_assignments, programs) that are referenced in a string SQL snippet. For example:



    Post.includes(:comments).where("comments.title = 'foo'")



Currently, Active Record recognizes the table in the string, and knows to JOIN the comments table to the query, rather than loading comments in a separate query. However, doing this without writing a full-blown SQL parser is inherently flawed. Since we don't want to write an SQL parser, we are removing this functionality. From now on, you must explicitly tell Active Record when you are referencing a table from a string:



    Post.includes(:comments).where("comments.title = 'foo'").references(:comments)



If you don't rely on implicit join references you can disable the feature entirely by setting `config.active_record.disable_implicit_join_references = true`. (called from score_for_scoring_models at /home/travis/build/Liaison-Intl/WebAdMIT/app/models/scoring/scorer.rb:50)

DEPRECATION WARNING: It looks like you are eager loading table(s) (one of: designations, programs, user_identity_programs) that are referenced in a string SQL snippet. For example:



    Post.includes(:comments).where("comments.title = 'foo'")



Currently, Active Record recognizes the table in the string, and knows to JOIN the comments table to the query, rather than loading comments in a separate query. However, doing this without writing a full-blown SQL parser is inherently flawed. Since we don't want to write an SQL parser, we are removing this functionality. From now on, you must explicitly tell Active Record when you are referencing a table from a string:



    Post.includes(:comments).where("comments.title = 'foo'").references(:comments)



If you don't rely on implicit join references you can disable the feature entirely by setting `config.active_record.disable_implicit_join_references = true`. (called from designations_received? at /home/travis/build/Liaison-Intl/WebAdMIT/app/models/applicant.rb:941)

[32m.[0mDEPRECATION WARNING: It looks like you are eager loading table(s) (one of: scoring_models, scoring_model_assignments, programs) that are referenced in a string SQL snippet. For example:



    Post.includes(:comments).where("comments.title = 'foo'")



Currently, Active Record recognizes the table in the string, and knows to JOIN the comments table to the query, rather than loading comments in a separate query. However, doing this without writing a full-blown SQL parser is inherently flawed. Since we don't want to write an SQL parser, we are removing this functionality. From now on, you must explicitly tell Active Record when you are referencing a table from a string:



    Post.includes(:comments).where("comments.title = 'foo'").references(:comments)



If you don't rely on implicit join references you can disable the feature entirely by setting `config.active_record.disable_implicit_join_references = true`. (called from score_for_scoring_models at /home/travis/build/Liaison-Intl/WebAdMIT/app/models/scoring/scorer.rb:50)

DEPRECATION WARNING: It looks like you are eager loading table(s) (one of: designations, programs, user_identity_programs) that are referenced in a string SQL snippet. For example:



    Post.includes(:comments).where("comments.title = 'foo'")



Currently, Active Record recognizes the table in the string, and knows to JOIN the comments table to the query, rather than loading comments in a separate query. However, doing this without writing a full-blown SQL parser is inherently flawed. Since we don't want to write an SQL parser, we are removing this functionality. From now on, you must explicitly tell Active Record when you are referencing a table from a string:



    Post.includes(:comments).where("comments.title = 'foo'").references(:comments)



If you don't rely on implicit join references you can disable the feature entirely by setting `config.active_record.disable_implicit_join_references = true`. (called from designations_received? at /home/travis/build/Liaison-Intl/WebAdMIT/app/models/applicant.rb:941)

[32m.[0mDEPRECATION WARNING: It looks like you are eager loading table(s) (one of: scoring_models, scoring_model_assignments, programs) that are referenced in a string SQL snippet. For example:



    Post.includes(:comments).where("comments.title = 'foo'")



Currently, Active Record recognizes the table in the string, and knows to JOIN the comments table to the query, rather than loading comments in a separate query. However, doing this without writing a full-blown SQL parser is inherently flawed. Since we don't want to write an SQL parser, we are removing this functionality. From now on, you must explicitly tell Active Record when you are referencing a table from a string:



    Post.includes(:comments).where("comments.title = 'foo'").references(:comments)



If you don't rely on implicit join references you can disable the feature entirely by setting `config.active_record.disable_implicit_join_references = true`. (called from score_for_scoring_models at /home/travis/build/Liaison-Intl/WebAdMIT/app/models/scoring/scorer.rb:50)

DEPRECATION WARNING: It looks like you are eager loading table(s) (one of: designations, programs, user_identity_programs) that are referenced in a string SQL snippet. For example:



    Post.includes(:comments).where("comments.title = 'foo'")



Currently, Active Record recognizes the table in the string, and knows to JOIN the comments table to the query, rather than loading comments in a separate query. However, doing this without writing a full-blown SQL parser is inherently flawed. Since we don't want to write an SQL parser, we are removing this functionality. From now on, you must explicitly tell Active Record when you are referencing a table from a string:



    Post.includes(:comments).where("comments.title = 'foo'").references(:comments)



If you don't rely on implicit join references you can disable the feature entirely by setting `config.active_record.disable_implicit_join_references = true`. (called from designations_received? at /home/travis/build/Liaison-Intl/WebAdMIT/app/models/applicant.rb:941)

DEPRECATION WARNING: It looks like you are eager loading table(s) (one of: designations, programs, user_identity_programs) that are referenced in a string SQL snippet. For example:



    Post.includes(:comments).where("comments.title = 'foo'")



Currently, Active Record recognizes the table in the string, and knows to JOIN the comments table to the query, rather than loading comments in a separate query. However, doing this without writing a full-blown SQL parser is inherently flawed. Since we don't want to write an SQL parser, we are removing this functionality. From now on, you must explicitly tell Active Record when you are referencing a table from a string:



    Post.includes(:comments).where("comments.title = 'foo'").references(:comments)



If you don't rely on implicit join references you can disable the feature entirely by setting `config.active_record.disable_implicit_join_references = true`. (called from designations_received? at /home/travis/build/Liaison-Intl/WebAdMIT/app/models/applicant.rb:941)

[32m.[0mDEPRECATION WARNING: It looks like you are eager loading table(s) (one of: scoring_models, scoring_model_assignments, programs) that are referenced in a string SQL snippet. For example:



    Post.includes(:comments).where("comments.title = 'foo'")



Currently, Active Record recognizes the table in the string, and knows to JOIN the comments table to the query, rather than loading comments in a separate query. However, doing this without writing a full-blown SQL parser is inherently flawed. Since we don't want to write an SQL parser, we are removing this functionality. From now on, you must explicitly tell Active Record when you are referencing a table from a string:



    Post.includes(:comments).where("comments.title = 'foo'").references(:comments)



If you don't rely on implicit join references you can disable the feature entirely by setting `config.active_record.disable_implicit_join_references = true`. (called from score_for_scoring_models at /home/travis/build/Liaison-Intl/WebAdMIT/app/models/scoring/scorer.rb:50)

DEPRECATION WARNING: It looks like you are eager loading table(s) (one of: designations, programs, user_identity_programs) that are referenced in a string SQL snippet. For example:



    Post.includes(:comments).where("comments.title = 'foo'")



Currently, Active Record recognizes the table in the string, and knows to JOIN the comments table to the query, rather than loading comments in a separate query. However, doing this without writing a full-blown SQL parser is inherently flawed. Since we don't want to write an SQL parser, we are removing this functionality. From now on, you must explicitly tell Active Record when you are referencing a table from a string:



    Post.includes(:comments).where("comments.title = 'foo'").references(:comments)



If you don't rely on implicit join references you can disable the feature entirely by setting `config.active_record.disable_implicit_join_references = true`. (called from designations_received? at /home/travis/build/Liaison-Intl/WebAdMIT/app/models/applicant.rb:941)

[32m.[0mDEPRECATION WARNING: It looks like you are eager loading table(s) (one of: scoring_models, scoring_model_assignments, programs) that are referenced in a string SQL snippet. For example:



    Post.includes(:comments).where("comments.title = 'foo'")



Currently, Active Record recognizes the table in the string, and knows to JOIN the comments table to the query, rather than loading comments in a separate query. However, doing this without writing a full-blown SQL parser is inherently flawed. Since we don't want to write an SQL parser, we are removing this functionality. From now on, you must explicitly tell Active Record when you are referencing a table from a string:



    Post.includes(:comments).where("comments.title = 'foo'").references(:comments)



If you don't rely on implicit join references you can disable the feature entirely by setting `config.active_record.disable_implicit_join_references = true`. (called from score_for_scoring_models at /home/travis/build/Liaison-Intl/WebAdMIT/app/models/scoring/scorer.rb:50)

DEPRECATION WARNING: It looks like you are eager loading table(s) (one of: designations, programs, user_identity_programs) that are referenced in a string SQL snippet. For example:



    Post.includes(:comments).where("comments.title = 'foo'")



Currently, Active Record recognizes the table in the string, and knows to JOIN the comments table to the query, rather than loading comments in a separate query. However, doing this without writing a full-blown SQL parser is inherently flawed. Since we don't want to write an SQL parser, we are removing this functionality. From now on, you must explicitly tell Active Record when you are referencing a table from a string:



    Post.includes(:comments).where("comments.title = 'foo'").references(:comments)



If you don't rely on implicit join references you can disable the feature entirely by setting `config.active_record.disable_implicit_join_references = true`. (called from designations_received? at /home/travis/build/Liaison-Intl/WebAdMIT/app/models/applicant.rb:941)

[32m.[0mDEPRECATION WARNING: It looks like you are eager loading table(s) (one of: scoring_models, scoring_model_assignments, programs) that are referenced in a string SQL snippet. For example:



    Post.includes(:comments).where("comments.title = 'foo'")



Currently, Active Record recognizes the table in the string, and knows to JOIN the comments table to the query, rather than loading comments in a separate query. However, doing this without writing a full-blown SQL parser is inherently flawed. Since we don't want to write an SQL parser, we are removing this functionality. From now on, you must explicitly tell Active Record when you are referencing a table from a string:



    Post.includes(:comments).where("comments.title = 'foo'").references(:comments)



If you don't rely on implicit join references you can disable the feature entirely by setting `config.active_record.disable_implicit_join_references = true`. (called from score_for_scoring_models at /home/travis/build/Liaison-Intl/WebAdMIT/app/models/scoring/scorer.rb:50)

DEPRECATION WARNING: It looks like you are eager loading table(s) (one of: designations, programs, user_identity_programs) that are referenced in a string SQL snippet. For example:



    Post.includes(:comments).where("comments.title = 'foo'")



Currently, Active Record recognizes the table in the string, and knows to JOIN the comments table to the query, rather than loading comments in a separate query. However, doing this without writing a full-blown SQL parser is inherently flawed. Since we don't want to write an SQL parser, we are removing this functionality. From now on, you must explicitly tell Active Record when you are referencing a table from a string:



    Post.includes(:comments).where("comments.title = 'foo'").references(:comments)



If you don't rely on implicit join references you can disable the feature entirely by setting `config.active_record.disable_implicit_join_references = true`. (called from designations_received? at /home/travis/build/Liaison-Intl/WebAdMIT/app/models/applicant.rb:941)

[32m.[0mDEPRECATION WARNING: It looks like you are eager loading table(s) (one of: scoring_models, scoring_model_assignments, programs) that are referenced in a string SQL snippet. For example:



    Post.includes(:comments).where("comments.title = 'foo'")



Currently, Active Record recognizes the table in the string, and knows to JOIN the comments table to the query, rather than loading comments in a separate query. However, doing this without writing a full-blown SQL parser is inherently flawed. Since we don't want to write an SQL parser, we are removing this functionality. From now on, you must explicitly tell Active Record when you are referencing a table from a string:



    Post.includes(:comments).where("comments.title = 'foo'").references(:comments)



If you don't rely on implicit join references you can disable the feature entirely by setting `config.active_record.disable_implicit_join_references = true`. (called from score_for_scoring_models at /home/travis/build/Liaison-Intl/WebAdMIT/app/models/scoring/scorer.rb:50)

DEPRECATION WARNING: It looks like you are eager loading table(s) (one of: designations, programs, user_identity_programs) that are referenced in a string SQL snippet. For example:



    Post.includes(:comments).where("comments.title = 'foo'")



Currently, Active Record recognizes the table in the string, and knows to JOIN the comments table to the query, rather than loading comments in a separate query. However, doing this without writing a full-blown SQL parser is inherently flawed. Since we don't want to write an SQL parser, we are removing this functionality. From now on, you must explicitly tell Active Record when you are referencing a table from a string:



    Post.includes(:comments).where("comments.title = 'foo'").references(:comments)



If you don't rely on implicit join references you can disable the feature entirely by setting `config.active_record.disable_implicit_join_references = true`. (called from designations_received? at /home/travis/build/Liaison-Intl/WebAdMIT/app/models/applicant.rb:941)

DEPRECATION WARNING: It looks like you are eager loading table(s) (one of: designations, programs, user_identity_programs) that are referenced in a string SQL snippet. For example:



    Post.includes(:comments).where("comments.title = 'foo'")



Currently, Active Record recognizes the table in the string, and knows to JOIN the comments table to the query, rather than loading comments in a separate query. However, doing this without writing a full-blown SQL parser is inherently flawed. Since we don't want to write an SQL parser, we are removing this functionality. From now on, you must explicitly tell Active Record when you are referencing a table from a string:



    Post.includes(:comments).where("comments.title = 'foo'").references(:comments)



If you don't rely on implicit join references you can disable the feature entirely by setting `config.active_record.disable_implicit_join_references = true`. (called from designations_received? at /home/travis/build/Liaison-Intl/WebAdMIT/app/models/applicant.rb:941)

[32m.[0mDEPRECATION WARNING: It looks like you are eager loading table(s) (one of: scoring_models, scoring_model_assignments, programs) that are referenced in a string SQL snippet. For example:



    Post.includes(:comments).where("comments.title = 'foo'")



Currently, Active Record recognizes the table in the string, and knows to JOIN the comments table to the query, rather than loading comments in a separate query. However, doing this without writing a full-blown SQL parser is inherently flawed. Since we don't want to write an SQL parser, we are removing this functionality. From now on, you must explicitly tell Active Record when you are referencing a table from a string:



    Post.includes(:comments).where("comments.title = 'foo'").references(:comments)



If you don't rely on implicit join references you can disable the feature entirely by setting `config.active_record.disable_implicit_join_references = true`. (called from score_for_scoring_models at /home/travis/build/Liaison-Intl/WebAdMIT/app/models/scoring/scorer.rb:50)

DEPRECATION WARNING: It looks like you are eager loading table(s) (one of: designations, programs, user_identity_programs) that are referenced in a string SQL snippet. For example:



    Post.includes(:comments).where("comments.title = 'foo'")



Currently, Active Record recognizes the table in the string, and knows to JOIN the comments table to the query, rather than loading comments in a separate query. However, doing this without writing a full-blown SQL parser is inherently flawed. Since we don't want to write an SQL parser, we are removing this functionality. From now on, you must explicitly tell Active Record when you are referencing a table from a string:



    Post.includes(:comments).where("comments.title = 'foo'").references(:comments)



If you don't rely on implicit join references you can disable the feature entirely by setting `config.active_record.disable_implicit_join_references = true`. (called from designations_received? at /home/travis/build/Liaison-Intl/WebAdMIT/app/models/applicant.rb:941)

[32m.[0mDEPRECATION WARNING: It looks like you are eager loading table(s) (one of: scoring_models, scoring_model_assignments, programs) that are referenced in a string SQL snippet. For example:



    Post.includes(:comments).where("comments.title = 'foo'")



Currently, Active Record recognizes the table in the string, and knows to JOIN the comments table to the query, rather than loading comments in a separate query. However, doing this without writing a full-blown SQL parser is inherently flawed. Since we don't want to write an SQL parser, we are removing this functionality. From now on, you must explicitly tell Active Record when you are referencing a table from a string:



    Post.includes(:comments).where("comments.title = 'foo'").references(:comments)



If you don't rely on implicit join references you can disable the feature entirely by setting `config.active_record.disable_implicit_join_references = true`. (called from score_for_scoring_models at /home/travis/build/Liaison-Intl/WebAdMIT/app/models/scoring/scorer.rb:50)

DEPRECATION WARNING: It looks like you are eager loading table(s) (one of: designations, programs, user_identity_programs) that are referenced in a string SQL snippet. For example:



    Post.includes(:comments).where("comments.title = 'foo'")



Currently, Active Record recognizes the table in the string, and knows to JOIN the comments table to the query, rather than loading comments in a separate query. However, doing this without writing a full-blown SQL parser is inherently flawed. Since we don't want to write an SQL parser, we are removing this functionality. From now on, you must explicitly tell Active Record when you are referencing a table from a string:



    Post.includes(:comments).where("comments.title = 'foo'").references(:comments)



If you don't rely on implicit join references you can disable the feature entirely by setting `config.active_record.disable_implicit_join_references = true`. (called from designations_received? at /home/travis/build/Liaison-Intl/WebAdMIT/app/models/applicant.rb:941)

[32m.[0mDEPRECATION WARNING: It looks like you are eager loading table(s) (one of: scoring_models, scoring_model_assignments, programs) that are referenced in a string SQL snippet. For example:



    Post.includes(:comments).where("comments.title = 'foo'")



Currently, Active Record recognizes the table in the string, and knows to JOIN the comments table to the query, rather than loading comments in a separate query. However, doing this without writing a full-blown SQL parser is inherently flawed. Since we don't want to write an SQL parser, we are removing this functionality. From now on, you must explicitly tell Active Record when you are referencing a table from a string:



    Post.includes(:comments).where("comments.title = 'foo'").references(:comments)



If you don't rely on implicit join references you can disable the feature entirely by setting `config.active_record.disable_implicit_join_references = true`. (called from score_for_scoring_models at /home/travis/build/Liaison-Intl/WebAdMIT/app/models/scoring/scorer.rb:50)

DEPRECATION WARNING: It looks like you are eager loading table(s) (one of: designations, programs, user_identity_programs) that are referenced in a string SQL snippet. For example:



    Post.includes(:comments).where("comments.title = 'foo'")



Currently, Active Record recognizes the table in the string, and knows to JOIN the comments table to the query, rather than loading comments in a separate query. However, doing this without writing a full-blown SQL parser is inherently flawed. Since we don't want to write an SQL parser, we are removing this functionality. From now on, you must explicitly tell Active Record when you are referencing a table from a string:



    Post.includes(:comments).where("comments.title = 'foo'").references(:comments)



If you don't rely on implicit join references you can disable the feature entirely by setting `config.active_record.disable_implicit_join_references = true`. (called from designations_received? at /home/travis/build/Liaison-Intl/WebAdMIT/app/models/applicant.rb:941)

DEPRECATION WARNING: It looks like you are eager loading table(s) (one of: designations, programs, user_identity_programs) that are referenced in a string SQL snippet. For example:



    Post.includes(:comments).where("comments.title = 'foo'")



Currently, Active Record recognizes the table in the string, and knows to JOIN the comments table to the query, rather than loading comments in a separate query. However, doing this without writing a full-blown SQL parser is inherently flawed. Since we don't want to write an SQL parser, we are removing this functionality. From now on, you must explicitly tell Active Record when you are referencing a table from a string:



    Post.includes(:comments).where("comments.title = 'foo'").references(:comments)



If you don't rely on implicit join references you can disable the feature entirely by setting `config.active_record.disable_implicit_join_references = true`. (called from designations_received? at /home/travis/build/Liaison-Intl/WebAdMIT/app/models/applicant.rb:941)

[32m.[0mDEPRECATION WARNING: It looks like you are eager loading table(s) (one of: scoring_models, scoring_model_assignments, programs) that are referenced in a string SQL snippet. For example:



    Post.includes(:comments).where("comments.title = 'foo'")



Currently, Active Record recognizes the table in the string, and knows to JOIN the comments table to the query, rather than loading comments in a separate query. However, doing this without writing a full-blown SQL parser is inherently flawed. Since we don't want to write an SQL parser, we are removing this functionality. From now on, you must explicitly tell Active Record when you are referencing a table from a string:



    Post.includes(:comments).where("comments.title = 'foo'").references(:comments)



If you don't rely on implicit join references you can disable the feature entirely by setting `config.active_record.disable_implicit_join_references = true`. (called from score_for_scoring_models at /home/travis/build/Liaison-Intl/WebAdMIT/app/models/scoring/scorer.rb:50)

DEPRECATION WARNING: It looks like you are eager loading table(s) (one of: scoring_models, scoring_model_assignments, programs) that are referenced in a string SQL snippet. For example:



    Post.includes(:comments).where("comments.title = 'foo'")



Currently, Active Record recognizes the table in the string, and knows to JOIN the comments table to the query, rather than loading comments in a separate query. However, doing this without writing a full-blown SQL parser is inherently flawed. Since we don't want to write an SQL parser, we are removing this functionality. From now on, you must explicitly tell Active Record when you are referencing a table from a string:



    Post.includes(:comments).where("comments.title = 'foo'").references(:comments)



If you don't rely on implicit join references you can disable the feature entirely by setting `config.active_record.disable_implicit_join_references = true`. (called from score_for_scoring_models at /home/travis/build/Liaison-Intl/WebAdMIT/app/models/scoring/scorer.rb:50)

DEPRECATION WARNING: It looks like you are eager loading table(s) (one of: designations, programs, user_identity_programs) that are referenced in a string SQL snippet. For example:



    Post.includes(:comments).where("comments.title = 'foo'")



Currently, Active Record recognizes the table in the string, and knows to JOIN the comments table to the query, rather than loading comments in a separate query. However, doing this without writing a full-blown SQL parser is inherently flawed. Since we don't want to write an SQL parser, we are removing this functionality. From now on, you must explicitly tell Active Record when you are referencing a table from a string:



    Post.includes(:comments).where("comments.title = 'foo'").references(:comments)



If you don't rely on implicit join references you can disable the feature entirely by setting `config.active_record.disable_implicit_join_references = true`. (called from designations_received? at /home/travis/build/Liaison-Intl/WebAdMIT/app/models/applicant.rb:941)

[32m.[0mDEPRECATION WARNING: It looks like you are eager loading table(s) (one of: scoring_models, scoring_model_assignments, programs) that are referenced in a string SQL snippet. For example:



    Post.includes(:comments).where("comments.title = 'foo'")



Currently, Active Record recognizes the table in the string, and knows to JOIN the comments table to the query, rather than loading comments in a separate query. However, doing this without writing a full-blown SQL parser is inherently flawed. Since we don't want to write an SQL parser, we are removing this functionality. From now on, you must explicitly tell Active Record when you are referencing a table from a string:



    Post.includes(:comments).where("comments.title = 'foo'").references(:comments)



If you don't rely on implicit join references you can disable the feature entirely by setting `config.active_record.disable_implicit_join_references = true`. (called from score_for_scoring_models at /home/travis/build/Liaison-Intl/WebAdMIT/app/models/scoring/scorer.rb:50)

DEPRECATION WARNING: It looks like you are eager loading table(s) (one of: scoring_models, scoring_model_assignments, programs) that are referenced in a string SQL snippet. For example:



    Post.includes(:comments).where("comments.title = 'foo'")



Currently, Active Record recognizes the table in the string, and knows to JOIN the comments table to the query, rather than loading comments in a separate query. However, doing this without writing a full-blown SQL parser is inherently flawed. Since we don't want to write an SQL parser, we are removing this functionality. From now on, you must explicitly tell Active Record when you are referencing a table from a string:



    Post.includes(:comments).where("comments.title = 'foo'").references(:comments)



If you don't rely on implicit join references you can disable the feature entirely by setting `config.active_record.disable_implicit_join_references = true`. (called from score_for_scoring_models at /home/travis/build/Liaison-Intl/WebAdMIT/app/models/scoring/scorer.rb:50)

DEPRECATION WARNING: It looks like you are eager loading table(s) (one of: designations, programs, user_identity_programs) that are referenced in a string SQL snippet. For example:



    Post.includes(:comments).where("comments.title = 'foo'")



Currently, Active Record recognizes the table in the string, and knows to JOIN the comments table to the query, rather than loading comments in a separate query. However, doing this without writing a full-blown SQL parser is inherently flawed. Since we don't want to write an SQL parser, we are removing this functionality. From now on, you must explicitly tell Active Record when you are referencing a table from a string:



    Post.includes(:comments).where("comments.title = 'foo'").references(:comments)



If you don't rely on implicit join references you can disable the feature entirely by setting `config.active_record.disable_implicit_join_references = true`. (called from designations_received? at /home/travis/build/Liaison-Intl/WebAdMIT/app/models/applicant.rb:941)

[32m.[0mDEPRECATION WARNING: It looks like you are eager loading table(s) (one of: scoring_models, scoring_model_assignments, programs) that are referenced in a string SQL snippet. For example:



    Post.includes(:comments).where("comments.title = 'foo'")



Currently, Active Record recognizes the table in the string, and knows to JOIN the comments table to the query, rather than loading comments in a separate query. However, doing this without writing a full-blown SQL parser is inherently flawed. Since we don't want to write an SQL parser, we are removing this functionality. From now on, you must explicitly tell Active Record when you are referencing a table from a string:



    Post.includes(:comments).where("comments.title = 'foo'").references(:comments)



If you don't rely on implicit join references you can disable the feature entirely by setting `config.active_record.disable_implicit_join_references = true`. (called from score_for_scoring_models at /home/travis/build/Liaison-Intl/WebAdMIT/app/models/scoring/scorer.rb:50)

DEPRECATION WARNING: It looks like you are eager loading table(s) (one of: scoring_models, scoring_model_assignments, programs) that are referenced in a string SQL snippet. For example:



    Post.includes(:comments).where("comments.title = 'foo'")



Currently, Active Record recognizes the table in the string, and knows to JOIN the comments table to the query, rather than loading comments in a separate query. However, doing this without writing a full-blown SQL parser is inherently flawed. Since we don't want to write an SQL parser, we are removing this functionality. From now on, you must explicitly tell Active Record when you are referencing a table from a string:



    Post.includes(:comments).where("comments.title = 'foo'").references(:comments)



If you don't rely on implicit join references you can disable the feature entirely by setting `config.active_record.disable_implicit_join_references = true`. (called from score_for_scoring_models at /home/travis/build/Liaison-Intl/WebAdMIT/app/models/scoring/scorer.rb:50)

DEPRECATION WARNING: It looks like you are eager loading table(s) (one of: designations, programs, user_identity_programs) that are referenced in a string SQL snippet. For example:



    Post.includes(:comments).where("comments.title = 'foo'")



Currently, Active Record recognizes the table in the string, and knows to JOIN the comments table to the query, rather than loading comments in a separate query. However, doing this without writing a full-blown SQL parser is inherently flawed. Since we don't want to write an SQL parser, we are removing this functionality. From now on, you must explicitly tell Active Record when you are referencing a table from a string:



    Post.includes(:comments).where("comments.title = 'foo'").references(:comments)



If you don't rely on implicit join references you can disable the feature entirely by setting `config.active_record.disable_implicit_join_references = true`. (called from designations_received? at /home/travis/build/Liaison-Intl/WebAdMIT/app/models/applicant.rb:941)

[32m.[0mDEPRECATION WARNING: It looks like you are eager loading table(s) (one of: scoring_models, scoring_model_assignments, programs) that are referenced in a string SQL snippet. For example:



    Post.includes(:comments).where("comments.title = 'foo'")



Currently, Active Record recognizes the table in the string, and knows to JOIN the comments table to the query, rather than loading comments in a separate query. However, doing this without writing a full-blown SQL parser is inherently flawed. Since we don't want to write an SQL parser, we are removing this functionality. From now on, you must explicitly tell Active Record when you are referencing a table from a string:



    Post.includes(:comments).where("comments.title = 'foo'").references(:comments)



If you don't rely on implicit join references you can disable the feature entirely by setting `config.active_record.disable_implicit_join_references = true`. (called from score_for_scoring_models at /home/travis/build/Liaison-Intl/WebAdMIT/app/models/scoring/scorer.rb:50)

DEPRECATION WARNING: It looks like you are eager loading table(s) (one of: scoring_models, scoring_model_assignments, programs) that are referenced in a string SQL snippet. For example:



    Post.includes(:comments).where("comments.title = 'foo'")



Currently, Active Record recognizes the table in the string, and knows to JOIN the comments table to the query, rather than loading comments in a separate query. However, doing this without writing a full-blown SQL parser is inherently flawed. Since we don't want to write an SQL parser, we are removing this functionality. From now on, you must explicitly tell Active Record when you are referencing a table from a string:



    Post.includes(:comments).where("comments.title = 'foo'").references(:comments)



If you don't rely on implicit join references you can disable the feature entirely by setting `config.active_record.disable_implicit_join_references = true`. (called from score_for_scoring_models at /home/travis/build/Liaison-Intl/WebAdMIT/app/models/scoring/scorer.rb:50)

DEPRECATION WARNING: It looks like you are eager loading table(s) (one of: designations, programs, user_identity_programs) that are referenced in a string SQL snippet. For example:



    Post.includes(:comments).where("comments.title = 'foo'")



Currently, Active Record recognizes the table in the string, and knows to JOIN the comments table to the query, rather than loading comments in a separate query. However, doing this without writing a full-blown SQL parser is inherently flawed. Since we don't want to write an SQL parser, we are removing this functionality. From now on, you must explicitly tell Active Record when you are referencing a table from a string:



    Post.includes(:comments).where("comments.title = 'foo'").references(:comments)



If you don't rely on implicit join references you can disable the feature entirely by setting `config.active_record.disable_implicit_join_references = true`. (called from designations_received? at /home/travis/build/Liaison-Intl/WebAdMIT/app/models/applicant.rb:941)

[32m.[0m[32m.[0mDEPRECATION WARNING: It looks like you are eager loading table(s) (one of: requirements, criteria) that are referenced in a string SQL snippet. For example:



    Post.includes(:comments).where("comments.title = 'foo'")



Currently, Active Record recognizes the table in the string, and knows to JOIN the comments table to the query, rather than loading comments in a separate query. However, doing this without writing a full-blown SQL parser is inherently flawed. Since we don't want to write an SQL parser, we are removing this functionality. From now on, you must explicitly tell Active Record when you are referencing a table from a string:



    Post.includes(:comments).where("comments.title = 'foo'").references(:comments)



If you don't rely on implicit join references you can disable the feature entirely by setting `config.active_record.disable_implicit_join_references = true`. (called from block in _app_views_requirements_index_html_haml__4490160196590661920_171876180 at /home/travis/build/Liaison-Intl/WebAdMIT/app/views/requirements/index.html.haml:12)

DEPRECATION WARNING: It looks like you are eager loading table(s) (one of: requirements, criteria) that are referenced in a string SQL snippet. For example:



    Post.includes(:comments).where("comments.title = 'foo'")



Currently, Active Record recognizes the table in the string, and knows to JOIN the comments table to the query, rather than loading comments in a separate query. However, doing this without writing a full-blown SQL parser is inherently flawed. Since we don't want to write an SQL parser, we are removing this functionality. From now on, you must explicitly tell Active Record when you are referencing a table from a string:



    Post.includes(:comments).where("comments.title = 'foo'").references(:comments)



If you don't rely on implicit join references you can disable the feature entirely by setting `config.active_record.disable_implicit_join_references = true`. (called from _app_views_requirements_index_html_haml__4490160196590661920_171876180 at /home/travis/build/Liaison-Intl/WebAdMIT/app/views/requirements/index.html.haml:17)

DEPRECATION WARNING: It looks like you are eager loading table(s) (one of: requirements, criteria) that are referenced in a string SQL snippet. For example:



    Post.includes(:comments).where("comments.title = 'foo'")



Currently, Active Record recognizes the table in the string, and knows to JOIN the comments table to the query, rather than loading comments in a separate query. However, doing this without writing a full-blown SQL parser is inherently flawed. Since we don't want to write an SQL parser, we are removing this functionality. From now on, you must explicitly tell Active Record when you are referencing a table from a string:



    Post.includes(:comments).where("comments.title = 'foo'").references(:comments)



If you don't rely on implicit join references you can disable the feature entirely by setting `config.active_record.disable_implicit_join_references = true`. (called from block in _app_views_requirements_index_html_haml__4490160196590661920_171876180 at /home/travis/build/Liaison-Intl/WebAdMIT/app/views/requirements/index.html.haml:12)

DEPRECATION WARNING: Relation#all is deprecated. If you want to eager-load a relation, you can call #load (e.g. `Post.where(published: true).load`). If you want to get an array of records from a relation, you can call #to_a (e.g. `Post.where(published: true).to_a`). (called from _app_views_requirements__requirement_html_haml__2195224900444059847_285679960 at /home/travis/build/Liaison-Intl/WebAdMIT/app/views/requirements/_requirement.html.haml:34)

DEPRECATION WARNING: It looks like you are eager loading table(s) (one of: requirements, criteria) that are referenced in a string SQL snippet. For example:



    Post.includes(:comments).where("comments.title = 'foo'")



Currently, Active Record recognizes the table in the string, and knows to JOIN the comments table to the query, rather than loading comments in a separate query. However, doing this without writing a full-blown SQL parser is inherently flawed. Since we don't want to write an SQL parser, we are removing this functionality. From now on, you must explicitly tell Active Record when you are referencing a table from a string:



    Post.includes(:comments).where("comments.title = 'foo'").references(:comments)



If you don't rely on implicit join references you can disable the feature entirely by setting `config.active_record.disable_implicit_join_references = true`. (called from _app_views_requirements_index_html_haml__4490160196590661920_171876180 at /home/travis/build/Liaison-Intl/WebAdMIT/app/views/requirements/index.html.haml:17)

DEPRECATION WARNING: It looks like you are eager loading table(s) (one of: requirements, criteria) that are referenced in a string SQL snippet. For example:



    Post.includes(:comments).where("comments.title = 'foo'")



Currently, Active Record recognizes the table in the string, and knows to JOIN the comments table to the query, rather than loading comments in a separate query. However, doing this without writing a full-blown SQL parser is inherently flawed. Since we don't want to write an SQL parser, we are removing this functionality. From now on, you must explicitly tell Active Record when you are referencing a table from a string:



    Post.includes(:comments).where("comments.title = 'foo'").references(:comments)



If you don't rely on implicit join references you can disable the feature entirely by setting `config.active_record.disable_implicit_join_references = true`. (called from find_requirement at /home/travis/build/Liaison-Intl/WebAdMIT/app/controllers/requirements_controller.rb:103)

DEPRECATION WARNING: It looks like you are eager loading table(s) (one of: requirements, criteria) that are referenced in a string SQL snippet. For example:



    Post.includes(:comments).where("comments.title = 'foo'")



Currently, Active Record recognizes the table in the string, and knows to JOIN the comments table to the query, rather than loading comments in a separate query. However, doing this without writing a full-blown SQL parser is inherently flawed. Since we don't want to write an SQL parser, we are removing this functionality. From now on, you must explicitly tell Active Record when you are referencing a table from a string:



    Post.includes(:comments).where("comments.title = 'foo'").references(:comments)



If you don't rely on implicit join references you can disable the feature entirely by setting `config.active_record.disable_implicit_join_references = true`. (called from find_requirement at /home/travis/build/Liaison-Intl/WebAdMIT/app/controllers/requirements_controller.rb:103)

DEPRECATION WARNING: It looks like you are eager loading table(s) (one of: requirements, criteria) that are referenced in a string SQL snippet. For example:



    Post.includes(:comments).where("comments.title = 'foo'")



Currently, Active Record recognizes the table in the string, and knows to JOIN the comments table to the query, rather than loading comments in a separate query. However, doing this without writing a full-blown SQL parser is inherently flawed. Since we don't want to write an SQL parser, we are removing this functionality. From now on, you must explicitly tell Active Record when you are referencing a table from a string:



    Post.includes(:comments).where("comments.title = 'foo'").references(:comments)



If you don't rely on implicit join references you can disable the feature entirely by setting `config.active_record.disable_implicit_join_references = true`. (called from block in _app_views_requirements_index_html_haml__4490160196590661920_171876180 at /home/travis/build/Liaison-Intl/WebAdMIT/app/views/requirements/index.html.haml:12)

DEPRECATION WARNING: Relation#all is deprecated. If you want to eager-load a relation, you can call #load (e.g. `Post.where(published: true).load`). If you want to get an array of records from a relation, you can call #to_a (e.g. `Post.where(published: true).to_a`). (called from _app_views_requirements__requirement_html_haml__2195224900444059847_285679960 at /home/travis/build/Liaison-Intl/WebAdMIT/app/views/requirements/_requirement.html.haml:34)

DEPRECATION WARNING: It looks like you are eager loading table(s) (one of: requirements, criteria) that are referenced in a string SQL snippet. For example:



    Post.includes(:comments).where("comments.title = 'foo'")



Currently, Active Record recognizes the table in the string, and knows to JOIN the comments table to the query, rather than loading comments in a separate query. However, doing this without writing a full-blown SQL parser is inherently flawed. Since we don't want to write an SQL parser, we are removing this functionality. From now on, you must explicitly tell Active Record when you are referencing a table from a string:



    Post.includes(:comments).where("comments.title = 'foo'").references(:comments)



If you don't rely on implicit join references you can disable the feature entirely by setting `config.active_record.disable_implicit_join_references = true`. (called from _app_views_requirements_index_html_haml__4490160196590661920_171876180 at /home/travis/build/Liaison-Intl/WebAdMIT/app/views/requirements/index.html.haml:17)

DEPRECATION WARNING: It looks like you are eager loading table(s) (one of: requirements, criteria) that are referenced in a string SQL snippet. For example:



    Post.includes(:comments).where("comments.title = 'foo'")



Currently, Active Record recognizes the table in the string, and knows to JOIN the comments table to the query, rather than loading comments in a separate query. However, doing this without writing a full-blown SQL parser is inherently flawed. Since we don't want to write an SQL parser, we are removing this functionality. From now on, you must explicitly tell Active Record when you are referencing a table from a string:



    Post.includes(:comments).where("comments.title = 'foo'").references(:comments)



If you don't rely on implicit join references you can disable the feature entirely by setting `config.active_record.disable_implicit_join_references = true`. (called from find_requirement at /home/travis/build/Liaison-Intl/WebAdMIT/app/controllers/requirements_controller.rb:103)

DEPRECATION WARNING: It looks like you are eager loading table(s) (one of: requirements, criteria) that are referenced in a string SQL snippet. For example:



    Post.includes(:comments).where("comments.title = 'foo'")



Currently, Active Record recognizes the table in the string, and knows to JOIN the comments table to the query, rather than loading comments in a separate query. However, doing this without writing a full-blown SQL parser is inherently flawed. Since we don't want to write an SQL parser, we are removing this functionality. From now on, you must explicitly tell Active Record when you are referencing a table from a string:



    Post.includes(:comments).where("comments.title = 'foo'").references(:comments)



If you don't rely on implicit join references you can disable the feature entirely by setting `config.active_record.disable_implicit_join_references = true`. (called from block in _app_views_requirements_index_html_haml__4490160196590661920_171876180 at /home/travis/build/Liaison-Intl/WebAdMIT/app/views/requirements/index.html.haml:12)

DEPRECATION WARNING: It looks like you are eager loading table(s) (one of: requirements, criteria) that are referenced in a string SQL snippet. For example:



    Post.includes(:comments).where("comments.title = 'foo'")



Currently, Active Record recognizes the table in the string, and knows to JOIN the comments table to the query, rather than loading comments in a separate query. However, doing this without writing a full-blown SQL parser is inherently flawed. Since we don't want to write an SQL parser, we are removing this functionality. From now on, you must explicitly tell Active Record when you are referencing a table from a string:



    Post.includes(:comments).where("comments.title = 'foo'").references(:comments)



If you don't rely on implicit join references you can disable the feature entirely by setting `config.active_record.disable_implicit_join_references = true`. (called from _app_views_requirements_index_html_haml__4490160196590661920_171876180 at /home/travis/build/Liaison-Intl/WebAdMIT/app/views/requirements/index.html.haml:17)

DEPRECATION WARNING: It looks like you are eager loading table(s) (one of: requirements, criteria) that are referenced in a string SQL snippet. For example:



    Post.includes(:comments).where("comments.title = 'foo'")



Currently, Active Record recognizes the table in the string, and knows to JOIN the comments table to the query, rather than loading comments in a separate query. However, doing this without writing a full-blown SQL parser is inherently flawed. Since we don't want to write an SQL parser, we are removing this functionality. From now on, you must explicitly tell Active Record when you are referencing a table from a string:



    Post.includes(:comments).where("comments.title = 'foo'").references(:comments)



If you don't rely on implicit join references you can disable the feature entirely by setting `config.active_record.disable_implicit_join_references = true`. (called from find_requirement at /home/travis/build/Liaison-Intl/WebAdMIT/app/controllers/requirements_controller.rb:103)

DEPRECATION WARNING: It looks like you are eager loading table(s) (one of: requirements, criteria) that are referenced in a string SQL snippet. For example:



    Post.includes(:comments).where("comments.title = 'foo'")



Currently, Active Record recognizes the table in the string, and knows to JOIN the comments table to the query, rather than loading comments in a separate query. However, doing this without writing a full-blown SQL parser is inherently flawed. Since we don't want to write an SQL parser, we are removing this functionality. From now on, you must explicitly tell Active Record when you are referencing a table from a string:



    Post.includes(:comments).where("comments.title = 'foo'").references(:comments)



If you don't rely on implicit join references you can disable the feature entirely by setting `config.active_record.disable_implicit_join_references = true`. (called from block in _app_views_requirements_index_html_haml__4490160196590661920_171876180 at /home/travis/build/Liaison-Intl/WebAdMIT/app/views/requirements/index.html.haml:12)

DEPRECATION WARNING: Relation#all is deprecated. If you want to eager-load a relation, you can call #load (e.g. `Post.where(published: true).load`). If you want to get an array of records from a relation, you can call #to_a (e.g. `Post.where(published: true).to_a`). (called from _app_views_requirements__requirement_html_haml__2195224900444059847_285679960 at /home/travis/build/Liaison-Intl/WebAdMIT/app/views/requirements/_requirement.html.haml:34)

DEPRECATION WARNING: It looks like you are eager loading table(s) (one of: requirements, criteria) that are referenced in a string SQL snippet. For example:



    Post.includes(:comments).where("comments.title = 'foo'")



Currently, Active Record recognizes the table in the string, and knows to JOIN the comments table to the query, rather than loading comments in a separate query. However, doing this without writing a full-blown SQL parser is inherently flawed. Since we don't want to write an SQL parser, we are removing this functionality. From now on, you must explicitly tell Active Record when you are referencing a table from a string:



    Post.includes(:comments).where("comments.title = 'foo'").references(:comments)



If you don't rely on implicit join references you can disable the feature entirely by setting `config.active_record.disable_implicit_join_references = true`. (called from _app_views_requirements_index_html_haml__4490160196590661920_171876180 at /home/travis/build/Liaison-Intl/WebAdMIT/app/views/requirements/index.html.haml:17)

[32m.[0mDEPRECATION WARNING: It looks like you are eager loading table(s) (one of: scoring_models, scoring_model_assignments, programs) that are referenced in a string SQL snippet. For example:



    Post.includes(:comments).where("comments.title = 'foo'")



Currently, Active Record recognizes the table in the string, and knows to JOIN the comments table to the query, rather than loading comments in a separate query. However, doing this without writing a full-blown SQL parser is inherently flawed. Since we don't want to write an SQL parser, we are removing this functionality. From now on, you must explicitly tell Active Record when you are referencing a table from a string:



    Post.includes(:comments).where("comments.title = 'foo'").references(:comments)



If you don't rely on implicit join references you can disable the feature entirely by setting `config.active_record.disable_implicit_join_references = true`. (called from score_for_scoring_models at /home/travis/build/Liaison-Intl/WebAdMIT/app/models/scoring/scorer.rb:50)

DEPRECATION WARNING: It looks like you are eager loading table(s) (one of: scoring_models, scoring_model_assignments, programs) that are referenced in a string SQL snippet. For example:



    Post.includes(:comments).where("comments.title = 'foo'")



Currently, Active Record recognizes the table in the string, and knows to JOIN the comments table to the query, rather than loading comments in a separate query. However, doing this without writing a full-blown SQL parser is inherently flawed. Since we don't want to write an SQL parser, we are removing this functionality. From now on, you must explicitly tell Active Record when you are referencing a table from a string:



    Post.includes(:comments).where("comments.title = 'foo'").references(:comments)



If you don't rely on implicit join references you can disable the feature entirely by setting `config.active_record.disable_implicit_join_references = true`. (called from score_for_scoring_models at /home/travis/build/Liaison-Intl/WebAdMIT/app/models/scoring/scorer.rb:50)

[32m.[0mDEPRECATION WARNING: It looks like you are eager loading table(s) (one of: scoring_models, scoring_model_assignments, programs) that are referenced in a string SQL snippet. For example:



    Post.includes(:comments).where("comments.title = 'foo'")



Currently, Active Record recognizes the table in the string, and knows to JOIN the comments table to the query, rather than loading comments in a separate query. However, doing this without writing a full-blown SQL parser is inherently flawed. Since we don't want to write an SQL parser, we are removing this functionality. From now on, you must explicitly tell Active Record when you are referencing a table from a string:



    Post.includes(:comments).where("comments.title = 'foo'").references(:comments)



If you don't rely on implicit join references you can disable the feature entirely by setting `config.active_record.disable_implicit_join_references = true`. (called from score_for_scoring_models at /home/travis/build/Liaison-Intl/WebAdMIT/app/models/scoring/scorer.rb:50)

DEPRECATION WARNING: It looks like you are eager loading table(s) (one of: scoring_models, scoring_model_assignments, programs) that are referenced in a string SQL snippet. For example:



    Post.includes(:comments).where("comments.title = 'foo'")



Currently, Active Record recognizes the table in the string, and knows to JOIN the comments table to the query, rather than loading comments in a separate query. However, doing this without writing a full-blown SQL parser is inherently flawed. Since we don't want to write an SQL parser, we are removing this functionality. From now on, you must explicitly tell Active Record when you are referencing a table from a string:



    Post.includes(:comments).where("comments.title = 'foo'").references(:comments)



If you don't rely on implicit join references you can disable the feature entirely by setting `config.active_record.disable_implicit_join_references = true`. (called from score_for_scoring_models at /home/travis/build/Liaison-Intl/WebAdMIT/app/models/scoring/scorer.rb:50)

[32m.[0mDEPRECATION WARNING: It looks like you are eager loading table(s) (one of: scoring_models, scoring_model_assignments, programs) that are referenced in a string SQL snippet. For example:



    Post.includes(:comments).where("comments.title = 'foo'")



Currently, Active Record recognizes the table in the string, and knows to JOIN the comments table to the query, rather than loading comments in a separate query. However, doing this without writing a full-blown SQL parser is inherently flawed. Since we don't want to write an SQL parser, we are removing this functionality. From now on, you must explicitly tell Active Record when you are referencing a table from a string:



    Post.includes(:comments).where("comments.title = 'foo'").references(:comments)



If you don't rely on implicit join references you can disable the feature entirely by setting `config.active_record.disable_implicit_join_references = true`. (called from score_for_scoring_models at /home/travis/build/Liaison-Intl/WebAdMIT/app/models/scoring/scorer.rb:50)

DEPRECATION WARNING: It looks like you are eager loading table(s) (one of: scoring_models, scoring_model_assignments, programs) that are referenced in a string SQL snippet. For example:



    Post.includes(:comments).where("comments.title = 'foo'")



Currently, Active Record recognizes the table in the string, and knows to JOIN the comments table to the query, rather than loading comments in a separate query. However, doing this without writing a full-blown SQL parser is inherently flawed. Since we don't want to write an SQL parser, we are removing this functionality. From now on, you must explicitly tell Active Record when you are referencing a table from a string:



    Post.includes(:comments).where("comments.title = 'foo'").references(:comments)



If you don't rely on implicit join references you can disable the feature entirely by setting `config.active_record.disable_implicit_join_references = true`. (called from score_for_scoring_models at /home/travis/build/Liaison-Intl/WebAdMIT/app/models/scoring/scorer.rb:50)

[32m.[0m[32m.[0m[32m.[0m[32m.[0m[32m.[0m[32m.[0m[32m.[0m

Top 5 slowest tests:

Experiences Panel Feature Test::with an experience Feature Test::without the related data Feature Test test_0001_does not show a link for most meaningful (35.49490s)

Experiences Panel Feature Test::with an experience Feature Test::with all the related data Feature Test test_0004_the details pane is correctly scoped to show proper fields (34.75664s)

Admin Association Feature Test test_0001_sets the subpanels available to the cas (13.78188s)

List Manager Applicant Count Feature Test test_0002_2 applicants with 1 designation each displays a count of 2 (7.15586s)

List Manager Applicant Count Feature Test test_0001_applicant with 2 designations displays a count of 1 (7.11487s)



Finished in 957.473007 seconds.



[1m285 tests[0m, [32m284 passed[0m, 0 failures, [33m1 errors[0m, 0 skips, 1075 assertions



[33m[Coveralls] Submitting with config:[0m

[33m{"environment":{"pwd":"/home/travis/build/Liaison-Intl/WebAdMIT","rails_root":"/home/travis/build/Liaison-Intl/WebAdMIT","simplecov_root":"/home/travis/build/Liaison-Intl/WebAdMIT","gem_version":"0.7.1","travis_job_id":"86779313","travis_pull_request":"7014"},"git":{"head":{"id":"e2bc547a0c7b3282f9674e93a2347c30a2ef1e15","author_name":"Daniel Quimper","author_email":"dquimper@gmail.com","committer_name":"GitHub","committer_email":"noreply@github.com","message":"Merge a52902397d0e150f681e5f4c3bda6235957ed20f into a4db17d8ab9e40c37412a7aa457a5350bccc3cd0"},"branch":"(HEAD detached at FETCH_HEAD)","remotes":[{"name":"origin","url":"git@github.com:Liaison-Intl/WebAdMIT.git"}]},"configuration":{"service_name":"travis-pro","repo_token":"0amOroLLl9AglDzBaqIx86g9buOaIvgSj"},"repo_token":"0amOroLLl9AglDzBaqIx86g9buOaIvgSj","service_job_id":"86779313","service_name":"travis-pro"}[0m

[36m[Coveralls] Submitting to https://coveralls.io/api/v1[0m

[36m[Coveralls] Job #23173.13[0m

[36m[Coveralls] [4mhttps://coveralls.io/jobs/28528732[0m[0m

Coverage is at 69.0%.

Coverage report sent to Coveralls.

rake aborted!

Command failed with status (1): [ruby -I"lib:test" -I"/home/travis/build/Liaison-Intl/WebAdMIT/vendor/bundle/ruby/1.9.1/gems/rake-10.5.0/lib" "/home/travis/build/Liaison-Intl/WebAdMIT/vendor/bundle/ruby/1.9.1/gems/rake-10.5.0/lib/rake/rake_test_loader.rb" "test/integration/admin/admin_association_test.rb" "test/integration/admin/admin_manages_exports_test.rb" "test/integration/admin/admin_score_run_test.rb" "test/integration/applicant_details/applicant_gateway/document_test.rb" "test/integration/applicant_details/applicant_gateway/extend_offer_test.rb" "test/integration/applicant_details/applicant_gateway/supplemental_application_test.rb" "test/integration/applicant_details/applicant_reported_other_tests/applicant_reported_other_tests_test.rb" "test/integration/applicant_details/documents/applications_subpanel_test.rb" "test/integration/applicant_details/education/previous_matriculation_test.rb" "test/integration/applicant_details/essays/essay_test.rb" "test/integration/applicant_details/experiences/experience_animal_experiences_test.rb" "test/integration/applicant_details/experiences/experiences_comprehensive_test.rb" "test/integration/applicant_details/experiences/experiences_test.rb" "test/integration/applicant_details/experiences/ministry_experience_test.rb" "test/integration/applicant_details/gpa_overview/by_local_gpa_test.rb" "test/integration/applicant_details/infractions/infractions_test.rb" "test/integration/applicant_details/licenses_certifications/licenses_test.rb" "test/integration/applicant_details/personal_statement/essay_test.rb" "test/integration/applicant_details/standardized_tests/dat_canada_test.rb" "test/integration/applicant_details/standardized_tests/dat_test.rb" "test/integration/applicant_details/standardized_tests/official_mcat_after_jan_31_2015_test.rb" "test/integration/applicant_details/standardized_tests/official_oat_test.rb" "test/integration/applicant_details/standardized_tests/official_pcat_test.rb" "test/integration/applicant_details/standardized_tests/official_pte_test.rb" "test/integration/applicant_details/standardized_tests/sat_official_before_march_2016_test.rb" "test/integration/applicant_details/supplemental_questions/supplemental_questions_test.rb" "test/integration/applicants_old_checks_test.rb" "test/integration/csrf_protection_test.rb" "test/integration/email_template_test.rb" "test/integration/email_test.rb" "test/integration/first_time_user_test.rb" "test/integration/footer_test.rb" "test/integration/institution_user_identity/dashboard_test.rb" "test/integration/interviews/interview_availability_test.rb" "test/integration/list_manager/batch_schedule_interview_modal_test.rb" "test/integration/list_manager/list_manager_count_test.rb" "test/integration/lists/clipboard_test.rb" "test/integration/local_statuses_test.rb" "test/integration/password_reset_test.rb" "test/integration/pdf_manager/create_template_test.rb" "test/integration/pdf_manager_test.rb" "test/integration/programs/security_test.rb" "test/integration/reports/feeder_school_report_test.rb" "test/integration/search/user_searches_on_hold_applicants_test.rb" "test/integration/search/user_searches_received_applicants_test.rb" "test/integration/sidebar_help_test.rb" "test/integration/sidebar_test.rb" "test/integration/user_manages_assigment_types_test.rb" "test/integration/user_manages_requirements_test.rb" ]



Tasks: TOP => minitest:integration_split

(See full trace by running task with --trace)
